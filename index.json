[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/abstracts/cliCommand.js",
    "content": "/**\n * A helper class for creating commands for the CLI.\n * @abstract\n * @version 1.0\n */\nclass CLICommand {\n  /**\n   * Class constructor.\n   * @throws {TypeError} If instantiated directly.\n   * @abstract\n   */\n  constructor() {\n    if (new.target === CLICommand) {\n      throw new TypeError(\n        'CLICommand is an abstract class, it can\\'t be instantiated directly'\n      );\n    }\n    /**\n     * The CLI command instruction. For example `my-command [target]`.\n     * @type {string}\n     */\n    this.command = '';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = '';\n    /**\n     * A more complete description of the command to show when the command help interface is\n     * invoked.\n     * If left empty, it won't be used.\n     * @type {string}\n     */\n    this.fullDescription = '';\n    /**\n     * A list with the name of the options the command supports. New options can be added using\n     * the `addOption` method.\n     * @type {Array}\n     */\n    this.options = [];\n    /**\n     * A dictionary of command options settings by their option name. New options can be added\n     * using the `addOption` method.\n     * @type {Object}\n     */\n    this.optionsByName = {};\n    /**\n     * This is a useful flag for when the command is ran as a result of another command. It lets\n     * the interface know that it can search for option values on a parent command, if there's one.\n     * @type {boolean}\n     */\n    this.checkOptionsOnParent = true;\n    /**\n     * Whether the command and its description should be shown on the CLI interface list of\n     * commands.\n     * @type {boolean}\n     */\n    this.hidden = false;\n    /**\n     * Whether or not a sub program should be executed for this command. Take for example the case\n     * of `git`, where `git checkout [branch]` executes `git` as main program, and `checkout` as a\n     * sub program. If this is `true`, then a binary with the name of the command should be\n     * exported on the `package.json`.\n     * @type {boolean}\n     */\n    this.subProgram = false;\n    /**\n     * This is the name of the program that runs the command. It will be added when the command\n     * is registered on the program.\n     * @type {string}\n     */\n    this.cliName = '';\n    /**\n     * Whether or not the command supports unknown options. If it does, it will be sent to the\n     * `onActivation` method as a parameter.\n     * @type {Boolean}\n     */\n    this.allowUnknownOptions = false;\n    /**\n     * This dictionary will be completed when the command gets activated. If the command supports\n     * unknown options (`allowUnknownOptions`), they'll be parsed and sent to the `handle` method\n     * as the last parameter.\n     * @type {Object}\n     */\n    this._unknownOptions = {};\n    /**\n     * Once registered on the program, this property will hold a reference to the real command\n     * the program generates.\n     * @type {?Command}\n     * @ignore\n     * @access protected\n     */\n    this._command = null;\n  }\n  /**\n   * Add a new option for the command.\n   * @example\n   * // To capture an option\n   * this.addOption(\n   *   'type',\n   *   '-t, --type [type]',\n   *   'The type of thingy you want to use?',\n   * );\n   *\n   * // As a simple flag\n   * this.addOption(\n   *   'ready',\n   *   '-r, --ready',\n   *   'Is it read?',\n   *   false\n   * );\n   *\n   * @param {string} name              The option name.\n   * @param {string} instruction       The option instruction, for example: `-t, --type [type]`.\n   * @param {string} [description='']  The option description.\n   * @param {string} [defaultValue=''] The option default value, in case is not used on execution.\n   */\n  addOption(name, instruction, description = '', defaultValue = '') {\n    this.optionsByName[name] = {\n      name,\n      instruction,\n      description,\n      defaultValue,\n    };\n\n    this.options.push(name);\n  }\n  /**\n   * Register this command on a CLI program.\n   * @param {Command} program  A Commander instance.\n   * @param {Object}  cli      The main CLI interface, just for the name.\n   * @param {string}  cli.name The CLI interface name.\n   * @see https://yarnpkg.com/en/package/commander\n   */\n  register(program, cli) {\n    // Get the real name of the command.\n    const commandName = this.command.replace(/\\[\\w+\\]/g, '').trim();\n    // Set a listener on the program in order to detect when it gets executed.\n    program.on(`command:${commandName}`, (args, unknown) => this._onActivation(args, unknown));\n    // Get the name of the program\n    this.cliName = cli.name;\n    const options = {};\n    // If the command should be hidden...\n    if (this.hidden) {\n      // ...remove it from the help interface.\n      options.noHelp = true;\n    }\n\n    let command;\n    // If the command is a sub program...\n    if (this.subProgram) {\n      /**\n       * ...it gets added without the `.description` property. That's how Commander differentiates\n       * a main program command and a sub program command.\n       */\n      command = program.command(this.command, this.description, options);\n    } else {\n      // ...otherwise, it gets added as a sub command of the main program.\n      command = program\n      .command(this.command, '', options)\n      .description(this.description);\n    }\n    // Register all the command options.\n    this.options.forEach((name) => {\n      const option = this.optionsByName[name];\n      command = command.option(\n        option.instruction,\n        option.description\n      );\n    });\n    // Add the handler for when the command gets executed.\n    command.action(this._handle.bind(this));\n    // Enable unknown options if the command supports it\n    command.allowUnknownOption(this.allowUnknownOptions);\n    // Save the reference\n    this._command = command;\n  }\n  /**\n   * Generate an instruction for this command.\n   * @example\n   * // Let's say this command is `destroy [target] [--once]`\n   *\n   * this.generate({ target: 'pluto' });\n   * // Will return `destroy pluto`\n   *\n   * this.generate({ target: 'moon', once: true });\n   * // Will return `destroy moon --once`\n   * @param  {Object} [args={}] A dictionary with the arguments and options for the command. If the\n   *                            command includes an argument on its `command` property, that\n   *                            argument is required.\n   * @return {string} The command instruction to run on the CLI interface.\n   */\n  generate(args = {}) {\n    let cmd = this.command;\n    const cmdOptions = [];\n    // Loop all the `args`...\n    Object.keys(args).forEach((name) => {\n      const value = args[name];\n      const asPlaceholder = `[${name}]`;\n      // Check if the current argument should be used on the command instruction...\n      if (cmd.includes(asPlaceholder)) {\n        // ...if so, replace it on the main command.\n        cmd = cmd.replace(asPlaceholder, value);\n      } else if (this.optionsByName[name]) {\n        // ...otherwise, check if there's an option with the same name as the argument.\n        const option = this.optionsByName[name];\n        /**\n         * Remove the shorthand version of the option instruction, if there's one. For example:\n         * `-t, --type [type]` -> `--type [type]`.\n         */\n        let instruction = option.instruction.split(',').pop().trim();\n        // If the option instruction includes the argument as a value (`[argument-name]`)...\n        if (instruction.includes(asPlaceholder)) {\n          // ...replace it on the option instruction.\n          instruction = instruction.replace(asPlaceholder, value);\n        } else if (value === false) {\n          /**\n           * ...but if the value is `false`, then we clear the instruction as it won't be included\n           * on the generated string.\n           */\n          instruction = '';\n        }\n\n        // If there's an option instruction...\n        if (instruction) {\n          // ...add it to the list.\n          cmdOptions.push(instruction);\n        }\n      } else if (this.allowUnknownOptions) {\n        /**\n         * Finally, if is not on the command options and the command supports unknown options,\n         * just add it.\n         */\n        let instruction = `--${name}`;\n        // If the option is not a flag, add its value.\n        if (value !== true) {\n          instruction += ` ${value}`;\n        }\n        // Push it to the list\n        cmdOptions.push(instruction);\n      }\n    });\n\n    let options = '';\n    // If after the loop, there are option instructions to add...\n    if (cmdOptions.length) {\n      // ...put them all together on a single string, separated by a space\n      options = ['', ...cmdOptions].join(' ');\n    }\n\n    // Return the complete command instruction\n    return `${this.cliName} ${cmd}${options}`;\n  }\n  /**\n   * Handle the command execution.\n   * This method will receive first the captured arguments, then the executed command information\n   * from Commander and finally, a dictionary with the options and their values.\n   * @example\n   * // Let's say the command is `run [target] [--production]`.\n   * // And now, it was executed with `run my-target`\n   * handle(target, command, options) {\n   *   console.log(target);\n   *   // Will output `my-target`\n   *   console.log(options.production)\n   *   // Will output `false`\n   * }\n   * @throws {Error} if not overwritten.\n   * @abstract\n   */\n  handle() {\n    throw new Error('This method must be overwritten');\n  }\n  /**\n   * A simple wrapper for a `console.log`. Outputs a variable to the CLI interface.\n   * @param {string} text The text to output.\n   */\n  output(text) {\n    // eslint-disable-next-line no-console\n    console.log(text);\n  }\n  /**\n   * This is the real method that receives the execution of the command and parses it in order to\n   * create the options dictionary that the `handle` method receives.\n   * @param {Array} args The list of arguments sent by Commander.\n   * @ignore\n   * @access protected\n   */\n  _handle(...args) {\n    // The actual command is always the last argument.\n    const command = args[args.length - 1];\n    const options = {};\n    // Loop all the known options the command can receive\n    Object.keys(this.optionsByName).forEach((name) => {\n      const option = this.optionsByName[name];\n      let value = '';\n      // If the option is on the command...\n      if (command[name]) {\n        // ...then that's the value that will be used.\n        value = command[name];\n      }\n\n      /**\n       * If no value was found yet, the flag to check on the parent is `true`, there's a parent\n       * command and it has an option with that name...\n       */\n      if (\n        !value &&\n        this.checkOptionsOnParent &&\n        command.parent &&\n        command.parent[name]\n      ) {\n        // ...then that's the value that will be used.\n        value = command.parent[name];\n      }\n      // If no value was found and there's a default value registered for the option...\n      if (!value && typeof option.defaultValue !== 'undefined') {\n        // ...then that's the value that will be used.\n        value = option.defaultValue;\n      }\n\n      // Set the option on the dictionary with the value found.\n      options[name] = value;\n    });\n\n    // Copy the arguments list.\n    const newArgs = args.slice();\n    // Add the new options dictionary.\n    newArgs.push(options);\n    // If the method supports unknown options, add them as the last argument.\n    if (this.allowUnknownOptions) {\n      newArgs.push(this._unknownOptions);\n    }\n    // Call the abstract method that handles the execution.\n    this.handle(...newArgs);\n  }\n  /**\n   * This method gets called by the program when the command is executed and it takes care of\n   * switching the descriptions, if needed, and parsing the unknown options, if supported.\n   * @param {Array} args        The list of known arguments the command received.\n   * @param {Array} unknownArgs The list of unknown arguments the command received.\n   * @ignore\n   * @protected\n   */\n  _onActivation(args, unknownArgs) {\n    // Switch the descriptions.\n    this._updateDescription();\n    // If unknown options are allowed, parsed them and save them on the local property.\n    if (this.allowUnknownOptions && unknownArgs && unknownArgs.length) {\n      this._unknownOptions = this._parseArgs(unknownArgs);\n    }\n  }\n  /**\n   * This method gets called when the command is executed on the program and before reaching the\n   * handle method. It checks if the command has a different description for when it gets\n   * executed, and if needed, it switches it on the program.\n   * @ignore\n   * @access protected\n   */\n  _updateDescription() {\n    // If the command reference is available and there's a full description...\n    if (this.fullDescription) {\n      // ...normalize it by adding the indentation the program uses to show descriptions and help.\n      const normalizedDescription = this.fullDescription.replace(/\\n/g, '\\n  ');\n      // Change the command description.\n      this._command.description(normalizedDescription);\n    }\n  }\n  /**\n   * This method parses a list of CLI arguments into a dicitionary.\n   * @example\n   * const args = [\n   *   '--include=something',\n   *   '-i',\n   *   'somes',\n   *   '--exclude',\n   *   '--type',\n   *   'building',\n   *   '-x=y',\n   * ];\n   * console.log(this._parseArgs(args));\n   * // Will output `{include: 'something', i: 'somes', exclude: true, type: 'building', x: 'y'}`\n   * @param {Array} args A list of arguments.\n   * @return {Object}\n   * @ignore\n   * @access protected\n   */\n  _parseArgs(args) {\n    // Use Commander to normalize the arguments list.\n    const list = this._command.normalize(args);\n    // Define the dictionary to return.\n    const parsed = {};\n    /**\n     * Define the regex that will validate if an argument is an _\"option header\"_ (`--[something]`)\n     * or a value.\n     */\n    const headerRegex = /^-(?:-)?/;\n    /**\n     * Every time the loop finds a header, it will be set on this variable, so the next time a value\n     * is found, it can be assigned to that header on the return dictionary.\n     */\n    let currentHeader;\n    /**\n     * The commander `normalize` method transforms `-x=y` into `['-x', '-=', '-y']`. On the first\n     * iteration, `-x` will be marked as a header, on the following iteration, the loop will check\n     * for `-=`, ignore it and mark this variable as `true` so on the final iteration, despite the\n     * fact that the value starts `-`, the method should remove the `-` and save it as a value for\n     * `-x`.\n     */\n    let nextValue = false;\n    // Loop the list...\n    list.forEach((item) => {\n      // Check whether the current item is a header or not.\n      const isHeader = item.match(headerRegex);\n      // If it is a header...\n      if (isHeader) {\n        // ...and the flag for short instructions is `true`...\n        if (nextValue) {\n          // ...remove the leading `-` and save it as a value for the current header.\n          parsed[currentHeader] = item.substr(1);\n          // Reset the flags.\n          currentHeader = null;\n          nextValue = false;\n        } else if (currentHeader && item === '-=') {\n          /**\n           * If there's a header and the current argument is `-=`, set the flag for short\n           * instructions to `true`.\n           */\n          nextValue = true;\n        } else if (currentHeader) {\n          /**\n           * If this is another header, it means that the argument is a flag, so save the current\n           * header as `true` and change the current header to the current item.\n           */\n          parsed[currentHeader] = true;\n          currentHeader = item.replace(headerRegex, '');\n        } else {\n          // Set the current header to the current item.\n          currentHeader = item.replace(headerRegex, '');\n        }\n      } else if (currentHeader) {\n        /**\n         * If there's a header, this means the current item is a value, so set it to the current\n         * header and reset the variable.\n         */\n        parsed[currentHeader] = item;\n        currentHeader = null;\n      }\n    });\n    // Return the parsed object.\n    return parsed;\n  }\n}\n\nmodule.exports = CLICommand;\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/abstracts/cliCommand.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CLICommand",
    "memberof": "src/abstracts/cliCommand.js",
    "static": true,
    "longname": "src/abstracts/cliCommand.js~CLICommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/abstracts/cliCommand.js",
    "importStyle": "CLICommand",
    "description": "A helper class for creating commands for the CLI.",
    "lineNumber": 6,
    "version": "1.0",
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12,
    "abstract": true,
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "If instantiated directly."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "command",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#command",
    "access": "public",
    "description": "The CLI command instruction. For example `my-command [target]`.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "description",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "fullDescription",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#fullDescription",
    "access": "public",
    "description": "A more complete description of the command to show when the command help interface is\ninvoked.\nIf left empty, it won't be used.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "options",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#options",
    "access": "public",
    "description": "A list with the name of the options the command supports. New options can be added using\nthe `addOption` method.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "optionsByName",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#optionsByName",
    "access": "public",
    "description": "A dictionary of command options settings by their option name. New options can be added\nusing the `addOption` method.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "checkOptionsOnParent",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#checkOptionsOnParent",
    "access": "public",
    "description": "This is a useful flag for when the command is ran as a result of another command. It lets\nthe interface know that it can search for option values on a parent command, if there's one.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#hidden",
    "access": "public",
    "description": "Whether the command and its description should be shown on the CLI interface list of\ncommands.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "subProgram",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#subProgram",
    "access": "public",
    "description": "Whether or not a sub program should be executed for this command. Take for example the case\nof `git`, where `git checkout [branch]` executes `git` as main program, and `checkout` as a\nsub program. If this is `true`, then a binary with the name of the command should be\nexported on the `package.json`.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "cliName",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#cliName",
    "access": "public",
    "description": "This is the name of the program that runs the command. It will be added when the command\nis registered on the program.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#allowUnknownOptions",
    "access": "public",
    "description": "Whether or not the command supports unknown options. If it does, it will be sent to the\n`onActivation` method as a parameter.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "_unknownOptions",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_unknownOptions",
    "access": "private",
    "description": "This dictionary will be completed when the command gets activated. If the command supports\nunknown options (`allowUnknownOptions`), they'll be parsed and sent to the `handle` method\nas the last parameter.",
    "lineNumber": 85,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_command",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_command",
    "access": "protected",
    "description": "Once registered on the program, this property will hold a reference to the real command\nthe program generates.",
    "lineNumber": 93,
    "ignore": true,
    "type": {
      "nullable": true,
      "types": [
        "Command"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "addOption",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#addOption",
    "access": "public",
    "description": "Add a new option for the command.",
    "examples": [
      "// To capture an option\nthis.addOption(\n  'type',\n  '-t, --type [type]',\n  'The type of thingy you want to use?',\n);\n\n// As a simple flag\nthis.addOption(\n  'ready',\n  '-r, --ready',\n  'Is it read?',\n  false\n);"
    ],
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The option name."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instruction",
        "description": "The option instruction, for example: `-t, --type [type]`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "description",
        "description": "The option description."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "defaultValue",
        "description": "The option default value, in case is not used on execution."
      }
    ],
    "return": null
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "register",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#register",
    "access": "public",
    "description": "Register this command on a CLI program.",
    "see": [
      "https://yarnpkg.com/en/package/commander"
    ],
    "lineNumber": 135,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "program",
        "description": "A Commander instance."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "cli",
        "description": "The main CLI interface, just for the name."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "cli.name",
        "description": "The CLI interface name."
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "generate",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#generate",
    "access": "public",
    "description": "Generate an instruction for this command.",
    "examples": [
      "// Let's say this command is `destroy [target] [--once]`\n\nthis.generate({ target: 'pluto' });\n// Will return `destroy pluto`\n\nthis.generate({ target: 'moon', once: true });\n// Will return `destroy moon --once`"
    ],
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "args",
        "description": "A dictionary with the arguments and options for the command. If the\n                           command includes an argument on its `command` property, that\n                           argument is required."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The command instruction to run on the CLI interface."
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "handle",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#handle",
    "access": "public",
    "description": "Handle the command execution.\nThis method will receive first the captured arguments, then the executed command information\nfrom Commander and finally, a dictionary with the options and their values.",
    "examples": [
      "// Let's say the command is `run [target] [--production]`.\n// And now, it was executed with `run my-target`\nhandle(target, command, options) {\n  console.log(target);\n  // Will output `my-target`\n  console.log(options.production)\n  // Will output `false`\n}"
    ],
    "lineNumber": 270,
    "abstract": true,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if not overwritten."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "output",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#output",
    "access": "public",
    "description": "A simple wrapper for a `console.log`. Outputs a variable to the CLI interface.",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "The text to output."
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "_handle",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_handle",
    "access": "protected",
    "description": "This is the real method that receives the execution of the command and parses it in order to\ncreate the options dictionary that the `handle` method receives.",
    "lineNumber": 288,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "The list of arguments sent by Commander."
      }
    ],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "_onActivation",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_onActivation",
    "access": "protected",
    "description": "This method gets called by the program when the command is executed and it takes care of\nswitching the descriptions, if needed, and parsing the unknown options, if supported.",
    "lineNumber": 344,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "The list of known arguments the command received."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownArgs",
        "description": "The list of unknown arguments the command received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "_updateDescription",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_updateDescription",
    "access": "protected",
    "description": "This method gets called when the command is executed on the program and before reaching the\nhandle method. It checks if the command has a different description for when it gets\nexecuted, and if needed, it switches it on the program.",
    "lineNumber": 359,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "_parseArgs",
    "memberof": "src/abstracts/cliCommand.js~CLICommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliCommand.js~CLICommand#_parseArgs",
    "access": "protected",
    "description": "This method parses a list of CLI arguments into a dicitionary.",
    "examples": [
      "const args = [\n  '--include=something',\n  '-i',\n  'somes',\n  '--exclude',\n  '--type',\n  'building',\n  '-x=y',\n];\nconsole.log(this._parseArgs(args));\n// Will output `{include: 'something', i: 'somes', exclude: true, type: 'building', x: 'y'}`"
    ],
    "lineNumber": 387,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "A list of arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/abstracts/cliSubCommand.js",
    "content": "/**\n * A helper class for creating sub commands for the CLI. A sub command works like a\n * {@link CLICommand} inside a regular {@link CLICommand}.\n * @abstract\n * @version 1.0\n */\nclass CLISubCommand {\n  /**\n   * Class constructor.\n   * @throws {TypeError} If instantiated directly.\n   * @abstract\n   */\n  constructor() {\n    if (new.target === CLISubCommand) {\n      throw new TypeError(\n        'CLISubCommand is an abstract class, it can\\'t be instantiated directly'\n      );\n    }\n    /**\n     * The name of the sub command for the help interface.\n     * @type {string}\n     */\n    this.name = '';\n    /**\n     * A short description for what the generator does.\n     * @type {string}\n     */\n    this.description = '';\n    /**\n     * A list with the name of the options the generator supports. New options can be added using\n     * the `addOption` method.\n     * @type {Array}\n     */\n    this.options = [];\n    /**\n     * A dictionary of options settings by their option name. New options can be added using\n     * the `addOption` method.\n     * @type {Object}\n     */\n    this.optionsByName = {};\n  }\n  /**\n   * Add a new option for the command.\n   * @example\n   * // To capture an option\n   * this.addOption(\n   *   'type',\n   *   '-t, --type [type]',\n   *   'The type of thingy you want to use?',\n   * );\n   *\n   * // As a simple flag\n   * this.addOption(\n   *   'ready',\n   *   '-r, --ready',\n   *   'Is it read?',\n   *   false\n   * );\n   *\n   * @param {string} name              The option name.\n   * @param {string} instruction       The option instruction, for example: `-t, --type [type]`.\n   * @param {string} [description='']  The option description.\n   * @param {string} [defaultValue=''] The option default value, in case is not used on execution.\n   */\n  addOption(name, instruction, description = '', defaultValue = '') {\n    this.optionsByName[name] = {\n      name,\n      instruction,\n      description,\n      defaultValue,\n    };\n\n    this.options.push(name);\n  }\n  /**\n   * Generates a complete description of the sub command and its options in order to be used on the\n   * help interface of the {@link CLICommand} that implements it.\n   * @return {string}\n   */\n  getHelpInformation() {\n    // Define the basic description line.\n    let description = ` - '${this.name}': ${this.description}`;\n    // If the generator has options...\n    if (this.options.length) {\n      // ...add the options subtitle.\n      description += '\\n   Options:\\n';\n      /**\n       * Loop all the options and find the one with the longest instruction to calculate the\n       * necessary padding in order to show all instructions on a _\"fixed width column\"_ style.\n       */\n      let longest = '';\n      this.options.forEach((optionName) => {\n        const option = this.optionsByName[optionName];\n        if (option.instruction.length > longest.length) {\n          longest = option.instruction;\n        }\n      });\n      // Once the longest instruction is saved, loop all the options again...\n      this.options.forEach((optionName) => {\n        const option = this.optionsByName[optionName];\n        // Set the instruction as the initial value of the description.\n        let line = option.instruction;\n        // If the instruction is shorter than the longest, add the necessary padding.\n        if (line.length < longest.length) {\n          line += (new Array(longest.length - line.length)).fill(' ').join('');\n        }\n        // Add the option description after the instruction, and possibly the padding.\n        line += `  ${option.description}`;\n        // Add the description to the generator description.\n        description += `\\n   ${line}`;\n      });\n    }\n\n    return description;\n  }\n  /**\n   * The method called by the {@link CLICommand} that implements the sub command.\n   * It receives a dicitionary with the parsed options the command received.\n   * @throws {Error} if not overwritten.\n   * @abstract\n   */\n  handle() {\n    throw new Error('This method must to be overwritten');\n  }\n}\n\nmodule.exports = CLISubCommand;\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/abstracts/cliSubCommand.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "class",
    "name": "CLISubCommand",
    "memberof": "src/abstracts/cliSubCommand.js",
    "static": true,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/abstracts/cliSubCommand.js",
    "importStyle": "CLISubCommand",
    "description": "A helper class for creating sub commands for the CLI. A sub command works like a\n{@link CLICommand} inside a regular {@link CLICommand}.",
    "lineNumber": 7,
    "version": "1.0",
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "abstract": true,
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "If instantiated directly."
      }
    ]
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "name",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#name",
    "access": "public",
    "description": "The name of the sub command for the help interface.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "description",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#description",
    "access": "public",
    "description": "A short description for what the generator does.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "options",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#options",
    "access": "public",
    "description": "A list with the name of the options the generator supports. New options can be added using\nthe `addOption` method.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "optionsByName",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#optionsByName",
    "access": "public",
    "description": "A dictionary of options settings by their option name. New options can be added using\nthe `addOption` method.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "addOption",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#addOption",
    "access": "public",
    "description": "Add a new option for the command.",
    "examples": [
      "// To capture an option\nthis.addOption(\n  'type',\n  '-t, --type [type]',\n  'The type of thingy you want to use?',\n);\n\n// As a simple flag\nthis.addOption(\n  'ready',\n  '-r, --ready',\n  'Is it read?',\n  false\n);"
    ],
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The option name."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instruction",
        "description": "The option instruction, for example: `-t, --type [type]`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "description",
        "description": "The option description."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "defaultValue",
        "description": "The option default value, in case is not used on execution."
      }
    ],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "getHelpInformation",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#getHelpInformation",
    "access": "public",
    "description": "Generates a complete description of the sub command and its options in order to be used on the\nhelp interface of the {@link CLICommand} that implements it.",
    "lineNumber": 80,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "handle",
    "memberof": "src/abstracts/cliSubCommand.js~CLISubCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/cliSubCommand.js~CLISubCommand#handle",
    "access": "public",
    "description": "The method called by the {@link CLICommand} that implements the sub command.\nIt receives a dicitionary with the parsed options the command received.",
    "lineNumber": 122,
    "abstract": true,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if not overwritten."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/abstracts/configurationFile.js",
    "content": "const fs = require('fs-extra');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst path = require('path');\n/**\n * A helper class for creating configuration files that can be overwritten on\n * implementation.\n * @abstract\n * @version 1.0\n */\nclass ConfigurationFile {\n  /**\n   * Class constructor.\n   * @param {PathUtils}         pathUtils            To build the path to the overwrite file.\n   * @param {string|Array}      overwritePaths       A path of a list of paths for files that can\n   *                                                 overwrite the configuration. If used as a\n   *                                                 string, it will assume the path is inside\n   *                                                 the `config` folder, but if used as a list, the\n   *                                                 paths will be relative to the project root\n   *                                                 directory.\n   *                                                 If used as an array, the class will use the\n   *                                                 first file of the list that exists and ignore\n   *                                                 the rest.\n   * @param {boolean}           [asFactory=false]    If `true`, every time `getConfig` gets called,\n   *                                                 the configuration will be created again,\n   *                                                 instead of caching it the first time it's\n   *                                                 created.\n   * @param {?ConfigurationFile} [parentConfig=null] If this parameter is used, the configuration\n   *                                                 created by the instance will be merged on top\n   *                                                 of the configuration returned by the\n   *                                                 `getConfig` method of the parent configuration.\n   * @throws {TypeError} If instantiated directly.\n   * @abstract\n   */\n  constructor(pathUtils, overwritePaths, asFactory = false, parentConfig = null) {\n    if (new.target === ConfigurationFile) {\n      throw new TypeError(\n        'ConfigurationFile is an abstract class, it can\\'t be instantiated directly'\n      );\n    }\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * A list of paths that can overwrite the configuration.\n     * @type {Array}\n     */\n    this.overwritePaths = (typeof overwritePaths === 'string') ?\n      [path.join('config', overwritePaths)] :\n      (overwritePaths || []);\n    /**\n     * Whether the configuration should be created every time `getConfig` gets called or not.\n     * @type {boolean}\n     */\n    this.asFactory = asFactory;\n    /**\n     * A parent configuration to extend.\n     * @type {?ConfigurationFile}\n     */\n    this.parentConfig = parentConfig;\n    /**\n     * This will store the configuration after creating it.\n     * @type {?Object}\n     * @ignore\n     * @access protected\n     */\n    this._config = null;\n    /**\n     * A flag to know if the overwrite file has been loaded or not.\n     * @type {boolean}\n     * @ignore\n     * @access protected\n     */\n    this._fileConfigLoaded = false;\n    /**\n     * A function that eventually will return the changes from the overwrite file. Once the file\n     * is loaded, if the file exports a function, then it will replace this variable, otherwise, the\n     * return value of this method will be become the exported configuration.\n     * @return {Object}\n     * @ignore\n     * @access protected\n     */\n    this._fileConfig = () => ({});\n  }\n  /**\n   * This method will be called the first time `getConfig` gets called (or every time, depending on\n   * the value of the `asFactory` property) and it should return the configuration contents.\n   * As parameters, it will return the same ones sent to `getConfig`.\n   * @example\n   * // Let's say the class receives this call: `getConfig({ name: 'Charito'}, 'hello')`, you could\n   * // do something like this:\n   * createConfig(options, prefix) {\n   *   return { message: `${prefix} ${options.name}` };\n   * }\n   * // And the configuration would be `{ message: 'hello Charito'}`\n   * @throws {Error} if not overwritten.\n   * @abstract\n   */\n  createConfig() {\n    throw new Error('This method must to be overwritten');\n  }\n  /**\n   * This is the public method all other services uses to obtain the configuration. If the\n   * configuration doesn't exists or `asFactory` was set to `true` on the `constructor`, the\n   * configuration will be reloaded.\n   * @param  {Array} args A list of parameters for the service to use when creating the\n   *                      configuration\n   * @return {Object}\n   */\n  getConfig(...args) {\n    if (!this._config || this.asFactory) {\n      this._loadConfig(...args);\n    }\n\n    return this._config;\n  }\n  /**\n   * This is the real method that creates the configuration.\n   * @param  {Array} args A list of parameters for the service to use when creating the\n   *                      configuration\n   * @ignore\n   * @access protected\n   */\n  _loadConfig(...args) {\n    // If the overwrite file wasn't loaded yet...\n    if (!this._fileConfigLoaded) {\n      // ...turn on the flag that says it was loaded.\n      this._fileConfigLoaded = true;\n      // Call the method that loads the file.\n      this._loadConfigFromFile();\n    }\n\n    let parentConfig = {};\n    // If a parent configuration was defined on the constructor...\n    if (this.parentConfig) {\n      /**\n       * Get its configuration by calling its `getConfig` method with the same parameters this\n       * method received.\n       */\n      parentConfig = this.parentConfig.getConfig(...args);\n    }\n    // Define the current configuration using the parent one.\n    let currentConfig = ObjectUtils.copy(parentConfig);\n    // Create a new set of arguments by adding the current configuration at the end.\n    let currentArgs = [...args, currentConfig];\n    // Update the current configuration by calling `createConfig` with the new arguments.\n    currentConfig = ObjectUtils.merge(currentConfig, this.createConfig(...currentArgs));\n    // Update the arguments with the \"new current configuration\".\n    currentArgs = [...args, currentConfig];\n    // Finally, call the method for the overwrite file and merge everything together.\n    this._config = ObjectUtils.merge(currentConfig, this._fileConfig(...currentArgs));\n  }\n  /**\n   * Load the configuration from an overwrite file.\n   * @ignore\n   * @access protected\n   */\n  _loadConfigFromFile() {\n    const filepath = this.overwritePaths\n    .map((overwrite) => this.pathUtils.join(overwrite))\n    .find((overwrite) => fs.pathExistsSync(overwrite));\n    // If there's a file...\n    if (filepath) {\n      // ...require it\n      // eslint-disable-next-line global-require, import/no-dynamic-require\n      const overwriteContents = require(filepath);\n      // If the file exported anything...\n      if (overwriteContents) {\n        // ...get the type of whatever the file exported.\n        const overwriteType = typeof overwriteContents;\n        // If the file exported a function...\n        if (overwriteType === 'function') {\n          // ...set it as the `_fileConfig` property.\n          this._fileConfig = overwriteContents;\n        } else {\n          // ...otherwise, set the `_fileConfig` property to return whatever the file exported.\n          this._fileConfig = () => overwriteContents;\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConfigurationFile;\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/abstracts/configurationFile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "class",
    "name": "ConfigurationFile",
    "memberof": "src/abstracts/configurationFile.js",
    "static": true,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile",
    "access": "public",
    "export": true,
    "importPath": "projext/src/abstracts/configurationFile.js",
    "importStyle": "ConfigurationFile",
    "description": "A helper class for creating configuration files that can be overwritten on\nimplementation.",
    "lineNumber": 10,
    "version": "1.0",
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 87,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build the path to the overwrite file."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "overwritePaths",
        "description": "A path of a list of paths for files that can\n                                                overwrite the configuration. If used as a\n                                                string, it will assume the path is inside\n                                                the `config` folder, but if used as a list, the\n                                                paths will be relative to the project root\n                                                directory.\n                                                If used as an array, the class will use the\n                                                first file of the list that exists and ignore\n                                                the rest."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "asFactory",
        "description": "If `true`, every time `getConfig` gets called,\n                                                the configuration will be created again,\n                                                instead of caching it the first time it's\n                                                created."
      },
      {
        "nullable": true,
        "types": [
          "ConfigurationFile"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "parentConfig",
        "description": "If this parameter is used, the configuration\n                                                created by the instance will be merged on top\n                                                of the configuration returned by the\n                                                `getConfig` method of the parent configuration."
      }
    ],
    "abstract": true,
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "If instantiated directly."
      }
    ]
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "overwritePaths",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#overwritePaths",
    "access": "public",
    "description": "A list of paths that can overwrite the configuration.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "asFactory",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#asFactory",
    "access": "public",
    "description": "Whether the configuration should be created every time `getConfig` gets called or not.",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "parentConfig",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#parentConfig",
    "access": "public",
    "description": "A parent configuration to extend.",
    "lineNumber": 61,
    "type": {
      "nullable": true,
      "types": [
        "ConfigurationFile"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "_config",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#_config",
    "access": "protected",
    "description": "This will store the configuration after creating it.",
    "lineNumber": 68,
    "ignore": true,
    "type": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "_fileConfigLoaded",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#_fileConfigLoaded",
    "access": "protected",
    "description": "A flag to know if the overwrite file has been loaded or not.",
    "lineNumber": 75,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "_fileConfig",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#_fileConfig",
    "access": "protected",
    "description": "A function that eventually will return the changes from the overwrite file. Once the file\nis loaded, if the file exports a function, then it will replace this variable, otherwise, the\nreturn value of this method will be become the exported configuration.",
    "lineNumber": 84,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "createConfig",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#createConfig",
    "access": "public",
    "description": "This method will be called the first time `getConfig` gets called (or every time, depending on\nthe value of the `asFactory` property) and it should return the configuration contents.\nAs parameters, it will return the same ones sent to `getConfig`.",
    "examples": [
      "// Let's say the class receives this call: `getConfig({ name: 'Charito'}, 'hello')`, you could\n// do something like this:\ncreateConfig(options, prefix) {\n  return { message: `${prefix} ${options.name}` };\n}\n// And the configuration would be `{ message: 'hello Charito'}`"
    ],
    "lineNumber": 100,
    "abstract": true,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if not overwritten."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "getConfig",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#getConfig",
    "access": "public",
    "description": "This is the public method all other services uses to obtain the configuration. If the\nconfiguration doesn't exists or `asFactory` was set to `true` on the `constructor`, the\nconfiguration will be reloaded.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "A list of parameters for the service to use when creating the\n                     configuration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "_loadConfig",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#_loadConfig",
    "access": "protected",
    "description": "This is the real method that creates the configuration.",
    "lineNumber": 125,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "A list of parameters for the service to use when creating the\n                     configuration"
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "_loadConfigFromFile",
    "memberof": "src/abstracts/configurationFile.js~ConfigurationFile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/configurationFile.js~ConfigurationFile#_loadConfigFromFile",
    "access": "protected",
    "description": "Load the configuration from an overwrite file.",
    "lineNumber": 159,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "file",
    "name": "src/abstracts/nodeWatcher.js",
    "content": "const path = require('path');\nconst Watchpack = require('watchpack');\n/**\n * A helper class for creating services that rely on watching directories and copying and/or\n * transpiling files.\n * @abstract\n * @version 1.0\n */\nclass NodeWatcher {\n  /**\n   * @param {WatchpackOptions} [watchpackOptions={}] Custom options for `watchpack`, the library\n   *                                                 being used to watch directories.\n   */\n  constructor(watchpackOptions = {}) {\n    if (new.target === NodeWatcher) {\n      throw new TypeError(\n        'NodeWatcher is an abstract class, it can\\'t be instantiated directly'\n      );\n    }\n    /**\n     * Whether or not the service is watching.\n     * @type {boolean}\n     */\n    this.watching = false;\n    /**\n     * The custom options for `watchpack`. They're stored because the instance will be created\n     * when {@link NodeWatcher#watch} is called.\n     * @type {WatchpackOptions}\n     * @access protected\n     * @ignore\n     */\n    this._watchpackOptions = watchpackOptions;\n    /**\n     * This will be the instance of `watchpack` when the service starts watching the files.\n     * @type {?Watchpack}\n     */\n    this._watcher = null;\n    /**\n     * This will be the list of paths the service will be watching.\n     * @type {Array}\n     * @access protected\n     * @ignore\n     */\n    this._paths = [];\n    /**\n     * A list of dictionaries with `from` and `to` paths for transpilation. When a file change is\n     * detected by `watchpack`, the service will try to match the file path with the `from`\n     * property of one of the items, and if one is found, it will call the method to transpile\n     * that file using item's paths.\n     * @type {Array}\n     * @access protected\n     * @ignore\n     */\n    this._transpilationPaths = [];\n    /**\n     * A list of dictionaries with `from` and `to` paths for copying files. When a file change is\n     * detected by `watchpack`, and if the file path doesn't match any of the transpilation paths,\n     * the service will try to match the `from` of an item from this list. If one is found, it will\n     * then call the method to copy that file using item's paths.\n     * @type {Array}\n     * @access protected\n     * @ignore\n     */\n    this._copyPaths = [];\n    /**\n     * Bind the method in case is sent as reference.\n     * @ignore\n     */\n    this.watch = this.watch.bind(this);\n    /**\n     * Bind the method as it will be sent to `watchpack` as reference.\n     * @ignore\n     */\n    this._onChange = this._onChange.bind(this);\n  }\n  /**\n   * Starts watching the directories.\n   * @param {Array} paths                   The list of directories the service will watch.\n   * @param {Array} [transpilationPaths=[]] A list of dictionaries with `from` and `to` paths for\n   *                                        transpilation. When a file change is detected by the\n   *                                        service, it will try to match the file path with the\n   *                                        `from` property of one of the items, and if one is\n   *                                        found, it will call the method to transpile that file\n   *                                        using item's paths.\n   * @param {Array} [copyPaths=[]]          A list of dictionaries with `from` and `to` paths for\n   *                                        copying files. When a file change is detected by the\n   *                                        service, and if the file path doesn't match any of\n   *                                        the transpilation paths, it will try to match the\n   *                                        `from` of an item from this list. If one is found, it\n   *                                        will then call the method to copy that file using\n   *                                        item's paths.\n   * @return {Watchpack}\n   */\n  watch(paths, transpilationPaths = [], copyPaths = []) {\n    if (this.watching) {\n      throw new Error('The service is already watching, you can\\'t call it more than once');\n    } else if (!paths.length) {\n      throw new Error('You need to specify at least one path to watch');\n    } else if (!transpilationPaths.length && !copyPaths.length) {\n      throw new Error('You need to provide at least one transpilation or copy path');\n    }\n\n    this.watching = true;\n    this._paths = paths;\n    this._transpilationPaths = transpilationPaths;\n    this._copyPaths = copyPaths;\n\n    this._onStart();\n\n    this._watcher = new Watchpack(this._watchpackOptions);\n    this._watcher.watch([], this._paths);\n    this._watcher.on('change', this._onChange);\n    return this._watcher;\n  }\n  /**\n   * Stops watching the directories.\n   */\n  stop() {\n    if (this._watcher) {\n      this._watcher.close();\n      this.watching = false;\n    }\n  }\n  /**\n   * Gets the list of paths the service is watching.\n   * @return {Array}\n   */\n  getPaths() {\n    return this._paths;\n  }\n  /**\n   * This is called when the service is about to start watching the directories.\n   * @access protected\n   * @ignore\n   */\n  _onStart() {\n\n  }\n  /**\n   * This method is called when `watchpack` detects a source file has changed. It checks if the\n   * file path matches one of the transpilation paths or the copy paths in order to either\n   * transpile or copy the file in to the _\"build directory\"_.\n   * @param {string} file The path to the modified file.\n   * @access protected\n   * @ignore\n   */\n  _onChange(file) {\n    // Try to find a matching item on the transpilation paths.\n    const transpilationPath = this._transpilationPaths\n    .find(({ from }) => file.startsWith(from));\n    if (transpilationPath) {\n      // If there's an item which `from` matched the file path, transpile the file.\n      this._transpileFile(\n        file,\n        this._getFileNewPath(file, transpilationPath.from, transpilationPath.to)\n      );\n    } else {\n      // If no item matched the file, try to find a copy path.\n      const copyPath = this._copyPaths\n      .find(({ from }) => file.startsWith(from));\n      if (copyPath) {\n        // If there's an item which `from` matched the file path, copy the file.\n        this._copyFile(\n          file,\n          this._getFileNewPath(file, copyPath.from, copyPath.to)\n        );\n      } else {\n        this._onInvalidPathForChange(file);\n      }\n    }\n  }\n  /**\n   * This is called when a source file changes and the service can't find a matching path on neither\n   * the transpilation paths nor the copy paths.\n   * @param {string} file The path to the modified file.\n   * @access protected\n   * @ignore\n   */\n  _onInvalidPathForChange(file) {\n    // To avoid a ESLint vs ESDoc issues.\n    // eslint-disable-next-line no-unused-vars\n    const ignore = file;\n  }\n  /**\n   * Transpiles a file from a source directory into a build directory.\n   * @param {string} source The path to the source file.\n   * @param {string} output The path for the source file once transpiled.\n   * @abstract\n   * @access protected\n   * @ignore\n   */\n  _transpileFile(source, output) {\n    // To avoid a ESLint vs ESDoc issues.\n    // eslint-disable-next-line no-unused-vars\n    const ignore = { source, output };\n\n    throw new Error('_transpileFile must be overwritten');\n  }\n  /**\n   * Copies a file from a source directory into a build directory.\n   * @param {string} from The original path of the file.\n   * @param {string} to   The new path for the file.\n   * @abstract\n   * @access protected\n   * @ignore\n   */\n  _copyFile(from, to) {\n    // To avoid a ESLint vs ESDoc issues.\n    // eslint-disable-next-line no-unused-vars\n    const ignore = { from, to };\n\n    throw new Error('_copyFile must be overwritten');\n  }\n  /**\n   * Builds the path for a file that will be copied/transpiled fro its source directory into the\n   * build directory.\n   * @param {string} file The original path of the file.\n   * @param {string} from The path to the source directory.\n   * @param {string} to   The path to the build directory.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getFileNewPath(file, from, to) {\n    // Remove the _\"source directory\"_ of the file path in order to have just the relative part.\n    const relative = file.substr(from.length);\n    // Create the new path the file will have once copied/transpiled.\n    return path.join(to, relative);\n  }\n}\n\nmodule.exports = NodeWatcher;\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/abstracts/nodeWatcher.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 104,
    "kind": "class",
    "name": "NodeWatcher",
    "memberof": "src/abstracts/nodeWatcher.js",
    "static": true,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "access": "public",
    "export": true,
    "importPath": "projext/src/abstracts/nodeWatcher.js",
    "importStyle": "NodeWatcher",
    "description": "A helper class for creating services that rely on watching directories and copying and/or\ntranspiling files.",
    "lineNumber": 9,
    "version": "1.0",
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 105,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "WatchpackOptions"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "watchpackOptions",
        "description": "Custom options for `watchpack`, the library\n                                                being used to watch directories."
      }
    ]
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "watching",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#watching",
    "access": "public",
    "description": "Whether or not the service is watching.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_watchpackOptions",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_watchpackOptions",
    "access": "protected",
    "description": "The custom options for `watchpack`. They're stored because the instance will be created\nwhen {@link NodeWatcher#watch} is called.",
    "lineNumber": 32,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "WatchpackOptions"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_watcher",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_watcher",
    "access": "private",
    "description": "This will be the instance of `watchpack` when the service starts watching the files.",
    "lineNumber": 37,
    "type": {
      "nullable": true,
      "types": [
        "Watchpack"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_paths",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_paths",
    "access": "protected",
    "description": "This will be the list of paths the service will be watching.",
    "lineNumber": 44,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_transpilationPaths",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_transpilationPaths",
    "access": "protected",
    "description": "A list of dictionaries with `from` and `to` paths for transpilation. When a file change is\ndetected by `watchpack`, the service will try to match the file path with the `from`\nproperty of one of the items, and if one is found, it will call the method to transpile\nthat file using item's paths.",
    "lineNumber": 54,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_copyPaths",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_copyPaths",
    "access": "protected",
    "description": "A list of dictionaries with `from` and `to` paths for copying files. When a file change is\ndetected by `watchpack`, and if the file path doesn't match any of the transpilation paths,\nthe service will try to match the `from` of an item from this list. If one is found, it will\nthen call the method to copy that file using item's paths.",
    "lineNumber": 64,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "watch",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#watch",
    "access": "public",
    "description": "Starts watching the directories.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "paths",
        "description": "The list of directories the service will watch."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "transpilationPaths",
        "description": "A list of dictionaries with `from` and `to` paths for\n                                       transpilation. When a file change is detected by the\n                                       service, it will try to match the file path with the\n                                       `from` property of one of the items, and if one is\n                                       found, it will call the method to transpile that file\n                                       using item's paths."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "copyPaths",
        "description": "A list of dictionaries with `from` and `to` paths for\n                                       copying files. When a file change is detected by the\n                                       service, and if the file path doesn't match any of\n                                       the transpilation paths, it will try to match the\n                                       `from` of an item from this list. If one is found, it\n                                       will then call the method to copy that file using\n                                       item's paths."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Watchpack"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "stop",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#stop",
    "access": "public",
    "description": "Stops watching the directories.",
    "lineNumber": 118,
    "params": [],
    "return": null
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "getPaths",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#getPaths",
    "access": "public",
    "description": "Gets the list of paths the service is watching.",
    "lineNumber": 128,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "_onStart",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_onStart",
    "access": "protected",
    "description": "This is called when the service is about to start watching the directories.",
    "lineNumber": 136,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "_onChange",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_onChange",
    "access": "protected",
    "description": "This method is called when `watchpack` detects a source file has changed. It checks if the\nfile path matches one of the transpilation paths or the copy paths in order to either\ntranspile or copy the file in to the _\"build directory\"_.",
    "lineNumber": 147,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to the modified file."
      }
    ],
    "return": null
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "_onInvalidPathForChange",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_onInvalidPathForChange",
    "access": "protected",
    "description": "This is called when a source file changes and the service can't find a matching path on neither\nthe transpilation paths nor the copy paths.",
    "lineNumber": 179,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to the modified file."
      }
    ],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "_transpileFile",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_transpileFile",
    "access": "protected",
    "description": "Transpiles a file from a source directory into a build directory.",
    "lineNumber": 192,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The path to the source file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "The path for the source file once transpiled."
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "_copyFile",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_copyFile",
    "access": "protected",
    "description": "Copies a file from a source directory into a build directory.",
    "lineNumber": 207,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The original path of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The new path for the file."
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_getFileNewPath",
    "memberof": "src/abstracts/nodeWatcher.js~NodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/abstracts/nodeWatcher.js~NodeWatcher#_getFileNewPath",
    "access": "protected",
    "description": "Builds the path for a file that will be copied/transpiled fro its source directory into the\nbuild directory.",
    "lineNumber": 224,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The original path of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The path to the source directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The path to the build directory."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 129,
    "kind": "file",
    "name": "src/app/index.js",
    "content": "const Jimple = require('jimple');\n\nconst {\n  environmentUtils,\n  errorHandler,\n  appLogger,\n  packageInfo,\n  pathUtils,\n  rootRequire,\n} = require('wootils/node/providers');\n\nconst appPackage = require('../../package.json');\n\nconst {\n  babelHelper,\n  cleaner,\n  copier,\n  dotEnvUtils,\n  events,\n  plugins,\n  appPrompt,\n  tempFiles,\n  utils,\n  versionUtils,\n} = require('../services/common');\n\nconst {\n  buildCleaner,\n  buildCopier,\n  buildEngines,\n  buildNodeRunner,\n  buildNodeRunnerProcess,\n  buildNodeWatcher,\n  buildNodeWatcherProcess,\n  buildTranspiler,\n  buildTypeScriptHelper,\n  buildVersion,\n  builder,\n} = require('../services/building');\n\nconst {\n  cli,\n  cliAnalyzeCommand,\n  cliBuildCommand,\n  cliCleanCommand,\n  cliCopyProjectFilesCommand,\n  cliGenerateCommand,\n  cliInfoCommand,\n  cliInspectCommand,\n  cliRevisionCommand,\n  cliRunCommand,\n  cliSHAnalyzeCommand,\n  cliSHBuildCommand,\n  cliSHCopyCommand,\n  cliSHInspectCommand,\n  cliSHNodeRunCommand,\n  cliSHNodeWatchCommand,\n  cliSHRunCommand,\n  cliSHTranspileCommand,\n  cliSHValidateAnalyzeCommand,\n  cliSHValidateBuildCommand,\n  cliSHValidateInspectCommand,\n  cliSHValidateRunCommand,\n  cliGenerators,\n  cliSHValidateWatchCommand,\n  cliSHWatchCommand,\n  cliWatchCommand,\n} = require('../services/cli');\n\nconst {\n  babelConfiguration,\n  projectConfiguration,\n  targetConfiguration,\n} = require('../services/configurations');\n\nconst {\n  targets,\n  targetsFileRules,\n  targetsFinder,\n  targetsHTML,\n} = require('../services/targets');\n/**\n * This is projext dependecy injection container. This class is in charge of registering all the\n * known services, load any existing plugin and add an error handler.\n * @extends {Jimple}\n */\nclass Projext extends Jimple {\n  /**\n   * Registers all the known services, load any existing plugin and add an error handler.\n   * @ignore\n   */\n  constructor() {\n    super();\n\n    this.set('info', () => appPackage);\n\n    this.register(environmentUtils);\n    this.register(errorHandler);\n    this.register(appLogger);\n    this.register(packageInfo);\n    this.register(pathUtils);\n    this.register(rootRequire);\n\n    this.register(babelHelper);\n    this.register(cleaner);\n    this.register(copier);\n    this.register(dotEnvUtils);\n    this.register(events);\n    this.register(plugins('projext-plugin-'));\n    this.register(appPrompt);\n    this.register(tempFiles);\n    this.register(utils);\n    this.register(versionUtils);\n\n    this.register(buildCleaner);\n    this.register(buildCopier);\n    this.register(buildEngines);\n    this.register(buildNodeRunner);\n    this.register(buildNodeRunnerProcess);\n    this.register(buildNodeWatcher);\n    this.register(buildNodeWatcherProcess);\n    this.register(buildTranspiler);\n    this.register(buildTypeScriptHelper);\n    this.register(buildVersion);\n    this.register(builder);\n\n    this.register(cli);\n    this.register(cliAnalyzeCommand);\n    this.register(cliBuildCommand);\n    this.register(cliCleanCommand);\n    this.register(cliCopyProjectFilesCommand);\n    this.register(cliGenerateCommand);\n    this.register(cliInfoCommand);\n    this.register(cliInspectCommand);\n    this.register(cliRevisionCommand);\n    this.register(cliRunCommand);\n    this.register(cliSHAnalyzeCommand);\n    this.register(cliSHBuildCommand);\n    this.register(cliSHCopyCommand);\n    this.register(cliSHInspectCommand);\n    this.register(cliSHNodeRunCommand);\n    this.register(cliSHNodeWatchCommand);\n    this.register(cliSHRunCommand);\n    this.register(cliSHTranspileCommand);\n    this.register(cliSHValidateAnalyzeCommand);\n    this.register(cliSHValidateBuildCommand);\n    this.register(cliSHValidateInspectCommand);\n    this.register(cliSHValidateRunCommand);\n    this.register(cliSHValidateWatchCommand);\n    this.register(cliSHWatchCommand);\n    this.register(cliWatchCommand);\n\n    this.register(cliGenerators.targetHTMLGenerator);\n    this.register(cliGenerators.projectConfigurationFileGenerator);\n\n    this.register(babelConfiguration);\n    this.register(projectConfiguration);\n    this.register(targetConfiguration);\n\n    this.register(targets);\n    this.register(targetsFileRules);\n    this.register(targetsFinder);\n    this.register(targetsHTML);\n\n    this._loadPlugins();\n    this._addErrorHandler();\n  }\n  /**\n   * Starts projext CLI interface.\n   */\n  cli() {\n    // Get the `generate` command and register the available generators.\n    const generateCommand = this.get('cliGenerateCommand');\n    generateCommand.addGenerators([\n      this.get('projectConfigurationFileGenerator'),\n      this.get('targetHTMLGenerator'),\n    ]);\n    // Start the CLI with the available commands.\n    this.get('cli').start([\n      this.get('cliAnalyzeCommand'),\n      this.get('cliBuildCommand'),\n      this.get('cliRunCommand'),\n      this.get('cliCleanCommand'),\n      this.get('cliCopyProjectFilesCommand'),\n      generateCommand,\n      this.get('cliInfoCommand'),\n      this.get('cliInspectCommand'),\n      this.get('cliRevisionCommand'),\n      this.get('cliSHAnalyzeCommand'),\n      this.get('cliSHBuildCommand'),\n      this.get('cliSHCopyCommand'),\n      this.get('cliSHInspectCommand'),\n      this.get('cliSHNodeRunCommand'),\n      this.get('cliSHNodeWatchCommand'),\n      this.get('cliSHRunCommand'),\n      this.get('cliSHTranspileCommand'),\n      this.get('cliSHValidateAnalyzeCommand'),\n      this.get('cliSHValidateBuildCommand'),\n      this.get('cliSHValidateInspectCommand'),\n      this.get('cliSHValidateRunCommand'),\n      this.get('cliSHValidateWatchCommand'),\n      this.get('cliSHWatchCommand'),\n      this.get('cliWatchCommand'),\n    ]);\n  }\n  /**\n   * Uses the `plugins` service to load and register any existing plugin.\n   * @ignore\n   * @access protected\n   */\n  _loadPlugins() {\n    this.get('plugins').load();\n  }\n  /**\n   * Makes the `errorHandler` service listen for any uncaught exceptions projext may throw.\n   * @ignore\n   * @access protected\n   */\n  _addErrorHandler() {\n    this.get('errorHandler').listen();\n  }\n}\n\nmodule.exports = { Projext };\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/app/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 130,
    "kind": "class",
    "name": "Projext",
    "memberof": "src/app/index.js",
    "static": true,
    "longname": "src/app/index.js~Projext",
    "access": "public",
    "export": true,
    "importPath": "projext/src/app/index.js",
    "importStyle": "{Projext}",
    "description": "This is projext dependecy injection container. This class is in charge of registering all the\nknown services, load any existing plugin and add an error handler.",
    "lineNumber": 87,
    "interface": false,
    "extends": [
      "Jimple"
    ]
  },
  {
    "__docId__": 131,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/app/index.js~Projext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/app/index.js~Projext#constructor",
    "access": "public",
    "description": "Registers all the known services, load any existing plugin and add an error handler.",
    "lineNumber": 92,
    "ignore": true
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "cli",
    "memberof": "src/app/index.js~Projext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/app/index.js~Projext#cli",
    "access": "public",
    "description": "Starts projext CLI interface.",
    "lineNumber": 171,
    "params": [],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "_loadPlugins",
    "memberof": "src/app/index.js~Projext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/app/index.js~Projext#_loadPlugins",
    "access": "protected",
    "description": "Uses the `plugins` service to load and register any existing plugin.",
    "lineNumber": 211,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "_addErrorHandler",
    "memberof": "src/app/index.js~Projext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/app/index.js~Projext#_addErrorHandler",
    "access": "protected",
    "description": "Makes the `errorHandler` service listen for any uncaught exceptions projext may throw.",
    "lineNumber": 219,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 135,
    "kind": "file",
    "name": "src/index.js",
    "content": "module.exports = require('./app');\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "src/services/building/buildCleaner.js",
    "content": "const fs = require('fs-extra');\nconst { provider } = require('jimple');\n/**\n * Remove the builded files for the project and/or an specific target.\n */\nclass BuildCleaner {\n  /**\n   * Class constructor.\n   * @param {Logger}                       appLogger            Used to inform the user when files\n   *                                                            haven been removed of it there was\n   *                                                            a problem removing them.\n   * @param {Cleaner.clean}                cleaner              The function that removes\n   *                                                            directories and files using glob\n   *                                                            patterns.\n   * @param {PathUtils}                    pathUtils            Necessary to build the paths to\n   *                                                            clean.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the project information and\n   *                                                            get paths.\n   * @param {Utils}                        utils                To replace plaholders on the targets\n   *                                                            paths.\n   */\n  constructor(\n    appLogger,\n    cleaner,\n    pathUtils,\n    projectConfiguration,\n    utils\n  ) {\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `cleaner` service function.\n     * @type {Cleaner.clean}\n     */\n    this.cleaner = cleaner;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `utils` service.\n     * @type {Utils}\n     */\n    this.utils = utils;\n  }\n  /**\n   * Removes the entire distribution directory (where are the targets build are located).\n   * @return {Promise<undefined,Error>}\n   */\n  cleanAll() {\n    const { paths: { build } } = this.projectConfiguration;\n    const dist = this.pathUtils.join(build);\n    return this.cleaner(dist, '**')\n    .then(() => {\n      this.appLogger.success(\n        `The distribution directory was successfully removed (${dist})`\n      );\n    })\n    .catch((error) => {\n      this.appLogger.error(\n        `Error: There was an error while removing the distribution directory (${dist})`\n      );\n\n      return Promise.reject(error);\n    });\n  }\n  /**\n   * Removes the builded files of an specific target.\n   * @param {Target} target The target information.\n   * @return {Promise<undefined,Error>}\n   */\n  cleanTarget(target) {\n    const { paths: { build } } = this.projectConfiguration;\n    const dist = this.pathUtils.join(build);\n    let firstStep;\n    if (target.is.node && !target.bundle) {\n      firstStep = fs.readdir(target.paths.source);\n    } else {\n      const items = [];\n      const placeholders = {\n        'target-name': target.name,\n        hash: '*',\n        name: '*',\n        ext: '*',\n      };\n      Object.keys(target.originalOutput).forEach((type) => {\n        const output = target.originalOutput[type];\n        // JS\n        const js = this.utils.replacePlaceholders(output.js, placeholders);\n        items.push(js);\n        if (target.is.browser) {\n          items.push(`${js}.map`);\n        }\n        // Others\n        items.push(...[\n          this.utils.replacePlaceholders(output.css, placeholders),\n          this.utils.replacePlaceholders(output.fonts, placeholders),\n          this.utils.replacePlaceholders(output.images, placeholders),\n        ]);\n      });\n\n      if (target.is.browser && target.html) {\n        items.push(target.html.filename);\n      }\n\n      items.push(...items.map((item) => `${item}.gz`));\n      firstStep = Promise.resolve(items);\n    }\n\n    return firstStep\n    .then((items) => this.cleaner(target.paths.build, items))\n    .then(() => {\n      this.appLogger.success(\n        `The files for '${target.name}' have been was successfully removed from ` +\n        `the distribution directory (${dist})`\n      );\n    })\n    .catch((error) => {\n      this.appLogger.error(\n        `Error: There was an error while removing the files for '${target.name}' ` +\n        `from the distribution directory (${dist})`\n      );\n\n      return Promise.reject(error);\n    });\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildCleaner` as the `buildCleaner` service.\n * @example\n * // Register it on the container\n * container.register(buildCleaner);\n * // Getting access to the service instance\n * const buildCleaner = container.get('buildCleaner');\n * @type {Provider}\n */\nconst buildCleaner = provider((app) => {\n  app.set('buildCleaner', () => new BuildCleaner(\n    app.get('appLogger'),\n    app.get('cleaner'),\n    app.get('pathUtils'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('utils')\n  ));\n});\n\nmodule.exports = {\n  BuildCleaner,\n  buildCleaner,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildCleaner.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "class",
    "name": "BuildCleaner",
    "memberof": "src/services/building/buildCleaner.js",
    "static": true,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildCleaner.js",
    "importStyle": "{BuildCleaner}",
    "description": "Remove the builded files for the project and/or an specific target.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 138,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "Used to inform the user when files\n                                                           haven been removed of it there was\n                                                           a problem removing them."
      },
      {
        "nullable": null,
        "types": [
          "Cleaner.clean"
        ],
        "spread": false,
        "optional": false,
        "name": "cleaner",
        "description": "The function that removes\n                                                           directories and files using glob\n                                                           patterns."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "Necessary to build the paths to\n                                                           clean."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the project information and\n                                                           get paths."
      },
      {
        "nullable": null,
        "types": [
          "Utils"
        ],
        "spread": false,
        "optional": false,
        "name": "utils",
        "description": "To replace plaholders on the targets\n                                                           paths."
      }
    ]
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "cleaner",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#cleaner",
    "access": "public",
    "description": "A local reference for the `cleaner` service function.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Cleaner.clean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "utils",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#utils",
    "access": "public",
    "description": "A local reference for the `utils` service.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Utils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "cleanAll",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#cleanAll",
    "access": "public",
    "description": "Removes the entire distribution directory (where are the targets build are located).",
    "lineNumber": 59,
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "cleanTarget",
    "memberof": "src/services/building/buildCleaner.js~BuildCleaner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCleaner.js~BuildCleaner#cleanTarget",
    "access": "public",
    "description": "Removes the builded files of an specific target.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 146,
    "kind": "variable",
    "name": "buildCleaner",
    "memberof": "src/services/building/buildCleaner.js",
    "static": true,
    "longname": "src/services/building/buildCleaner.js~buildCleaner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildCleaner.js",
    "importStyle": "{buildCleaner}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildCleaner` as the `buildCleaner` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildCleaner);\n// Getting access to the service instance\nconst buildCleaner = container.get('buildCleaner');"
    ],
    "lineNumber": 147,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 147,
    "kind": "file",
    "name": "src/services/building/buildCopier.js",
    "content": "const fs = require('fs-extra');\nconst path = require('path');\nconst { provider } = require('jimple');\n/**\n * Copies the project files and/or the files of a target that doesn't require bundling.\n */\nclass BuildCopier {\n  /**\n   * Class constructor.\n   * @param {Copier.copy}                  copier               The function that copies files and\n   *                                                            directories.\n   * @param {Logger}                       appLogger            Used to inform the user when files\n   *                                                            are being copied.\n   * @param {Events}                       events               To trigger events reducer that may\n   *                                                            alter the items being copied.\n   * @param {PathUtils}                    pathUtils            Necessary to build the paths.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the project information and\n   *                                                            get paths.\n   * @param {Targets}                      targets              To get the information of targets\n   *                                                            from `includeTargets` and copy their\n   *                                                            files too.\n   */\n  constructor(copier, appLogger, events, pathUtils, projectConfiguration, targets) {\n    /**\n     * A local reference for the `copier` service function.\n     * @type {Copier.copy}\n     */\n    this.copier = copier;\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n  }\n  /**\n   * If `copy.enabled` is `true` on the project configuration, this method will copy the list of\n   * items on the configuration `copy.items` key.\n   * This method emits the event reducer `project-files-to-copy` with the list of items to copy and\n   * expects an `Array` on return.\n   * @return {Promise<undefined,Error>}\n   */\n  copyFiles() {\n    let result;\n    const {\n      copy,\n      version: {\n        revision,\n      },\n      paths: {\n        build,\n        privateModules,\n      },\n    } = this.projectConfiguration;\n    // If the feature is enabled...\n    if (copy.enabled) {\n      // ..prepare a list of the items\n      let items = [];\n      // Prepare a list of Node modules that may be copied.\n      const copiedModules = {};\n      // If there are items to copy on the project configuration...\n      if (Array.isArray(copy.items)) {\n        // ...loop the items.\n        copy.items.forEach((item) => {\n          // If the item is a Node module...\n          if (typeof item === 'string' && item.startsWith('node_modules')) {\n            // ...generate a new path for the module inside a private folder.\n            const newModulePath = item.replace(/^(node_modules\\/)/, `${privateModules}/`);\n            // Save the name of the module linked to the new path.\n            copiedModules[item.split('/').pop()] = newModulePath;\n            // Push the module and its new path to the list of items to copy.\n            items.push({\n              [item]: newModulePath,\n            });\n          } else {\n            // ...otherwise, just push it to the list of items to copy.\n            items.push(item);\n          }\n        });\n\n        // if the revision functionality is enabled and the file exists...\n        if (\n          revision.enabled &&\n          revision.copy &&\n          fs.pathExistsSync(this.pathUtils.join(revision.filename))\n        ) {\n          // ...add it to the items to copy.\n          items.push(revision.filename);\n        }\n        // Reduce the list of items to copy and give the chance to any plugin to add new ones.\n        items = this.events.reduce('project-files-to-copy', items);\n        // If there are still items to copy...\n        if (items.length) {\n          // ...grab a reference to the path of the project.\n          const thispath = this.pathUtils.path;\n          // Copy all the items on the project path onto the distribution directory.\n          result = this.copier(\n            thispath,\n            this.pathUtils.join(build),\n            items\n          )\n          .then((results) => {\n            this.appLogger.success('The following items have been successfully copied:');\n            // Remove the absolute path and the first `/`\n            const prefix = thispath.length + 1;\n            // Log a message for each item informing it was copied.\n            results.forEach((item) => {\n              const from = item.from.substr(prefix);\n              const to = item.to.substr(prefix);\n              this.appLogger.info(`${from} -> ${to}`);\n            });\n            /**\n             * If there any Node module was copied, call the method that updates the copied\n             * `package.json` of the project and modules in order to use relative paths instead of\n             * versions of the npm/yarn registry.\n             */\n            return Object.keys(copiedModules).length ?\n              this.addPrivateModules(this.pathUtils.join(build, 'package.json'), copiedModules) :\n              {};\n          })\n          .catch((error) => {\n            this.appLogger.error('There was an error while copying the files');\n            return Promise.reject(error);\n          });\n        } else {\n          result = Promise.resolve();\n        }\n      } else {\n        result = Promise.reject(new Error('The \\'copy.items\\' setting is not an array'));\n      }\n    } else {\n      result = Promise.resolve();\n    }\n\n    return result;\n  }\n  /**\n   * After the project files are copied, this module updates the copied package.json with local\n   * references for any given module name.\n   * @param {string}  packagePath             The path to the main `package.json`.\n   * @param {Object}  modules                 A dictionary with the name of modules as keys and\n   *                                          local paths as values.\n   * @param {boolean} [updateModulesToo=true] If `true`, it will also update the `package.json` of\n   *                                          each of the modules with references each others local\n   *                                          paths.\n   * @return Promise<undefined,Error>\n   */\n  addPrivateModules(packagePath, modules, updateModulesToo = true) {\n    // Read the main `package.json`\n    return fs.readJson(packagePath)\n    .then((packageContents) => {\n      // Create a new reference to avoid linting issues.\n      const newPackage = Object.assign({}, packageContents);\n      // Loop the different types of dependencies...\n      ['dependencies', 'devDependencies']\n      .forEach((type) => {\n        // Loop the dictionary of modules...\n        Object.keys(modules).forEach((dependencyName) => {\n          // If the module is present...\n          if (newPackage[type] && newPackage[type][dependencyName]) {\n            // ...change the version to the local path.\n            newPackage[type][dependencyName] = `./${modules[dependencyName]}`;\n          }\n        });\n      });\n      // Remove any \"private property\" npm adds on the `package.json`\n      Object.keys(newPackage).forEach((property) => {\n        if (property.startsWith('_')) {\n          delete newPackage[property];\n        }\n      });\n      // Write the updated file.\n      return fs.writeJson(packagePath, newPackage);\n    })\n    .then(() => {\n      let result = {};\n      // If it needs to also update the methods between each other...\n      if (updateModulesToo) {\n        // Get the location of the private folder where modules are copied.\n        const { paths: { privateModules } } = this.projectConfiguration;\n        // Generate a path to it.\n        const directory = path.join(path.dirname(packagePath), privateModules);\n        const packages = [];\n        const modulesWithPathToRoot = {};\n        // Loop all the modules...\n        Object.keys(modules).forEach((dependencyName) => {\n          // Get its private path.\n          const privatePath = modules[dependencyName];\n          /**\n           * Updates it by adding 2 levels up from its location so they will be relative to where\n           * the `package.json` is: one to `node_modules`, and a second one to the \"root\"\n           */\n          modulesWithPathToRoot[dependencyName] = `../../${privatePath}`;\n          /**\n           * Push the module `package.json` path to the list of `package.json`s that will be\n           * updated.\n           */\n          packages.push(path.join(directory, dependencyName, 'package.json'));\n        });\n        /**\n         * Loop all the `package.json`s and call this same method to update their references, but\n         * with the flag to update modules disabled as it's already doing it.\n         */\n        result = Promise.all(packages.map((modulePackage) => this.addPrivateModules(\n          modulePackage,\n          modulesWithPathToRoot,\n          false\n        )));\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Copy the files of an specific target.\n   * @param {Target} target The target information.\n   * @return {Promise<undefined,Error>}\n   */\n  copyTargetFiles(target) {\n    // Define the variable to return.\n    let result;\n    // Get the information of all the targets on the `includeTargets` list.\n    const includedTargets = target.includeTargets.map((name) => this.targets.getTarget(name));\n    // Try to find one that requires bundling.\n    const bundledTarget = includedTargets.find((info) => info.bundle);\n    if (bundledTarget) {\n      // If there's one that requires bundling, set to return a rejected promise.\n      const errorMessage = `The target ${bundledTarget.name} requires bundling so it can't be ` +\n        `included by ${target.name}`;\n      result = Promise.reject(new Error(errorMessage));\n    } else {\n      /**\n       * If there are no included targets or none that requires bundling, continue...\n       * Make sure the build directory exists.\n       */\n      result = fs.ensureDir(target.paths.build)\n      // Get all the items on the source directory.\n      .then(() => fs.readdir(target.paths.source))\n      // Copy everything.\n      .then((items) => this.copier(\n        target.paths.source,\n        target.paths.build,\n        items\n      ))\n      .then(() => {\n        this.appLogger.success(\n          `The files for '${target.name}' have been successfully copied (${target.paths.build})`\n        );\n        let nextStep;\n        // If there are targets to include...\n        if (includedTargets.length) {\n          // ...chain their promises.\n          nextStep = Promise.all(includedTargets.map((info) => this.copyTargetFiles(info)));\n        }\n\n        return nextStep;\n      })\n      .catch((error) => {\n        this.appLogger.error(`The files for '${target.name}' couldn't be copied`);\n        return Promise.reject(error);\n      });\n    }\n\n    return result;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildCopier` as the `buildCopier` service.\n * @example\n * // Register it on the container\n * container.register(buildCopier);\n * // Getting access to the service instance\n * const buildCopier = container.get('buildCopier');\n * @type {Provider}\n */\nconst buildCopier = provider((app) => {\n  app.set('buildCopier', () => new BuildCopier(\n    app.get('copier'),\n    app.get('appLogger'),\n    app.get('events'),\n    app.get('pathUtils'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  BuildCopier,\n  buildCopier,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildCopier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 148,
    "kind": "class",
    "name": "BuildCopier",
    "memberof": "src/services/building/buildCopier.js",
    "static": true,
    "longname": "src/services/building/buildCopier.js~BuildCopier",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildCopier.js",
    "importStyle": "{BuildCopier}",
    "description": "Copies the project files and/or the files of a target that doesn't require bundling.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 149,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Copier.copy"
        ],
        "spread": false,
        "optional": false,
        "name": "copier",
        "description": "The function that copies files and\n                                                           directories."
      },
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "Used to inform the user when files\n                                                           are being copied."
      },
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To trigger events reducer that may\n                                                           alter the items being copied."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "Necessary to build the paths."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the project information and\n                                                           get paths."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the information of targets\n                                                           from `includeTargets` and copy their\n                                                           files too."
      }
    ]
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "copier",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#copier",
    "access": "public",
    "description": "A local reference for the `copier` service function.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "Copier.copy"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "copyFiles",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#copyFiles",
    "access": "public",
    "description": "If `copy.enabled` is `true` on the project configuration, this method will copy the list of\nitems on the configuration `copy.items` key.\nThis method emits the event reducer `project-files-to-copy` with the list of items to copy and\nexpects an `Array` on return.",
    "lineNumber": 62,
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "addPrivateModules",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#addPrivateModules",
    "access": "public",
    "description": "After the project files are copied, this module updates the copied package.json with local\nreferences for any given module name.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "packagePath",
        "description": "The path to the main `package.json`."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "modules",
        "description": "A dictionary with the name of modules as keys and\n                                         local paths as values."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "updateModulesToo",
        "description": "If `true`, it will also update the `package.json` of\n                                         each of the modules with references each others local\n                                         paths."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Promise<undefined,Error>"
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "copyTargetFiles",
    "memberof": "src/services/building/buildCopier.js~BuildCopier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildCopier.js~BuildCopier#copyTargetFiles",
    "access": "public",
    "description": "Copy the files of an specific target.",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 159,
    "kind": "variable",
    "name": "buildCopier",
    "memberof": "src/services/building/buildCopier.js",
    "static": true,
    "longname": "src/services/building/buildCopier.js~buildCopier",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildCopier.js",
    "importStyle": "{buildCopier}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildCopier` as the `buildCopier` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildCopier);\n// Getting access to the service instance\nconst buildCopier = container.get('buildCopier');"
    ],
    "lineNumber": 296,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 160,
    "kind": "file",
    "name": "src/services/building/buildEngines.js",
    "content": "const { provider } = require('jimple');\n/**\n * This is an special service as it doesn't do anything but returning another services: Build\n * engines are what projext uses to bundle targets, since they depend on a target configuration,\n * we can't have huge `if` that checks the value of the setting in order to retrieve the required\n * service.\n * The solution we came up with is that the engines services all respect an interface and register\n * themselves with the name `[name]BuildEngine` so the rest of the app can use this service to\n * retrieve them by name.\n */\nclass BuildEngines {\n  /**\n   * Class constructor.\n   * @param {Projext} app The main app container. Used to retrieve the build engines services.\n   */\n  constructor(app) {\n    /**\n     * A local reference for the main app container.\n     * @type {Projext}\n     */\n    this.app = app;\n  }\n  /**\n   * Get a build engine service.\n   * @param {string} name The engine name.\n   * @return {BuildEngine}\n   * @throws {Error} If the service is not registered.\n   */\n  getEngine(name) {\n    return this.app.get(`${name}BuildEngine`);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildEngines` as the `buildEngines` service.\n * @example\n * // Register it on the container\n * container.register(buildEngines);\n * // Getting access to the service instance\n * const buildEngines = container.get('buildEngines');\n * @type {Provider}\n */\nconst buildEngines = provider((app) => {\n  app.set('buildEngines', () => new BuildEngines(app));\n});\n\nmodule.exports = {\n  BuildEngines,\n  buildEngines,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildEngines.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 161,
    "kind": "class",
    "name": "BuildEngines",
    "memberof": "src/services/building/buildEngines.js",
    "static": true,
    "longname": "src/services/building/buildEngines.js~BuildEngines",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildEngines.js",
    "importStyle": "{BuildEngines}",
    "description": "This is an special service as it doesn't do anything but returning another services: Build\nengines are what projext uses to bundle targets, since they depend on a target configuration,\nwe can't have huge `if` that checks the value of the setting in order to retrieve the required\nservice.\nThe solution we came up with is that the engines services all respect an interface and register\nthemselves with the name `[name]BuildEngine` so the rest of the app can use this service to\nretrieve them by name.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 162,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildEngines.js~BuildEngines",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildEngines.js~BuildEngines#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Projext"
        ],
        "spread": false,
        "optional": false,
        "name": "app",
        "description": "The main app container. Used to retrieve the build engines services."
      }
    ]
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "app",
    "memberof": "src/services/building/buildEngines.js~BuildEngines",
    "static": false,
    "longname": "src/services/building/buildEngines.js~BuildEngines#app",
    "access": "public",
    "description": "A local reference for the main app container.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Projext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "getEngine",
    "memberof": "src/services/building/buildEngines.js~BuildEngines",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildEngines.js~BuildEngines#getEngine",
    "access": "public",
    "description": "Get a build engine service.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The engine name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BuildEngine"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the service is not registered."
      }
    ]
  },
  {
    "__docId__": 165,
    "kind": "variable",
    "name": "buildEngines",
    "memberof": "src/services/building/buildEngines.js",
    "static": true,
    "longname": "src/services/building/buildEngines.js~buildEngines",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildEngines.js",
    "importStyle": "{buildEngines}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildEngines` as the `buildEngines` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildEngines);\n// Getting access to the service instance\nconst buildEngines = container.get('buildEngines');"
    ],
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/services/building/buildNodeRunner.js",
    "content": "const path = require('path');\nconst { provider } = require('jimple');\n/**\n * This service provides a simple interface for running targets on a development environment using\n * `Nodemon`. The actual service that does the _'running'_ is `buildNodeRunnerProcess`, but this\n * one takes care of reading and processing a target settings before telling the other service\n * to start Nodemon.\n */\nclass BuildNodeRunner {\n  /**\n   * Class constructor.\n   * @param {BuildNodeRunnerProcess}       buildNodeRunnerProcess To actually run a target process.\n   * @param {ProjectConfigurationSettings} projectConfiguration   To read the targets and their\n   *                                                              templates.\n   * @param {Targets}                      targets                To get the information of the\n   *                                                              included targets.\n   * @param {Utils}                        utils                  To normalize executable\n   *                                                              extensions.\n   */\n  constructor(buildNodeRunnerProcess, projectConfiguration, targets, utils) {\n    /**\n     * A local reference for the `buildNodeRunnerProcess` service.\n     * @type {BuildNodeRunnerProcess}\n     */\n    this.buildNodeRunnerProcess = buildNodeRunnerProcess;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * A local reference for the `utils` service.\n     * @type {Utils}\n     */\n    this.utils = utils;\n    // Check the project settings and enable the `nodemon` legacy watch mode.\n    if (projectConfiguration.others.nodemon.legacyWatch) {\n      this.buildNodeRunnerProcess.enableLegacyWatch();\n    }\n  }\n  /**\n   * Run a target with Nodemon.\n   * @param {Target}  target               The target information.\n   * @param {boolean} [forceInspect=false] Whether or not to _\"force enable\"_ the Node inspector,\n   *                                       even if the target has disabled it.\n   * @return {Nodemon}\n   * @throws {Error} If the target type is `browser`.\n   * @throws {Error} If the target needs to be bundled.\n   */\n  runTarget(target, forceInspect = false) {\n    if (target.is.browser) {\n      throw new Error(`${target.name} is a browser target and can't be executed`);\n    } else if (target.bundle) {\n      throw new Error(`${target.name} needs to be bundled in order to run`);\n    }\n\n    const inspectOptions = Object.assign({}, target.inspect, {\n      enabled: (forceInspect || target.inspect.enabled),\n    });\n\n    return target.transpile ?\n      this._runWithTranspilation(target, inspectOptions) :\n      this._run(target, inspectOptions);\n  }\n  /**\n   * Runs a target that requires transpilation. It executes the file from the distribution\n   * directory while it watches the source directory.\n   * @param {Target}                target         The target information.\n   * @param {NodeInspectorSettings} inspectOptions The options for the Node inspector.\n   * @return {Nodemon}\n   * @throws {Error} If one of the included targets requires bundling.\n   * @access protected\n   * @ignore\n   */\n  _runWithTranspilation(target, inspectOptions) {\n    const { paths: { source, build }, includeTargets } = target;\n    const executable = path.join(build, target.entry.development);\n    const watch = [build];\n    const copyPaths = [];\n    const transpilationPaths = [{\n      from: source,\n      to: build,\n    }];\n\n    includeTargets.forEach((name) => {\n      const subTarget = this.targets.getTarget(name);\n      if (subTarget.bundle) {\n        const errorMessage = `The target ${name} requires bundling so it can't be ` +\n          `included by ${target.name}`;\n        throw new Error(errorMessage);\n      } else {\n        watch.push(subTarget.paths.build);\n        const pathSettings = {\n          from: subTarget.paths.source,\n          to: subTarget.paths.build,\n        };\n        if (subTarget.transpile) {\n          transpilationPaths.push(pathSettings);\n        } else {\n          copyPaths.push(pathSettings);\n        }\n      }\n    });\n\n    this.buildNodeRunnerProcess.run(\n      this.utils.ensureExtension(executable),\n      watch,\n      inspectOptions,\n      transpilationPaths,\n      copyPaths,\n      {},\n      ['*.test.js'],\n      () => this.targets.loadTargetDotEnvFile(target, 'development')\n    );\n  }\n  /**\n   * Runs a target that doesn't require transpilation. It executes and watches the source directory.\n   * @param {Target}                target         The target information.\n   * @param {NodeInspectorSettings} inspectOptions The options for the Node inspector.\n   * @return {Nodemon}\n   * @throws {Error} If one of the included targets requires bundling.\n   * @throws {Error} If one of the included targets requires transpiling.\n   * @access protected\n   * @ignore\n   */\n  _run(target, inspectOptions) {\n    const { paths: { source }, includeTargets } = target;\n    const executable = path.join(source, target.entry.development);\n    const watch = [source];\n\n    includeTargets.forEach((name) => {\n      const subTarget = this.targets.getTarget(name);\n      if (subTarget.bundle) {\n        const errorMessage = `The target ${name} requires bundling so it can't be ` +\n          `included by ${target.name}`;\n        throw new Error(errorMessage);\n      } else if (subTarget.transpile) {\n        const errorMessage = `The target ${name} requires transpilation so it can't be ` +\n          `included by ${target.name}`;\n        throw new Error(errorMessage);\n      } else {\n        watch.push(subTarget.paths.source);\n      }\n    });\n\n    this.buildNodeRunnerProcess.run(\n      executable,\n      watch,\n      inspectOptions,\n      [],\n      [],\n      {},\n      ['*.test.js'],\n      () => this.targets.loadTargetDotEnvFile(target, 'development')\n    );\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildNodeRunner` as the `buildNodeRunner` service.\n * @example\n * // Register it on the container\n * container.register(buildNodeRunner);\n * // Getting access to the service instance\n * const buildNodeRunner = container.get('buildNodeRunner');\n * @type {Provider}\n */\nconst buildNodeRunner = provider((app) => {\n  app.set('buildNodeRunner', () => new BuildNodeRunner(\n    app.get('buildNodeRunnerProcess'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('targets'),\n    app.get('utils')\n  ));\n});\n\nmodule.exports = {\n  BuildNodeRunner,\n  buildNodeRunner,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildNodeRunner.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "class",
    "name": "BuildNodeRunner",
    "memberof": "src/services/building/buildNodeRunner.js",
    "static": true,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeRunner.js",
    "importStyle": "{BuildNodeRunner}",
    "description": "This service provides a simple interface for running targets on a development environment using\n`Nodemon`. The actual service that does the _'running'_ is `buildNodeRunnerProcess`, but this\none takes care of reading and processing a target settings before telling the other service\nto start Nodemon.",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 168,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildNodeRunnerProcess"
        ],
        "spread": false,
        "optional": false,
        "name": "buildNodeRunnerProcess",
        "description": "To actually run a target process."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the targets and their\n                                                             templates."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the information of the\n                                                             included targets."
      },
      {
        "nullable": null,
        "types": [
          "Utils"
        ],
        "spread": false,
        "optional": false,
        "name": "utils",
        "description": "To normalize executable\n                                                             extensions."
      }
    ]
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "buildNodeRunnerProcess",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#buildNodeRunnerProcess",
    "access": "public",
    "description": "A local reference for the `buildNodeRunnerProcess` service.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "BuildNodeRunnerProcess"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "utils",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#utils",
    "access": "public",
    "description": "A local reference for the `utils` service.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "Utils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "runTarget",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#runTarget",
    "access": "public",
    "description": "Run a target with Nodemon.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceInspect",
        "description": "Whether or not to _\"force enable\"_ the Node inspector,\n                                      even if the target has disabled it."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Nodemon"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target type is `browser`."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If the target needs to be bundled."
      }
    ]
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "_runWithTranspilation",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#_runWithTranspilation",
    "access": "protected",
    "description": "Runs a target that requires transpilation. It executes the file from the distribution\ndirectory while it watches the source directory.",
    "lineNumber": 75,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "NodeInspectorSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "inspectOptions",
        "description": "The options for the Node inspector."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Nodemon"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If one of the included targets requires bundling."
      }
    ]
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "_run",
    "memberof": "src/services/building/buildNodeRunner.js~BuildNodeRunner",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunner.js~BuildNodeRunner#_run",
    "access": "protected",
    "description": "Runs a target that doesn't require transpilation. It executes and watches the source directory.",
    "lineNumber": 126,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "NodeInspectorSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "inspectOptions",
        "description": "The options for the Node inspector."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Nodemon"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If one of the included targets requires bundling."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If one of the included targets requires transpiling."
      }
    ]
  },
  {
    "__docId__": 175,
    "kind": "variable",
    "name": "buildNodeRunner",
    "memberof": "src/services/building/buildNodeRunner.js",
    "static": true,
    "longname": "src/services/building/buildNodeRunner.js~buildNodeRunner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeRunner.js",
    "importStyle": "{buildNodeRunner}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildNodeRunner` as the `buildNodeRunner` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildNodeRunner);\n// Getting access to the service instance\nconst buildNodeRunner = container.get('buildNodeRunner');"
    ],
    "lineNumber": 168,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "src/services/building/buildNodeRunnerProcess.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst nodemon = require('nodemon');\nconst nodemonBus = require('nodemon/lib/utils/bus');\nconst { provider } = require('jimple');\nconst NodeWatcher = require('../../abstracts/nodeWatcher');\n\n/**\n * This service implements `nodemon` and {@link NodeWatcher} in order to run Node apps while\n * watching, transpiling and copying files.\n * @extends {NodeWatcher}\n */\nclass BuildNodeRunnerProcess extends NodeWatcher {\n  /**\n   * @param {Logger}                       appLogger            The inform on the CLI of the events\n   *                                                            of the runner.\n   * @param {BuildTranspiler}              buildTranspiler      To transpile files if needed.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the watch settings.\n   */\n  constructor(appLogger, buildTranspiler, projectConfiguration) {\n    super({\n      poll: projectConfiguration.others.watch.poll,\n    });\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `buildTranspiler` service.\n     * @type {BuildTranspiler}\n     */\n    this.buildTranspiler = buildTranspiler;\n    /**\n     * A simple flag to check whether the process is running or not.\n     * @type {boolean}\n     */\n    this.running = false;\n    /**\n     * The default values for the options that can be customized when calling `run`.\n     * @property {string}                executable     The path to the file `nodemon` will\n     *                                                  execute.\n     * @property {NodeInspectorSettings} inspectOptions The settings for the Node inspector.\n     * @property {Array}                 watch          The list of directories `nodemon` will\n     *                                                  watch in orderto reset the execution.\n     * @property {Array}                 ignore         A list of patterns `nodemon` will ignore\n     *                                                  while watching directories.\n     * @property {Object}                envVars        A dictionary of environment variables to\n     *                                                  send to the execution process.\n     * @property {boolean}               legacyWatch    Whether or not to enable `nodemon` legacy\n     *                                                  watch mode.\n     */\n    this.defaultOptions = {\n      executable: '',\n      inspectOptions: {\n        enabled: false,\n        host: '0.0.0.0',\n        port: 9229,\n        command: 'inspect',\n        ndb: false,\n      },\n      watch: [],\n      ignore: [],\n      envVars: {},\n      legacyWatch: false,\n    };\n    /**\n     * This dictionary is where the parameters sent to the `run` method and the `defaultOptions`\n     * will be merged.\n     * @type {Object}\n     */\n    this.options = {};\n    /**\n     * Whether or not the process logged the starting message.\n     * @type {boolean}\n     * @access protected\n     * @ignore\n     */\n    this._started = false;\n    /**\n     * Whether or not the process is currently being restarted.\n     * @type {boolean}\n     * @access protected\n     * @ignore\n     */\n    this._restaring = false;\n    /**\n     * Bind the method to send it to the `nodemon` events listener.\n     * @ignore\n     */\n    this._onNodemonStart = this._onNodemonStart.bind(this);\n    /**\n     * Bind the method to send it to the `nodemon` events listener.\n     * @ignore\n     */\n    this._onNodemonRestart = this._onNodemonRestart.bind(this);\n    /**\n     * Bind the method to send it to the `nodemon` events listener.\n     * @ignore\n     */\n    this._onNodemonCrash = this._onNodemonCrash.bind(this);\n    /**\n     * Bind the method to send it to the `nodemon` events listener.\n     * @ignore\n     */\n    this._onNodemonQuit = this._onNodemonQuit.bind(this);\n  }\n  /**\n   * Enables `nodemon` legacy watch mode.\n   * @see https://github.com/remy/nodemon#application-isnt-restarting\n   */\n  enableLegacyWatch() {\n    this.options.legacyWatch = true;\n  }\n  /**\n   * Run a Node application.\n   * @param {string} executable\n   * The path to the file to execute.\n   * @param {Array} watch\n   * The list of directories to watch in order to restart the application.\n   * @param {NodeInspectorSettings} inspectOptions\n   * The settings for the Node inspector.\n   * @param {Array} [transpilationPaths=[]]\n   * A list of dictionaries with `from` and `to` paths the service will use for transpilation\n   * when files change during the execution, in order to restart the application.\n   * @param {Array} [copyPaths=[]]\n   * A list of dictionaries with `from` and `to` paths the service will use for copying files\n   * when they change during the execution, in order to restart the application.\n   * @param {Object} [envVars={}]\n   * A dictionary with extra environment variables to send to the execution process.\n   * @param {Array} [ignore=['.test.js']]\n   * A list of file name patterns the service that will be ignored by the `nodemon` watcher.\n   * @param {Function(instance:BuildNodeRunnerProcess)} [setupFn=()=>{}]\n   * A custom callback that will be executed before starting (and restaring) a Node application.\n   * It can be used to \"modify the environment\" before the application runs.\n   * @return {Nodemon}\n   * @throws {Error} if the process is already running.\n   * @throws {Error} if the executable doesn't exist.\n   * @todo refactor the parameters into a single \"options object\".\n   * @todo watch the .env files.\n   */\n  run(\n    executable,\n    watch,\n    inspectOptions,\n    transpilationPaths = [],\n    copyPaths = [],\n    envVars = {},\n    ignore = ['*.test.js'],\n    setupFn = () => {}\n  ) {\n    // Check that is not already running and that the executable exists.\n    if (this.running) {\n      throw new Error(\n        'The process is already running, you can\\'t start it more than once'\n      );\n    } else if (!fs.pathExistsSync(executable)) {\n      throw new Error(`The target executable doesn't exist (${executable})`);\n    }\n    // Turn on the flag that tells the service the process is running.\n    this.running = true;\n    // Merge the default options with the parameters.\n    this.options = ObjectUtils.merge(this.defaultOptions, this.options, {\n      executable,\n      watch,\n      inspectOptions,\n      envVars,\n      ignore,\n    });\n    /**\n     * This part is tricky...\n     * First, make sure there's at least one item on the transpilation paths list, because that\n     * means that the files are being executed from a different path than its source directory.\n     * If the files change location, and the application depends on files outside its directory,\n     * then the service will watch the transpilation paths, for files that need to be moved and\n     * transpiled, and the copy files, for files that just need to be moved.\n     * The reason this is _\"tricky\"_ is because the copy paths are only added if there's\n     * transpilation, because there's no need to copy files if the code doesn't change locations.\n     */\n    if (transpilationPaths.length) {\n      this.watch(\n        [\n          ...transpilationPaths.map(({ from }) => from),\n          ...copyPaths.map(({ from }) => from),\n        ],\n        transpilationPaths,\n        copyPaths\n      );\n    }\n    // Run the callback that sets up the environment.\n    setupFn(this);\n    // Get the command for `nodemon`.\n    const command = this._getNodemonCommand();\n    // Start `nodemon`.\n    nodemon(command);\n    // Inject the function that sets up the environment.\n    this._injectSetupFnOnNodemon(setupFn);\n    // Add the `nodemon` listeners.\n    nodemon.on('start', this._onNodemonStart);\n    nodemon.on('restart', this._onNodemonRestart);\n    nodemon.on('crash', this._onNodemonCrash);\n    nodemon.on('quit', this._onNodemonQuit);\n\n    return nodemon;\n  }\n  /**\n   * Generates the `nodemon` command. The reason there's an specific method for generating it is\n   * because the service needs to validate the different options in order to enable or not the\n   * Node inspector (or ndb).\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getNodemonCommand() {\n    const {\n      executable,\n      watch,\n      ignore,\n      envVars,\n      inspectOptions,\n      legacyWatch,\n    } = this.options;\n    // Prefix the command with all the environment variables.\n    const command = [\n      ...Object.keys(envVars).map((varName) => {\n        const varValue = envVars[varName];\n        return `${varName}=${varValue}`;\n      }),\n    ];\n    // Add the `nodemon` command in the format required by the library.\n    command.push('node nodemon');\n    // If the native inspector is enabled, push the required flag.\n    if (inspectOptions.enabled && !inspectOptions.ndb) {\n      const { host, port, command: inspectCommand } = inspectOptions;\n      command.push(`--${inspectCommand}=${host}:${port}`);\n    }\n    // Add the path to the executable.\n    command.push(executable);\n    // If `ndb` is enabled, change the executable.\n    if (inspectOptions.enabled && inspectOptions.ndb) {\n      command.push('--exec \"ndb node\"');\n    }\n    // Push the paths to watch and ignore.\n    command.push(...[\n      ...watch.map((watchPath) => `--watch ${watchPath}`),\n      ...ignore.map((ignorePath) => `--ignore ${ignorePath}`),\n    ]);\n    // If required, enable the legacy watch mode.\n    if (legacyWatch) {\n      command.push('--legacy-watch');\n    }\n    // Transform the list into a string and return it.\n    return command.join(' ').trim();\n  }\n  /**\n   * This is called when a source file changes and it's detected by the service, not `nodemon`.\n   * The overwrite is just to show a log message saying that the process will be restarted, as the\n   * parent class will end up transpiling or copying a file into one the directories `nodemon`\n   * watches.\n   * @param {string} file The path to the file that changed.\n   * @access protected\n   * @ignore\n   */\n  _onChange(file) {\n    this.appLogger.warning(`Restarting because a file was modified: ${file}`);\n    super._onChange(file);\n  }\n  /**\n   * This is called when a source file changes and the service can't find a matching path on neither\n   * the transpilation paths nor the copy paths.\n   * The method will just show an error message explaning the problem and call the method that shows\n   * the error when `nodemon` crashes.\n   * @access protected\n   * @ignore\n   */\n  _onInvalidPathForChange() {\n    this.appLogger.error('Error: The file directory is not on the list of allowed paths');\n    this._onNodemonCrash();\n  }\n  /**\n   * Transpiles a file from a source directory into a build directory, which `nodemon` watches.\n   * @param {string} source The path to the source file.\n   * @param {string} output The path for the source file once transpiled.\n   * @access protected\n   * @ignore\n   */\n  _transpileFile(source, output) {\n    try {\n      // Make sure the path to the directory exists.\n      fs.ensureDirSync(path.dirname(output));\n      // Transpile the file.\n      this.buildTranspiler.transpileFileSync({ source, output });\n      this.appLogger.success('The file was successfully copied and transpiled');\n    } catch (error) {\n      this.appLogger.error('Error: The file couldn\\'t be updated');\n      this.appLogger.error(error);\n      this._onNodemonCrash();\n    }\n  }\n  /**\n   * Copies a file from a source directory into a build directory, which `nodemon` watches.\n   * @param {string} from The original path of the file.\n   * @param {string} to   The new path for the file.\n   * @access protected\n   * @ignore\n   */\n  _copyFile(from, to) {\n    try {\n      // Make sure the path to the directory exists.\n      fs.ensureDirSync(path.dirname(to));\n      // Copy the file.\n      fs.copySync(from, to);\n      this.appLogger.success('The file was successfully copied');\n    } catch (error) {\n      this.appLogger.error('Error: The file couldn\\'t be copied');\n      this.appLogger.error(error);\n      this._onNodemonCrash();\n    }\n  }\n  /**\n   * This is called when `nodemon` starts the process and after each time it restarts it. The\n   * method just prints information messages and turn on the `_started` flag.\n   * @param {boolean} [forceLog=false] By default, it only logs the messages the first time, but\n   *                                   if this flag is `true`, it will do it anyways. This is\n   *                                   used from the `_onNodemonRestart` to make sure the restart\n   *                                   messages are shown before the start.\n   * @ignore\n   * @access protected\n   */\n  _onNodemonStart(forceLog = false) {\n    // Only log the messages if it is the first time or if the force flag is `true.`\n    if (!this._started || forceLog) {\n      this.appLogger.success(`Starting ${this.options.executable}`);\n      this.appLogger.info([\n        'to restart at any time, enter \\'rs\\'',\n        ...this.options.watch.map((directory) => `watching: ${directory}`),\n      ]);\n      // Turn on the flag that informs the service this method was executed at least once.\n      this._started = true;\n    }\n  }\n  /**\n   * This is called when `nodemon` restarts a process, because a file changed or because the user\n   * requested it. It only prints information messages.\n   * @param {?Array} files A list of files that changed, thus triggering the restart.\n   * @ignore\n   * @access protected\n   */\n  _onNodemonRestart(files) {\n    /**\n     * If the code requires transpilation (which means that the service is watching directories)\n     * and this was triggered by file changes, the restart message was already printed by the\n     * `_onChange` method, so no need to print anything else.\n     */\n    if (!this.watching) {\n      if (files && files.length) {\n        const [file] = files;\n        this.appLogger.warning(`Restarting because file was modified: ${file}`);\n      } else {\n        this.appLogger.warning('Restarting');\n      }\n    } else if (!files) {\n      /**\n       * If the code requires transpilation but the change was triggered by the user, then is ok to\n       * show a message.\n       */\n      this.appLogger.warning('Restarting');\n    }\n    /**\n     * After showing the restart messages, show the start messages again.\n     * This is done this way because for some reason, the events were being triggered before the\n     * `start` and then the `restart`, showing the messages out of order. This way, the `restart`\n     * triggers the `start`, so the order of the message is always correct.\n     */\n    this._onNodemonStart(true);\n  }\n  /**\n   * This is called when `nodemon` crashes and just prints a message saying that it is still\n   * watching.\n   * @ignore\n   * @access protected\n   */\n  _onNodemonCrash() {\n    this.appLogger.error('Crash - waiting for file changes before starting...');\n  }\n  /**\n   * This is called when the `nodemon` process is stopeed. It first checks if it needs to turn off\n   * the watcher and then exits the current process.\n   * @ignore\n   * @access protected\n   */\n  _onNodemonQuit() {\n    // If the service is watching directories...\n    if (this.watching) {\n      // ...then it should be stopped.\n      this.stop();\n    }\n\n    // eslint-disable-next-line no-process-exit\n    process.exit();\n  }\n  /**\n   * Disclaimer: This is a hack... there's no other way around it.\n   * The class needs for a function to be executed right before the Nodemon process spawns, but\n   * Nodemon uses its own listeners to setup that part and once `nodemon()` is called, it's too\n   * late to set anything, the internal listeners are already in place.\n   * After some debugging, I found that right after `nodemon()` is called, the last registered\n   * listener for the `restart` event is the one that actually does the restart; so, this method\n   * injects a listener right before that one in order for it to be called just before Nodemon\n   * does stops and starts the application.\n   * The function also checks if, by any chance, there's no other \"hack function\" already\n   * registered so it can replace it instead of adding one more.\n   * @param {Function(instance:BuildNodeRunnerProcess)} setupFn The function to call before\n   *                                                            starting the application.\n   * @access protected\n   * @ignore\n   */\n  _injectSetupFnOnNodemon(setupFn) {\n    const idKey = 'buildNodeRunnerProcessSetupFn';\n    const newFn = () => setupFn(this);\n    newFn[idKey] = true;\n    const { _events: { restart: events } } = nodemonBus;\n    const existingIndex = events.findIndex((fn) => fn[idKey] === true);\n    if (existingIndex > -1) {\n      events[existingIndex] = newFn;\n    } else {\n      events.splice(events.length - 1, 0, newFn);\n    }\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildNodeRunnerProcess` as the `buildNodeRunnerProcess` service.\n * @example\n * // Register it on the container\n * container.register(buildNodeRunnerProcess);\n * // Getting access to the service instance\n * const buildNodeRunnerProcess = container.get('buildNodeRunnerProcess');\n * @type {Provider}\n */\nconst buildNodeRunnerProcess = provider((app) => {\n  app.set('buildNodeRunnerProcess', () => new BuildNodeRunnerProcess(\n    app.get('appLogger'),\n    app.get('buildTranspiler'),\n    app.get('projectConfiguration').getConfig()\n  ));\n});\n\nmodule.exports = {\n  BuildNodeRunnerProcess,\n  buildNodeRunnerProcess,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildNodeRunnerProcess.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "class",
    "name": "BuildNodeRunnerProcess",
    "memberof": "src/services/building/buildNodeRunnerProcess.js",
    "static": true,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeRunnerProcess.js",
    "importStyle": "{BuildNodeRunnerProcess}",
    "description": "This service implements `nodemon` and {@link NodeWatcher} in order to run Node apps while\nwatching, transpiling and copying files.",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "NodeWatcher"
    ]
  },
  {
    "__docId__": 178,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "The inform on the CLI of the events\n                                                           of the runner."
      },
      {
        "nullable": null,
        "types": [
          "BuildTranspiler"
        ],
        "spread": false,
        "optional": false,
        "name": "buildTranspiler",
        "description": "To transpile files if needed."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the watch settings."
      }
    ]
  },
  {
    "__docId__": 179,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "buildTranspiler",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#buildTranspiler",
    "access": "public",
    "description": "A local reference for the `buildTranspiler` service.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "BuildTranspiler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "running",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#running",
    "access": "public",
    "description": "A simple flag to check whether the process is running or not.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "defaultOptions",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#defaultOptions",
    "access": "public",
    "description": "The default values for the options that can be customized when calling `run`.",
    "lineNumber": 54,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "executable",
        "description": "The path to the file `nodemon` will\n                                                 execute."
      },
      {
        "nullable": null,
        "types": [
          "NodeInspectorSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "inspectOptions",
        "description": "The settings for the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "The list of directories `nodemon` will\n                                                 watch in orderto reset the execution."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "ignore",
        "description": "A list of patterns `nodemon` will ignore\n                                                 while watching directories."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "envVars",
        "description": "A dictionary of environment variables to\n                                                 send to the execution process."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "legacyWatch",
        "description": "Whether or not to enable `nodemon` legacy\n                                                 watch mode."
      }
    ],
    "type": {
      "types": [
        "{\"executable\": *, \"inspectOptions\": *, \"watch\": *, \"ignore\": *, \"envVars\": *, \"legacyWatch\": *}"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "options",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#options",
    "access": "public",
    "description": "This dictionary is where the parameters sent to the `run` method and the `defaultOptions`\nwill be merged.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "_started",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_started",
    "access": "protected",
    "description": "Whether or not the process logged the starting message.",
    "lineNumber": 80,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "_restaring",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_restaring",
    "access": "protected",
    "description": "Whether or not the process is currently being restarted.",
    "lineNumber": 87,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "enableLegacyWatch",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#enableLegacyWatch",
    "access": "public",
    "description": "Enables `nodemon` legacy watch mode.",
    "see": [
      "https://github.com/remy/nodemon#application-isnt-restarting"
    ],
    "lineNumber": 113,
    "params": [],
    "return": null
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "run",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#run",
    "access": "public",
    "description": "Run a Node application.",
    "lineNumber": 143,
    "todo": [
      "refactor the parameters into a single \"options object\".",
      "watch the .env files."
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "executable",
        "description": "The path to the file to execute."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "The list of directories to watch in order to restart the application."
      },
      {
        "nullable": null,
        "types": [
          "NodeInspectorSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "inspectOptions",
        "description": "The settings for the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "transpilationPaths",
        "description": "A list of dictionaries with `from` and `to` paths the service will use for transpilation\nwhen files change during the execution, in order to restart the application."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "copyPaths",
        "description": "A list of dictionaries with `from` and `to` paths the service will use for copying files\nwhen they change during the execution, in order to restart the application."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "envVars",
        "description": "A dictionary with extra environment variables to send to the execution process."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "['.test.js']",
        "defaultRaw": "['.test.js']",
        "name": "ignore",
        "description": "A list of file name patterns the service that will be ignored by the `nodemon` watcher."
      },
      {
        "nullable": null,
        "types": [
          "Function(instance:BuildNodeRunnerProcess)"
        ],
        "spread": false,
        "optional": true,
        "name": "setupFn",
        "description": "A custom callback that will be executed before starting (and restaring) a Node application.\nIt can be used to \"modify the environment\" before the application runs."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Nodemon"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the process is already running."
      },
      {
        "types": [
          "Error"
        ],
        "description": "if the executable doesn't exist."
      }
    ]
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "_getNodemonCommand",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_getNodemonCommand",
    "access": "protected",
    "description": "Generates the `nodemon` command. The reason there's an specific method for generating it is\nbecause the service needs to validate the different options in order to enable or not the\nNode inspector (or ndb).",
    "lineNumber": 215,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "_onChange",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onChange",
    "access": "protected",
    "description": "This is called when a source file changes and it's detected by the service, not `nodemon`.\nThe overwrite is just to show a log message saying that the process will be restarted, as the\nparent class will end up transpiling or copying a file into one the directories `nodemon`\nwatches.",
    "lineNumber": 265,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to the file that changed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "_onInvalidPathForChange",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onInvalidPathForChange",
    "access": "protected",
    "description": "This is called when a source file changes and the service can't find a matching path on neither\nthe transpilation paths nor the copy paths.\nThe method will just show an error message explaning the problem and call the method that shows\nthe error when `nodemon` crashes.",
    "lineNumber": 277,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "_transpileFile",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_transpileFile",
    "access": "protected",
    "description": "Transpiles a file from a source directory into a build directory, which `nodemon` watches.",
    "lineNumber": 288,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The path to the source file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "The path for the source file once transpiled."
      }
    ],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "_copyFile",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_copyFile",
    "access": "protected",
    "description": "Copies a file from a source directory into a build directory, which `nodemon` watches.",
    "lineNumber": 308,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The original path of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The new path for the file."
      }
    ],
    "return": null
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "_onNodemonStart",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onNodemonStart",
    "access": "protected",
    "description": "This is called when `nodemon` starts the process and after each time it restarts it. The\nmethod just prints information messages and turn on the `_started` flag.",
    "lineNumber": 331,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceLog",
        "description": "By default, it only logs the messages the first time, but\n                                  if this flag is `true`, it will do it anyways. This is\n                                  used from the `_onNodemonRestart` to make sure the restart\n                                  messages are shown before the start."
      }
    ],
    "return": null
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "_onNodemonRestart",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onNodemonRestart",
    "access": "protected",
    "description": "This is called when `nodemon` restarts a process, because a file changed or because the user\nrequested it. It only prints information messages.",
    "lineNumber": 350,
    "ignore": true,
    "params": [
      {
        "nullable": true,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "A list of files that changed, thus triggering the restart."
      }
    ],
    "return": null
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "_onNodemonCrash",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onNodemonCrash",
    "access": "protected",
    "description": "This is called when `nodemon` crashes and just prints a message saying that it is still\nwatching.",
    "lineNumber": 384,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "_onNodemonQuit",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_onNodemonQuit",
    "access": "protected",
    "description": "This is called when the `nodemon` process is stopeed. It first checks if it needs to turn off\nthe watcher and then exits the current process.",
    "lineNumber": 393,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "_injectSetupFnOnNodemon",
    "memberof": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeRunnerProcess.js~BuildNodeRunnerProcess#_injectSetupFnOnNodemon",
    "access": "protected",
    "description": "Disclaimer: This is a hack... there's no other way around it.\nThe class needs for a function to be executed right before the Nodemon process spawns, but\nNodemon uses its own listeners to setup that part and once `nodemon()` is called, it's too\nlate to set anything, the internal listeners are already in place.\nAfter some debugging, I found that right after `nodemon()` is called, the last registered\nlistener for the `restart` event is the one that actually does the restart; so, this method\ninjects a listener right before that one in order for it to be called just before Nodemon\ndoes stops and starts the application.\nThe function also checks if, by any chance, there's no other \"hack function\" already\nregistered so it can replace it instead of adding one more.",
    "lineNumber": 419,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function(instance:BuildNodeRunnerProcess)"
        ],
        "spread": false,
        "optional": false,
        "name": "setupFn",
        "description": "The function to call before\n                                                           starting the application."
      }
    ],
    "return": null
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "buildNodeRunnerProcess",
    "memberof": "src/services/building/buildNodeRunnerProcess.js",
    "static": true,
    "longname": "src/services/building/buildNodeRunnerProcess.js~buildNodeRunnerProcess",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeRunnerProcess.js",
    "importStyle": "{buildNodeRunnerProcess}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildNodeRunnerProcess` as the `buildNodeRunnerProcess` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildNodeRunnerProcess);\n// Getting access to the service instance\nconst buildNodeRunnerProcess = container.get('buildNodeRunnerProcess');"
    ],
    "lineNumber": 442,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 206,
    "kind": "file",
    "name": "src/services/building/buildNodeWatcher.js",
    "content": "const { provider } = require('jimple');\n/**\n * This service provides a simple interface for watching targets using `watchpack`.\n * The actual service that does the _'watching'_ is `buildNodeWatcherProcess`, but this\n * one takes care of reading and processing a target settings before telling the other service\n * to start watching.\n */\nclass BuildNodeWatcher {\n  /**\n   * @param {BuildNodeWatcherProcess#run} buildNodeWatcherProcess To actually watch a target files.\n   * @param {Targets}                     targets                 To get the information of the\n   *                                                              included targets.\n   */\n  constructor(buildNodeWatcherProcess, targets) {\n    /**\n     * A local reference for the `buildNodeWatcherProcess` service.\n     * @type {BuildNodeWatcherProcess#run}\n     */\n    this.buildNodeWatcherProcess = buildNodeWatcherProcess;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n  }\n  /**\n   * Watch a target.\n   * @param  {Target} target The target information.\n   * @return {Watchpack}\n   * @throws {Error} If the target needs to be bundled.\n   * @throws {Error} If one of the included targets requires bundling.\n   */\n  watchTarget(target) {\n    if (target.bundle) {\n      throw new Error(`${target.name} needs to be bundled`);\n    }\n\n    const {\n      includeTargets,\n      transpile,\n      paths: { source, build },\n    } = target;\n    const watch = [source];\n    const transpilationPaths = [];\n    const copyPaths = [];\n    const targetPathSettings = {\n      from: source,\n      to: build,\n    };\n\n    if (transpile) {\n      transpilationPaths.push(targetPathSettings);\n    } else {\n      copyPaths.push(targetPathSettings);\n    }\n\n    includeTargets.forEach((name) => {\n      const subTarget = this.targets.getTarget(name);\n      if (subTarget.bundle) {\n        const errorMessage = `The target ${name} requires bundling so it can't be ` +\n          `included by ${target.name}`;\n        throw new Error(errorMessage);\n      } else {\n        const pathSettings = {\n          from: subTarget.paths.source,\n          to: subTarget.paths.build,\n        };\n        watch.push(pathSettings.from);\n        if (subTarget.transpile) {\n          transpilationPaths.push(pathSettings);\n        } else {\n          copyPaths.push(pathSettings);\n        }\n      }\n    });\n\n    return this.buildNodeWatcherProcess(\n      watch,\n      transpilationPaths,\n      copyPaths\n    );\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildNodeWatcher` as the `buildNodeWatcher` service.\n * @example\n * // Register it on the container\n * container.register(buildNodeWatcher);\n * // Getting access to the service instance\n * const buildNodeWatcher = container.get('buildNodeWatcher');\n * @type {Provider}\n */\nconst buildNodeWatcher = provider((app) => {\n  app.set('buildNodeWatcher', () => new BuildNodeWatcher(\n    app.get('buildNodeWatcherProcess'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  BuildNodeWatcher,\n  buildNodeWatcher,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildNodeWatcher.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 207,
    "kind": "class",
    "name": "BuildNodeWatcher",
    "memberof": "src/services/building/buildNodeWatcher.js",
    "static": true,
    "longname": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeWatcher.js",
    "importStyle": "{BuildNodeWatcher}",
    "description": "This service provides a simple interface for watching targets using `watchpack`.\nThe actual service that does the _'watching'_ is `buildNodeWatcherProcess`, but this\none takes care of reading and processing a target settings before telling the other service\nto start watching.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 208,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildNodeWatcherProcess#run"
        ],
        "spread": false,
        "optional": false,
        "name": "buildNodeWatcherProcess",
        "description": "To actually watch a target files."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the information of the\n                                                             included targets."
      }
    ]
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "buildNodeWatcherProcess",
    "memberof": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher",
    "static": false,
    "longname": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher#buildNodeWatcherProcess",
    "access": "public",
    "description": "A local reference for the `buildNodeWatcherProcess` service.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "BuildNodeWatcherProcess#run"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher",
    "static": false,
    "longname": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "watchTarget",
    "memberof": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcher.js~BuildNodeWatcher#watchTarget",
    "access": "public",
    "description": "Watch a target.",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Watchpack"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target needs to be bundled."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If one of the included targets requires bundling."
      }
    ]
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "name": "buildNodeWatcher",
    "memberof": "src/services/building/buildNodeWatcher.js",
    "static": true,
    "longname": "src/services/building/buildNodeWatcher.js~buildNodeWatcher",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeWatcher.js",
    "importStyle": "{buildNodeWatcher}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildNodeWatcher` as the `buildNodeWatcher` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildNodeWatcher);\n// Getting access to the service instance\nconst buildNodeWatcher = container.get('buildNodeWatcher');"
    ],
    "lineNumber": 94,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 213,
    "kind": "file",
    "name": "src/services/building/buildNodeWatcherProcess.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\nconst NodeWatcher = require('../../abstracts/nodeWatcher');\n/**\n * This service watches directories in order to copy and/or transpile files into their\n * build/distribution directories when they change.\n * @extends {NodeWatcher}\n */\nclass BuildNodeWatcherProcess extends NodeWatcher {\n  /**\n   * @param {Logger}                       appLogger            The inform on the CLI of the events\n   *                                                            of the watcher.\n   * @param {BuildTranspiler}              buildTranspiler      To transpile files if needed.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the watch settings.\n   */\n  constructor(appLogger, buildTranspiler, projectConfiguration) {\n    super({\n      poll: projectConfiguration.others.watch.poll,\n    });\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `buildTranspiler` service.\n     * @type {BuildTranspiler}\n     */\n    this.buildTranspiler = buildTranspiler;\n  }\n  /**\n   * This is called when the service is about to start watching the directories.\n   * The overwrite is just for logging some information messages.\n   * @access protected\n   * @ignore\n   */\n  _onStart() {\n    this.appLogger.success('Starting watch mode');\n    this.appLogger.info(this.getPaths().map((directory) => `watching: ${directory}`));\n  }\n\n  /**\n   * This is called when a source file changes and it's detected by the service.\n   * The overwrite is just to show an information message.\n   * @param {string} file The path to the file that changed.\n   * @access protected\n   * @ignore\n   */\n  _onChange(file) {\n    this.appLogger.warning(`Change detected on ${file}`);\n    super._onChange(file);\n  }\n  /**\n   * This is called when a source file changes and the service can't find a matching path on neither\n   * the transpilation paths nor the copy paths.\n   * The method will just show an error message explaning the problem.\n   * @access protected\n   * @ignore\n   */\n  _onInvalidPathForChange() {\n    this.appLogger.error('Error: The file directory is not on the list of allowed paths');\n  }\n  /**\n   * Transpiles a file from a source directory into a build directory.\n   * @param {string} source The path to the source file.\n   * @param {string} output The path for the source file once transpiled.\n   * @access protected\n   * @ignore\n   */\n  _transpileFile(source, output) {\n    try {\n      // Make sure the path to the directory exists.\n      fs.ensureDirSync(path.dirname(output));\n      // Transpile the file.\n      this.buildTranspiler.transpileFileSync({ source, output });\n      this.appLogger.success('The file was successfully copied and transpiled');\n    } catch (error) {\n      this.appLogger.error('Error: The file couldn\\'t be updated');\n      this.appLogger.error(error);\n    }\n  }\n  /**\n   * Copies a file from a source directory into a build directory.\n   * @param {string} from The original path of the file.\n   * @param {string} to   The new path for the file.\n   * @access protected\n   * @ignore\n   */\n  _copyFile(from, to) {\n    try {\n      // Make sure the path to the directory exists.\n      fs.ensureDirSync(path.dirname(to));\n      // Copy the file.\n      fs.copySync(from, to);\n      this.appLogger.success('The file was successfully copied');\n    } catch (error) {\n      this.appLogger.error('Error: The file couldn\\'t be copied');\n      this.appLogger.error(error);\n    }\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildNodeWatcherProcess` as the `buildNodeWatcherProcess` service.\n * @example\n * // Register it on the container\n * container.register(buildNodeWatcherProcess);\n * // Getting access to the service instance\n * const buildNodeWatcherProcess = container.get('buildNodeWatcherProcess');\n * @type {Provider}\n */\nconst buildNodeWatcherProcess = provider((app) => {\n  app.set('buildNodeWatcherProcess', () => new BuildNodeWatcherProcess(\n    app.get('appLogger'),\n    app.get('buildTranspiler'),\n    app.get('projectConfiguration').getConfig()\n  ).watch);\n});\n\nmodule.exports = {\n  BuildNodeWatcherProcess,\n  buildNodeWatcherProcess,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildNodeWatcherProcess.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 214,
    "kind": "class",
    "name": "BuildNodeWatcherProcess",
    "memberof": "src/services/building/buildNodeWatcherProcess.js",
    "static": true,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeWatcherProcess.js",
    "importStyle": "{BuildNodeWatcherProcess}",
    "description": "This service watches directories in order to copy and/or transpile files into their\nbuild/distribution directories when they change.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "NodeWatcher"
    ]
  },
  {
    "__docId__": 215,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "The inform on the CLI of the events\n                                                           of the watcher."
      },
      {
        "nullable": null,
        "types": [
          "BuildTranspiler"
        ],
        "spread": false,
        "optional": false,
        "name": "buildTranspiler",
        "description": "To transpile files if needed."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the watch settings."
      }
    ]
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "buildTranspiler",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#buildTranspiler",
    "access": "public",
    "description": "A local reference for the `buildTranspiler` service.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "BuildTranspiler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "_onStart",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#_onStart",
    "access": "protected",
    "description": "This is called when the service is about to start watching the directories.\nThe overwrite is just for logging some information messages.",
    "lineNumber": 38,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "_onChange",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#_onChange",
    "access": "protected",
    "description": "This is called when a source file changes and it's detected by the service.\nThe overwrite is just to show an information message.",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to the file that changed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "_onInvalidPathForChange",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#_onInvalidPathForChange",
    "access": "protected",
    "description": "This is called when a source file changes and the service can't find a matching path on neither\nthe transpilation paths nor the copy paths.\nThe method will just show an error message explaning the problem.",
    "lineNumber": 61,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "_transpileFile",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#_transpileFile",
    "access": "protected",
    "description": "Transpiles a file from a source directory into a build directory.",
    "lineNumber": 71,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The path to the source file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "The path for the source file once transpiled."
      }
    ],
    "return": null
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "_copyFile",
    "memberof": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildNodeWatcherProcess.js~BuildNodeWatcherProcess#_copyFile",
    "access": "protected",
    "description": "Copies a file from a source directory into a build directory.",
    "lineNumber": 90,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The original path of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The new path for the file."
      }
    ],
    "return": null
  },
  {
    "__docId__": 223,
    "kind": "variable",
    "name": "buildNodeWatcherProcess",
    "memberof": "src/services/building/buildNodeWatcherProcess.js",
    "static": true,
    "longname": "src/services/building/buildNodeWatcherProcess.js~buildNodeWatcherProcess",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildNodeWatcherProcess.js",
    "importStyle": "{buildNodeWatcherProcess}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildNodeWatcherProcess` as the `buildNodeWatcherProcess` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildNodeWatcherProcess);\n// Getting access to the service instance\nconst buildNodeWatcherProcess = container.get('buildNodeWatcherProcess');"
    ],
    "lineNumber": 113,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 224,
    "kind": "file",
    "name": "src/services/building/buildTranspiler.js",
    "content": "const path = require('path');\nconst babel = require('@babel/core');\nconst fs = require('fs-extra');\nconst glob = require('glob');\nconst { provider } = require('jimple');\n/**\n * Manages the transpilation of target files using Babel.\n */\nclass BuildTranspiler {\n  /**\n   * Class constructor.\n   * @param {BabelConfiguration} babelConfiguration To get a target Babel configuration.\n   * @param {Logger}             appLogger          To print information messages after transpiling\n   *                                                files.\n   * @param {Targets}            targets            To access targets information.\n   * @param {Utils}              utils              To normalize file extensions.\n   */\n  constructor(\n    babelConfiguration,\n    appLogger,\n    targets,\n    utils\n  ) {\n    /**\n     * A local reference for the `babelConfiguration` service.\n     * @type {BabelConfiguration}\n     */\n    this.babelConfiguration = babelConfiguration;\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * A local reference for the `utils` service.\n     * @type {Utils}\n     */\n    this.utils = utils;\n  }\n  /**\n   * Transpile a target files for a given build type. This requires the target files to have been\n   * previously copied to the distribution directory.\n   * @param {Target} target                    The target information.\n   * @param {string} [buildType='development'] The build type for which the target is being\n   *                                           transpiled for. This will be used to read the source\n   *                                           map settings of the target and tell Babel if it needs\n   *                                           to create them.\n   * @return {Promise<undefined,Error}\n   */\n  transpileTargetFiles(target, buildType = 'development') {\n    const {\n      paths: { build: buildPath },\n      folders: { build: buildFolder },\n      includeTargets,\n      sourceMap,\n    } = target;\n    // Define the variable to return.\n    let result;\n    // Get the information of all the targets on the `includeTargets` list.\n    const includedTargets = includeTargets.map((name) => this.targets.getTarget(name));\n    // Try to find one that requires bundling.\n    const bundledTarget = includedTargets.find((info) => info.bundle);\n    if (bundledTarget) {\n      // If there's one that requires bundling, set to return a rejected promise.\n      const errorMessage = `The target ${bundledTarget.name} requires bundling so it can't be ` +\n        `included by ${target.name}`;\n      result = Promise.reject(new Error(errorMessage));\n    } else {\n      // Find all the JS files on the target path inside the distribution directory.\n      result = this.findFiles(buildPath)\n      .then((files) => {\n        // Get the Babel configuration for the target.\n        const babelConfig = this.babelConfiguration.getConfigForTarget(target);\n        // Enable source map if the target requires it for the specified build type.\n        if (sourceMap[buildType]) {\n          babelConfig.sourceMaps = true;\n        }\n        // Loop all the files and transpile them\n        return Promise.all(files.map((file) => this.transpileFile(\n          file,\n          buildType,\n          babelConfig\n        )));\n      })\n      .then((files) => {\n        this.appLogger.success('The following files have been successfully transpiled:');\n        // Log all the files that have been transpiled.\n        files.forEach((file) => {\n          const filepath = file.substr(buildPath.length);\n          this.appLogger.info(`> ${buildFolder}${filepath}`);\n        });\n\n        let nextStep;\n        if (includedTargets.length) {\n          // ...chain their promises.\n          nextStep = Promise.all(includedTargets.map((info) => this.transpileTargetFiles(info)));\n        }\n\n        return nextStep;\n      })\n      .catch((error) => {\n        this.appLogger.error(\n          `There was an error while transpiling the target '${target.name}' code`\n        );\n        return Promise.reject(error);\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Transpile a file.\n   * @param {string|Object} filepath                  If used as a string, it's the path to the\n   *                                                  file to transpile; if used as an object, it\n   *                                                  should have `source` and `output` properties\n   *                                                  to define from where to where the file is\n   *                                                  transpiled.\n   * @param {string}        [buildType='development'] The build type for which the file is being\n   *                                                  transpiled for. If `options` is not\n   *                                                  specified, the method will try to load the\n   *                                                  target configuration based on the file path,\n   *                                                  and if the target has source maps enabled for\n   *                                                  the build type, it will tell Babel to\n   *                                                  create them.\n   * @param {?Object}       [options=null]            The Babel configuration to use. If not\n   *                                                  defined, the method will try to find a target\n   *                                                  configuration using the path of the file.\n   * @param {boolean}       [writeFile=true]          If `true`, it will write the transpile code,\n   *                                                  otherwise, it will return it on the promise.\n   * @return {Promise<Object|string,Error>} If `writeFile` is true, the promise will resolve on\n   *                                        an object with the keys `filepath` (the path where it\n   *                                        was transpiled) and `code`; but if the parameter is\n   *                                        `false`, the promise will resolve on a string with\n   *                                        the path to the file.\n   */\n  transpileFile(filepath, buildType = 'development', options = null, writeFile = true) {\n    let from = '';\n    let originalTo = '';\n    let to = '';\n    /**\n     * Check if the file is a string or an object and define the from where to where the\n     * transpilation should happen.\n     */\n    if (typeof filepath === 'string') {\n      from = filepath;\n      originalTo = filepath;\n    } else {\n      from = filepath.source;\n      originalTo = filepath.output;\n    }\n    // Normalize custom JS extensions (jsx, ts or tsx) to `.js`\n    to = this.utils.ensureExtension(originalTo);\n    // If no options were defined, try to get them from a target, using the path of the file.\n    const babelOptions = options || this.getTargetConfigurationForFile(from, buildType);\n    // First, transform the file with Babel.\n    const firstStep = new Promise((resolve, reject) => {\n      babel.transformFile(from, babelOptions, (error, transpiled) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(transpiled);\n        }\n      });\n    });\n\n    let result;\n    // If the file should be written...\n    if (writeFile) {\n      result = firstStep\n      .then((transpiled) => {\n        // Define the list of promises that need to be executed.\n        const nextSteps = [];\n        // Extract the code and the source map from the transpilation results.\n        const { code, map } = transpiled;\n        let newCode = code;\n        // If there's a map...\n        if (map) {\n          // ...parse and normalize it.\n          const sourceMap = this._normalizeSourceMap(to, map);\n          // ...update the code to include the link for the map.\n          newCode = `${code}\\n${sourceMap.link}\\n`;\n          // ...push the writing of the map onto the promises list.\n          nextSteps.push(fs.writeFile(sourceMap.filepath, sourceMap.code));\n        }\n        // Push the writing of the transpiled code on the promises list.\n        nextSteps.unshift(fs.writeFile(to, newCode));\n        // Process all the _\"writing promises\"_.\n        return Promise.all(nextSteps);\n      })\n      // ...if the file wasn't a normal `.js` and the original still exists, delete it.\n      .then(() => (to !== originalTo ? fs.pathExists(originalTo) : false))\n      .then((exists) => (exists ? fs.remove(originalTo) : null))\n      // And return the path to the transpiled file.\n      .then(() => to);\n    } else {\n      result = firstStep\n      // Return the code and the path it should've been saved.\n      .then((transpiled) => Object.assign({}, transpiled, { filepath: to }));\n    }\n\n    return result;\n  }\n  /**\n   * Synchronous version of `transpileFile`.\n   * @param {string|Object} filepath                  If used as a string, it's the path to the\n   *                                                  file to transpile; if used as an object, it\n   *                                                  should have `source` and `output` properties\n   *                                                  to define from where to where the file is\n   *                                                  transpiled.\n   * @param {string}        [buildType='development'] The build type for which the file is being\n   *                                                  transpiled for. If `options` is not\n   *                                                  specified, the method will try to load the\n   *                                                  target configuration based on the file path,\n   *                                                  and if the target has source maps enabled for\n   *                                                  the build type, it will tell Babel to\n   *                                                  create them.\n   * @param {?Object}       [options=null]            The Babel configuration to use. If not\n   *                                                  defined, the method will try to find a\n   *                                                  target configuration using the path of the\n   *                                                  file.\n   * @param {boolean}       [writeFile=true]          If `true`, it will write the transpile code,\n   *                                                  otherwise, it will return it.\n   * @return {Object|string} If `writeFile` is true, it will return an object with the keys\n   *                         `filepath` (the path where it was transpiled) and `code`; but if the\n   *                         parameter is `false`, it will return a string with the path to the\n   *                         file.\n   */\n  transpileFileSync(filepath, buildType = 'development', options = null, writeFile = true) {\n    let from = '';\n    let originalTo = '';\n    let to = '';\n    /**\n     * Check if the file is a string or an object and define the from where to where the\n     * transpilation should happen.\n     */\n    if (typeof filepath === 'string') {\n      from = filepath;\n      originalTo = filepath;\n    } else {\n      from = filepath.source;\n      originalTo = filepath.output;\n    }\n    // Normalize custom JS extensions (jsx, ts or tsx) to `.js`\n    to = this.utils.ensureExtension(originalTo);\n    // If no options were defined, try to get them from a target, using the path of the file.\n    const babelOptions = options || this.getTargetConfigurationForFile(from, buildType);\n    // First, transform the file with Babel.\n    const transpiled = babel.transformFileSync(from, babelOptions);\n    let result;\n\n    // If the file should be written...\n    if (writeFile) {\n      // Extract the code and the source map from the transpilation results\n      const { code, map } = transpiled;\n      let newCode = code;\n      // If there's a map...\n      if (map) {\n        // ...parse and normalize it.\n        const sourceMap = this._normalizeSourceMap(to, map);\n        // ...update the code to include the link for the map.\n        newCode = `${code}\\n${sourceMap.link}\\n`;\n        // ...write the source map.\n        fs.writeFileSync(sourceMap.filepath, sourceMap.code);\n      }\n\n      // ...write the file.\n      fs.writeFileSync(to, newCode);\n      // ...if the file wasn't a normal `.js` and the original still exists, delete it.\n      if (to !== originalTo && fs.pathExistsSync(originalTo)) {\n        fs.removeSync(originalTo);\n      }\n      // And set to return the path to the transpiled file.\n      result = to;\n    } else {\n      // Set to return the code and the path it should've been saved.\n      result = Object.assign({}, transpiled, { filepath: to });\n    }\n\n    return result;\n  }\n  /**\n   * Find files of a given type on a directory.\n   * @param {string} directory                         The directory where the files will be\n   *                                                   searched for.\n   * @param {string} [pattern='**\\/*.{js,jsx,ts,tsx}'] A glob pattern to match the files.\n   * @return {Promise<Array,Error>} If everything goes well, the promise will resolve on the list\n   *                                of files found.\n   */\n  findFiles(directory, pattern = '**/*.{js,jsx,ts,tsx}') {\n    return new Promise((resolve, reject) => {\n      glob(pattern, { cwd: directory }, (error, files) => {\n        if (error) {\n          reject(error);\n        } else {\n          let newFiles = files\n          // Filter out TypeScript declaration files.\n          .filter((file) => !file.match(/\\.d\\.tsx?$/i));\n\n          // Generate a list of the TypeScript files.\n          const tsFiles = newFiles\n          .filter((file) => file.match(/\\.tsx?$/i))\n          // Remove their extensions for the next validation.\n          .map((file) => file.replace(/\\.tsx?$/i, ''));\n\n          // If there are TypeScript files...\n          if (tsFiles.length) {\n            /**\n             * Filter the file list by removing those `.js` which have a `.tsx?` file with the\n             * same name, as they were generated by transpilation and they don't need to be\n             * transpilated again.\n             */\n            newFiles = newFiles.filter((file) => (\n              !file.match(/\\.js$/i) ||\n              !tsFiles.includes(file.replace(/\\.js$/i, ''))\n            ));\n          }\n          // Add the full path to all the files.\n          newFiles = newFiles.map((file) => path.join(directory, file));\n          resolve(newFiles);\n        }\n      });\n    });\n  }\n  /**\n   * Get a target Babel configuration based on a filepath.\n   * @param {string} file                      The file that will be used to obtain the target and\n   *                                           then the Babel configuration.\n   * @param {string} [buildType='development'] The build type for which the configuration is\n   *                                           needed for. This allows the method to check if the\n   *                                           target has source map enabled for the build type,\n   *                                           and if this happens, it will also enable it on the\n   *                                           configuration it returns.\n   * @return {Object}\n   */\n  getTargetConfigurationForFile(file, buildType = 'development') {\n    /**\n     * Find target using the received filepath. The method will throw an error if a target is not\n     * found.\n     */\n    const target = this.targets.findTargetForFile(file);\n    // Return the Babel configuration for the found target.\n    const config = this.babelConfiguration.getConfigForTarget(target);\n    if (target.sourceMap[buildType]) {\n      config.sourceMaps = true;\n    }\n\n    return config;\n  }\n  /**\n   * This is a helper method that prepares all the source map information needed to link it on the\n   * transpiled file and write it on the file system.\n   * @param {string} filepath      The path to the file the map is for.\n   * @param {Object} mapProperties The map properties generated by Babel.\n   * @return {Object}\n   * @property {string} filepath The complete path to the source map.\n   * @property {string} filename The name of the source map.\n   * @property {string} link     The comment needed on the original source to link the source map.\n   * @property {string} code     The actual code of the source map.\n   * @access protected\n   * @ignore\n   */\n  _normalizeSourceMap(filepath, mapProperties) {\n    const mapPath = `${filepath}.map`;\n    const mapName = path.basename(mapPath);\n    const link = `//# sourceMappingURL=${mapName}`;\n    const code = JSON.stringify(Object.assign({}, mapProperties, { sources: [] }));\n    return {\n      filepath: mapPath,\n      filename: mapName,\n      link,\n      code,\n    };\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildTranspiler` as the `buildTranspiler` service.\n * @example\n * // Register it on the container\n * container.register(buildTranspiler);\n * // Getting access to the service instance\n * const buildTranspiler = container.get('buildTranspiler');\n * @type {Provider}\n */\nconst buildTranspiler = provider((app) => {\n  app.set('buildTranspiler', () => new BuildTranspiler(\n    app.get('babelConfiguration'),\n    app.get('appLogger'),\n    app.get('targets'),\n    app.get('utils')\n  ));\n});\n\nmodule.exports = {\n  BuildTranspiler,\n  buildTranspiler,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildTranspiler.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 225,
    "kind": "class",
    "name": "BuildTranspiler",
    "memberof": "src/services/building/buildTranspiler.js",
    "static": true,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildTranspiler.js",
    "importStyle": "{BuildTranspiler}",
    "description": "Manages the transpilation of target files using Babel.",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 226,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "BabelConfiguration"
        ],
        "spread": false,
        "optional": false,
        "name": "babelConfiguration",
        "description": "To get a target Babel configuration."
      },
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To print information messages after transpiling\n                                               files."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To access targets information."
      },
      {
        "nullable": null,
        "types": [
          "Utils"
        ],
        "spread": false,
        "optional": false,
        "name": "utils",
        "description": "To normalize file extensions."
      }
    ]
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "babelConfiguration",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#babelConfiguration",
    "access": "public",
    "description": "A local reference for the `babelConfiguration` service.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "BabelConfiguration"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "utils",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#utils",
    "access": "public",
    "description": "A local reference for the `utils` service.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Utils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "transpileTargetFiles",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#transpileTargetFiles",
    "access": "public",
    "description": "Transpile a target files for a given build type. This requires the target files to have been\npreviously copied to the distribution directory.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The build type for which the target is being\n                                          transpiled for. This will be used to read the source\n                                          map settings of the target and tell Babel if it needs\n                                          to create them."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "transpileFile",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#transpileFile",
    "access": "public",
    "description": "Transpile a file.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "If used as a string, it's the path to the\n                                                 file to transpile; if used as an object, it\n                                                 should have `source` and `output` properties\n                                                 to define from where to where the file is\n                                                 transpiled."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The build type for which the file is being\n                                                 transpiled for. If `options` is not\n                                                 specified, the method will try to load the\n                                                 target configuration based on the file path,\n                                                 and if the target has source maps enabled for\n                                                 the build type, it will tell Babel to\n                                                 create them."
      },
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options",
        "description": "The Babel configuration to use. If not\n                                                 defined, the method will try to find a target\n                                                 configuration using the path of the file."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "writeFile",
        "description": "If `true`, it will write the transpile code,\n                                                 otherwise, it will return it on the promise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object|string,Error>"
      ],
      "spread": false,
      "description": "If `writeFile` is true, the promise will resolve on\n                                       an object with the keys `filepath` (the path where it\n                                       was transpiled) and `code`; but if the parameter is\n                                       `false`, the promise will resolve on a string with\n                                       the path to the file."
    }
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "transpileFileSync",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#transpileFileSync",
    "access": "public",
    "description": "Synchronous version of `transpileFile`.",
    "lineNumber": 233,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "If used as a string, it's the path to the\n                                                 file to transpile; if used as an object, it\n                                                 should have `source` and `output` properties\n                                                 to define from where to where the file is\n                                                 transpiled."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The build type for which the file is being\n                                                 transpiled for. If `options` is not\n                                                 specified, the method will try to load the\n                                                 target configuration based on the file path,\n                                                 and if the target has source maps enabled for\n                                                 the build type, it will tell Babel to\n                                                 create them."
      },
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options",
        "description": "The Babel configuration to use. If not\n                                                 defined, the method will try to find a\n                                                 target configuration using the path of the\n                                                 file."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "writeFile",
        "description": "If `true`, it will write the transpile code,\n                                                 otherwise, it will return it."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "string"
      ],
      "spread": false,
      "description": "If `writeFile` is true, it will return an object with the keys\n                        `filepath` (the path where it was transpiled) and `code`; but if the\n                        parameter is `false`, it will return a string with the path to the\n                        file."
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "findFiles",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#findFiles",
    "access": "public",
    "description": "Find files of a given type on a directory.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "directory",
        "description": "The directory where the files will be\n                                                  searched for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'**\\/*.{js,jsx,ts,tsx}'",
        "defaultRaw": "'**\\/*.{js,jsx,ts,tsx}'",
        "name": "pattern",
        "description": "A glob pattern to match the files."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the promise will resolve on the list\n                               of files found."
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "getTargetConfigurationForFile",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#getTargetConfigurationForFile",
    "access": "public",
    "description": "Get a target Babel configuration based on a filepath.",
    "lineNumber": 340,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The file that will be used to obtain the target and\n                                          then the Babel configuration."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The build type for which the configuration is\n                                          needed for. This allows the method to check if the\n                                          target has source map enabled for the build type,\n                                          and if this happens, it will also enable it on the\n                                          configuration it returns."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "_normalizeSourceMap",
    "memberof": "src/services/building/buildTranspiler.js~BuildTranspiler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTranspiler.js~BuildTranspiler#_normalizeSourceMap",
    "access": "protected",
    "description": "This is a helper method that prepares all the source map information needed to link it on the\ntranspiled file and write it on the file system.",
    "lineNumber": 367,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file the map is for."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mapProperties",
        "description": "The map properties generated by Babel."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The complete path to the source map."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filename",
        "description": "The name of the source map."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "link",
        "description": "The comment needed on the original source to link the source map."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "The actual code of the source map."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 237,
    "kind": "variable",
    "name": "buildTranspiler",
    "memberof": "src/services/building/buildTranspiler.js",
    "static": true,
    "longname": "src/services/building/buildTranspiler.js~buildTranspiler",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildTranspiler.js",
    "importStyle": "{buildTranspiler}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildTranspiler` as the `buildTranspiler` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildTranspiler);\n// Getting access to the service instance\nconst buildTranspiler = container.get('buildTranspiler');"
    ],
    "lineNumber": 390,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "src/services/building/buildTypeScriptHelper.js",
    "content": "const { provider } = require('jimple');\n/**\n * This service works as a helper to generate TypeScript binary commands.\n */\nclass BuildTypeScriptHelper {\n  /**\n   * Class constructor.\n   * @ignore\n   */\n  constructor() {\n    /**\n     * The path of the TypeScript binary that will execute the commands.\n     * @type {string}\n     * @access protected\n     * @ignore\n     */\n    this._bin = 'tsc';\n  }\n  /**\n   * Gets the command that generates the TypeScript declaration file(s) for a target.\n   * @param {Target} target The target from which the method will take the input (source) and\n   *                        output (build) paths.\n   * @return {string}\n   */\n  getDeclarationsCommand(target) {\n    const {\n      paths: {\n        build,\n        source,\n      },\n    } = target;\n    return this._command(`--emitDeclarationOnly --outDir ${build} --rootDir ${source}`);\n  }\n  /**\n   * Helper method that just puts the Typescript binary path on front of a set of instructions.\n   * @param {string} instructions The instructions for the TypeScript binary.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _command(instructions) {\n    return `${this._bin} ${instructions}`;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildTypeScriptHelper` as the `buildTypeScriptHelper` service.\n * @example\n * // Register it on the container\n * container.register(buildTypeScriptHelper);\n * // Getting access to the service instance\n * const buildTypeScriptHelper = container.get('buildTypeScriptHelper');\n * @type {Provider}\n */\nconst buildTypeScriptHelper = provider((app) => {\n  app.set('buildTypeScriptHelper', () => new BuildTypeScriptHelper());\n});\n\nmodule.exports = {\n  BuildTypeScriptHelper,\n  buildTypeScriptHelper,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildTypeScriptHelper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "class",
    "name": "BuildTypeScriptHelper",
    "memberof": "src/services/building/buildTypeScriptHelper.js",
    "static": true,
    "longname": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildTypeScriptHelper.js",
    "importStyle": "{BuildTypeScriptHelper}",
    "description": "This service works as a helper to generate TypeScript binary commands.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 240,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 10,
    "ignore": true
  },
  {
    "__docId__": 241,
    "kind": "member",
    "name": "_bin",
    "memberof": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper",
    "static": false,
    "longname": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper#_bin",
    "access": "protected",
    "description": "The path of the TypeScript binary that will execute the commands.",
    "lineNumber": 17,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "getDeclarationsCommand",
    "memberof": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper#getDeclarationsCommand",
    "access": "public",
    "description": "Gets the command that generates the TypeScript declaration file(s) for a target.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target from which the method will take the input (source) and\n                       output (build) paths."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "_command",
    "memberof": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildTypeScriptHelper.js~BuildTypeScriptHelper#_command",
    "access": "protected",
    "description": "Helper method that just puts the Typescript binary path on front of a set of instructions.",
    "lineNumber": 41,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instructions",
        "description": "The instructions for the TypeScript binary."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 244,
    "kind": "variable",
    "name": "buildTypeScriptHelper",
    "memberof": "src/services/building/buildTypeScriptHelper.js",
    "static": true,
    "longname": "src/services/building/buildTypeScriptHelper.js~buildTypeScriptHelper",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildTypeScriptHelper.js",
    "importStyle": "{buildTypeScriptHelper}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildTypeScriptHelper` as the `buildTypeScriptHelper` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildTypeScriptHelper);\n// Getting access to the service instance\nconst buildTypeScriptHelper = container.get('buildTypeScriptHelper');"
    ],
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 245,
    "kind": "file",
    "name": "src/services/building/buildVersion.js",
    "content": "const { provider } = require('jimple');\n/**\n * This service uses the project configuration settings in order manage the project version.\n */\nclass BuildVersion {\n  /**\n   * Class constructor.\n   * @param {Events}                       events               To fire an event when the revision\n   *                                                            file is created.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the `version` settings.\n   * @param {VersionUtils}                 versionUtils         To load the version and write the\n   *                                                            revision file.\n   */\n  constructor(events, projectConfiguration, versionUtils) {\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `versionUtils` service.\n     * @type {VersionUtils}\n     */\n    this.versionUtils = versionUtils;\n  }\n  /**\n   * Look for the project version first on the revision file, then on the environment variable and\n   * finally fallbacks to `development` if none of the other could be found.\n   * @return {string}\n   */\n  getVersion() {\n    const { version } = this.projectConfiguration;\n    return this.versionUtils.getVersion(\n      version.revision.filename,\n      version.environmentVariable\n    );\n  }\n  /**\n   * Create the revision file.\n   * This method emits the `revision-file-created` event and sends the contents of the file as\n   * a argument.\n   * @param {boolean} [force=false] Force the service to create the file even if the feature\n   *                                is disabled.\n   * @return {Promise<string,Error>}\n   */\n  createRevision(force = false) {\n    const { version } = this.projectConfiguration;\n    const { revision } = version;\n    let result;\n    if (revision.enabled || force) {\n      result = this.versionUtils.createRevisionFile(\n        revision.filename,\n        version.environmentVariable\n      )\n      .then((savedVersion) => {\n        this.events.emit('revision-file-created', savedVersion);\n        return savedVersion;\n      });\n    } else {\n      const error = new Error('The revision feature is disabled on the project configuration');\n      result = Promise.reject(error);\n    }\n\n    return result;\n  }\n  /**\n   * Get the name of the variable where the build engine should define the version.\n   * @return {string}\n   */\n  getDefinitionVariable() {\n    return this.projectConfiguration.version.defineOn;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BuildVersion` as the `buildVersion` service.\n * @example\n * // Register it on the container\n * container.register(buildVersion);\n * // Getting access to the service instance\n * const buildVersion = container.get('buildVersion');\n * @type {Provider}\n */\nconst buildVersion = provider((app) => {\n  app.set('buildVersion', () => new BuildVersion(\n    app.get('events'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('versionUtils')\n  ));\n});\n\nmodule.exports = {\n  BuildVersion,\n  buildVersion,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/buildVersion.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 246,
    "kind": "class",
    "name": "BuildVersion",
    "memberof": "src/services/building/buildVersion.js",
    "static": true,
    "longname": "src/services/building/buildVersion.js~BuildVersion",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildVersion.js",
    "importStyle": "{BuildVersion}",
    "description": "This service uses the project configuration settings in order manage the project version.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 247,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To fire an event when the revision\n                                                           file is created."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the `version` settings."
      },
      {
        "nullable": null,
        "types": [
          "VersionUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "versionUtils",
        "description": "To load the version and write the\n                                                           revision file."
      }
    ]
  },
  {
    "__docId__": 248,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 250,
    "kind": "member",
    "name": "versionUtils",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#versionUtils",
    "access": "public",
    "description": "A local reference for the `versionUtils` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "VersionUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "getVersion",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#getVersion",
    "access": "public",
    "description": "Look for the project version first on the revision file, then on the environment variable and\nfinally fallbacks to `development` if none of the other could be found.",
    "lineNumber": 36,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "createRevision",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#createRevision",
    "access": "public",
    "description": "Create the revision file.\nThis method emits the `revision-file-created` event and sends the contents of the file as\na argument.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Force the service to create the file even if the feature\n                               is disabled."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "getDefinitionVariable",
    "memberof": "src/services/building/buildVersion.js~BuildVersion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/buildVersion.js~BuildVersion#getDefinitionVariable",
    "access": "public",
    "description": "Get the name of the variable where the build engine should define the version.",
    "lineNumber": 75,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "name": "buildVersion",
    "memberof": "src/services/building/buildVersion.js",
    "static": true,
    "longname": "src/services/building/buildVersion.js~buildVersion",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/buildVersion.js",
    "importStyle": "{buildVersion}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BuildVersion` as the `buildVersion` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(buildVersion);\n// Getting access to the service instance\nconst buildVersion = container.get('buildVersion');"
    ],
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 255,
    "kind": "file",
    "name": "src/services/building/builder.js",
    "content": "const { provider } = require('jimple');\n/**\n * This is the main _\"bridge service\"_ for building: It connects the rest of the building services\n * and perform most of the _\"building-related tasks\"_.\n */\nclass Builder {\n  /**\n   * Class constructor.\n   * @param {BuildCleaner}    buildCleaner    Used to clean a target builded files before building\n   *                                          again.\n   * @param {BuildCopier}     buildCopier     Used to copy a target files if it doesn't require\n   *                                          bundling.\n   * @param {BuildEngines}    buildEngines    To access the engines in charge of building targets.\n   * @param {buildTranspiler} buildTranspiler To transpile files of atarget that doesn't require\n   *                                          bundling.\n   * @param {Targets}         targets         To access targets information.\n   */\n  constructor(\n    buildCleaner,\n    buildCopier,\n    buildEngines,\n    buildTranspiler,\n    targets\n  ) {\n    /**\n     * A local reference for the `buildCleaner` service.\n     * @type {BuildCleaner}\n     */\n    this.buildCleaner = buildCleaner;\n    /**\n     * A local reference for the `buildCopier` service.\n     * @type {BuildCopier}\n     */\n    this.buildCopier = buildCopier;\n    /**\n     * A local reference for the `buildEngines` service.\n     * @type {BuildEngines}\n     */\n    this.buildEngines = buildEngines;\n    /**\n     * A local reference for the `buildTranspiler` service.\n     * @type {BuildTranspiler}\n     */\n    this.buildTranspiler = buildTranspiler;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n  }\n  /**\n   * Get a build command for a target. If the target doesn't require bundling, it will return an\n   * empty string, otherwise, it will ask the build engine the target uses for the required shell\n   * command.\n   * @param {Target}  target               The target information.\n   * @param {string}  buildType            The type of build intended: `production` or\n   *                                       `development`.\n   * @param {boolean} [forceRun=false]     Whether or not the build command should also run the\n   *                                       target. It's _\"forced\"_ because it overwrites the\n   *                                       `runOnDevelopment` setting.\n   * @param {boolean} [forceWatch=false]   Whether or not the target files should be watched and\n   *                                       the build recreated when they changed.\n   * @param {boolean} [forceInspect=false] Whether or not the Node inspector should be enabled.\n   *                                       Only valid for Node targets.\n   * @param {boolean} [forceAnalyze=false] Whether or not the target bundle should be analyzed.\n   * @return {string}\n   * @todo These parameters should be an object.\n   */\n  getTargetBuildCommand(\n    target,\n    buildType,\n    forceRun = false,\n    forceWatch = false,\n    forceInspect = false,\n    forceAnalyze = false\n  ) {\n    let command = '';\n    if (target.bundle !== false) {\n      const engine = this.buildEngines.getEngine(target.engine);\n      command = engine.getBuildCommand(\n        target,\n        buildType,\n        forceRun,\n        forceWatch,\n        forceInspect,\n        forceAnalyze\n      );\n    }\n\n    return command;\n  }\n  /**\n   * Copy a target files to the distribution directory. The only reason to copy a target files are:\n   * If the target needs to be transpiles or if the build type is `production`, on all the other\n   * cases the method won't do anything.\n   * @param {string} targetName The name of the target.\n   * @param {string} buildType  The type of build it's being made: `production` or `development`.\n   * @return {Promise<undefined,Error>}\n   */\n  copyTarget(targetName, buildType) {\n    const target = this.targets.getTarget(targetName);\n    let result;\n    if (\n      target.is.node &&\n      target.bundle === false &&\n      (buildType === 'production' || target.transpile)\n    ) {\n      result = this.buildCopier.copyTargetFiles(target);\n    } else {\n      result = Promise.resolve();\n    }\n\n    return result;\n  }\n  /**\n   * Transpile a target files **that have been previously copied** to the distribution directory.\n   * If the target is not a Node target or it doesn't require transpiling, this method won't do\n   * anything.\n   * @param {string} targetName The name of the target.\n   * @param {string} buildType  The type of build it's being made: `production` or `development`.\n   * @return {Promise<undefined,Error>}\n   */\n  transpileTarget(targetName, buildType) {\n    const target = this.targets.getTarget(targetName);\n    let result;\n    if (\n      target.is.node &&\n      target.bundle === false &&\n      target.transpile\n    ) {\n      result = this.buildTranspiler.transpileTargetFiles(target, buildType);\n    } else {\n      result = Promise.resolve();\n    }\n\n    return result;\n  }\n  /**\n   * Removes all previous builds/copies of a target from the distribution directory.\n   * @param {string|target} targetName The name of the target, or the target itself.\n   * @return {Promise<undefined,Error>}\n   */\n  cleanTarget(targetName) {\n    const target = typeof targetName === 'string' ?\n      this.targets.getTarget(targetName) :\n      targetName;\n\n    return this.buildCleaner.cleanTarget(target);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `Builder` as the `builder` service.\n * @example\n * // Register it on the container\n * container.register(builder);\n * // Getting access to the service instance\n * const builder = container.get('builder');\n * @type {Provider}\n */\nconst builder = provider((app) => {\n  app.set('builder', () => new Builder(\n    app.get('buildCleaner'),\n    app.get('buildCopier'),\n    app.get('buildEngines'),\n    app.get('buildTranspiler'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  Builder,\n  builder,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "class",
    "name": "Builder",
    "memberof": "src/services/building/builder.js",
    "static": true,
    "longname": "src/services/building/builder.js~Builder",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/builder.js",
    "importStyle": "{Builder}",
    "description": "This is the main _\"bridge service\"_ for building: It connects the rest of the building services\nand perform most of the _\"building-related tasks\"_.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 257,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/building/builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/builder.js~Builder#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildCleaner"
        ],
        "spread": false,
        "optional": false,
        "name": "buildCleaner",
        "description": "Used to clean a target builded files before building\n                                         again."
      },
      {
        "nullable": null,
        "types": [
          "BuildCopier"
        ],
        "spread": false,
        "optional": false,
        "name": "buildCopier",
        "description": "Used to copy a target files if it doesn't require\n                                         bundling."
      },
      {
        "nullable": null,
        "types": [
          "BuildEngines"
        ],
        "spread": false,
        "optional": false,
        "name": "buildEngines",
        "description": "To access the engines in charge of building targets."
      },
      {
        "nullable": null,
        "types": [
          "buildTranspiler"
        ],
        "spread": false,
        "optional": false,
        "name": "buildTranspiler",
        "description": "To transpile files of atarget that doesn't require\n                                         bundling."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To access targets information."
      }
    ]
  },
  {
    "__docId__": 258,
    "kind": "member",
    "name": "buildCleaner",
    "memberof": "src/services/building/builder.js~Builder",
    "static": false,
    "longname": "src/services/building/builder.js~Builder#buildCleaner",
    "access": "public",
    "description": "A local reference for the `buildCleaner` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "BuildCleaner"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "buildCopier",
    "memberof": "src/services/building/builder.js~Builder",
    "static": false,
    "longname": "src/services/building/builder.js~Builder#buildCopier",
    "access": "public",
    "description": "A local reference for the `buildCopier` service.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "BuildCopier"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 260,
    "kind": "member",
    "name": "buildEngines",
    "memberof": "src/services/building/builder.js~Builder",
    "static": false,
    "longname": "src/services/building/builder.js~Builder#buildEngines",
    "access": "public",
    "description": "A local reference for the `buildEngines` service.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "BuildEngines"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "buildTranspiler",
    "memberof": "src/services/building/builder.js~Builder",
    "static": false,
    "longname": "src/services/building/builder.js~Builder#buildTranspiler",
    "access": "public",
    "description": "A local reference for the `buildTranspiler` service.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "BuildTranspiler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 262,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/building/builder.js~Builder",
    "static": false,
    "longname": "src/services/building/builder.js~Builder#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "getTargetBuildCommand",
    "memberof": "src/services/building/builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/builder.js~Builder#getTargetBuildCommand",
    "access": "public",
    "description": "Get a build command for a target. If the target doesn't require bundling, it will return an\nempty string, otherwise, it will ask the build engine the target uses for the required shell\ncommand.",
    "lineNumber": 69,
    "todo": [
      "These parameters should be an object."
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "buildType",
        "description": "The type of build intended: `production` or\n                                      `development`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceRun",
        "description": "Whether or not the build command should also run the\n                                      target. It's _\"forced\"_ because it overwrites the\n                                      `runOnDevelopment` setting."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceWatch",
        "description": "Whether or not the target files should be watched and\n                                      the build recreated when they changed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceInspect",
        "description": "Whether or not the Node inspector should be enabled.\n                                      Only valid for Node targets."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceAnalyze",
        "description": "Whether or not the target bundle should be analyzed."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "copyTarget",
    "memberof": "src/services/building/builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/builder.js~Builder#copyTarget",
    "access": "public",
    "description": "Copy a target files to the distribution directory. The only reason to copy a target files are:\nIf the target needs to be transpiles or if the build type is `production`, on all the other\ncases the method won't do anything.",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetName",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "buildType",
        "description": "The type of build it's being made: `production` or `development`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "transpileTarget",
    "memberof": "src/services/building/builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/builder.js~Builder#transpileTarget",
    "access": "public",
    "description": "Transpile a target files **that have been previously copied** to the distribution directory.\nIf the target is not a Node target or it doesn't require transpiling, this method won't do\nanything.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "targetName",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "buildType",
        "description": "The type of build it's being made: `production` or `development`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "cleanTarget",
    "memberof": "src/services/building/builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/building/builder.js~Builder#cleanTarget",
    "access": "public",
    "description": "Removes all previous builds/copies of a target from the distribution directory.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "target"
        ],
        "spread": false,
        "optional": false,
        "name": "targetName",
        "description": "The name of the target, or the target itself."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 267,
    "kind": "variable",
    "name": "builder",
    "memberof": "src/services/building/builder.js",
    "static": true,
    "longname": "src/services/building/builder.js~builder",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/building/builder.js",
    "importStyle": "{builder}",
    "description": "The service provider that once registered on the app container will set an instance of\n`Builder` as the `builder` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(builder);\n// Getting access to the service instance\nconst builder = container.get('builder');"
    ],
    "lineNumber": 161,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "src/services/building/index.js",
    "content": "const { buildCleaner } = require('./buildCleaner');\nconst { buildCopier } = require('./buildCopier');\nconst { buildEngines } = require('./buildEngines');\nconst { buildNodeRunner } = require('./buildNodeRunner');\nconst { buildNodeRunnerProcess } = require('./buildNodeRunnerProcess');\nconst { buildNodeWatcher } = require('./buildNodeWatcher');\nconst { buildNodeWatcherProcess } = require('./buildNodeWatcherProcess');\nconst { buildTranspiler } = require('./buildTranspiler');\nconst { buildTypeScriptHelper } = require('./buildTypeScriptHelper');\nconst { buildVersion } = require('./buildVersion');\nconst { builder } = require('./builder');\n\nmodule.exports = {\n  buildCleaner,\n  buildCopier,\n  buildEngines,\n  buildNodeRunner,\n  buildNodeRunnerProcess,\n  buildNodeWatcher,\n  buildNodeWatcherProcess,\n  buildTranspiler,\n  buildTypeScriptHelper,\n  buildVersion,\n  builder,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/building/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "file",
    "name": "src/services/cli/cli.js",
    "content": "const commander = require('commander');\nconst { provider } = require('jimple');\n/**\n * The main CLI program interface where all the commands are registered and that works as a bridge\n * between the app and `commander`.\n */\nclass CLI {\n  /**\n   * Class constructor.\n   * @param {Object} info      This app `package.json` information.\n   * @param {string} [name=''] The name of the program. If not specified, it will use the one on\n   *                           `info` object.\n   */\n  constructor(info, name = '') {\n    /**\n     * This app `package.json` information.\n     * @type {Object}\n     */\n    this.info = info;\n    /**\n     * The name of the CLI program.\n     * @type {string}\n     */\n    this.name = name || this.info.name;\n  }\n  /**\n   * Start the interface with a list of commands.\n   * @param {Array<CLICommand>} commands A list of commands to register.\n   */\n  start(commands) {\n    // Set the name, version and the description of the program.\n    commander.name(this.name);\n    commander.version(this.info.version, '-v, --version');\n    commander.description(this.info.description);\n    // Loop all the commands and register them.\n    commands.forEach((command) => {\n      command.register(commander, this);\n    });\n    // Tell commander to parse the arguments.\n    commander.parse(process.argv);\n  }\n}\n/**\n * Generates a `Provider` with an already defined name for the program.\n * @example\n * // Generate the provider\n * const provider = cliWithName('my-program');\n * // Register it on the container\n * container.register(provider);\n * // Getting access to the service instance\n * const cli = container.get('cli');\n * @param {string} name The name of the program.\n * @return {Provider}\n */\nconst cliWithName = (name) => provider((app) => {\n  app.set('cli', () => new CLI(\n    app.get('info'),\n    name\n  ));\n});\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLI` as the `cli` service.\n * @example\n * // Register it on the container\n * container.register(cli);\n * // Getting access to the service instance\n * const cli = container.get('cli');\n * @type {Provider}\n */\nconst cli = cliWithName();\n\nmodule.exports = {\n  CLI,\n  cliWithName,\n  cli,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cli.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 270,
    "kind": "class",
    "name": "CLI",
    "memberof": "src/services/cli/cli.js",
    "static": true,
    "longname": "src/services/cli/cli.js~CLI",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cli.js",
    "importStyle": "{CLI}",
    "description": "The main CLI program interface where all the commands are registered and that works as a bridge\nbetween the app and `commander`.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 271,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cli.js~CLI",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cli.js~CLI#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "This app `package.json` information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "name",
        "description": "The name of the program. If not specified, it will use the one on\n                          `info` object."
      }
    ]
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "info",
    "memberof": "src/services/cli/cli.js~CLI",
    "static": false,
    "longname": "src/services/cli/cli.js~CLI#info",
    "access": "public",
    "description": "This app `package.json` information.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "name",
    "memberof": "src/services/cli/cli.js~CLI",
    "static": false,
    "longname": "src/services/cli/cli.js~CLI#name",
    "access": "public",
    "description": "The name of the CLI program.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "start",
    "memberof": "src/services/cli/cli.js~CLI",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cli.js~CLI#start",
    "access": "public",
    "description": "Start the interface with a list of commands.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<CLICommand>"
        ],
        "spread": false,
        "optional": false,
        "name": "commands",
        "description": "A list of commands to register."
      }
    ],
    "return": null
  },
  {
    "__docId__": 275,
    "kind": "function",
    "name": "cliWithName",
    "memberof": "src/services/cli/cli.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/cli/cli.js~cliWithName",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cli.js",
    "importStyle": "{cliWithName}",
    "description": "Generates a `Provider` with an already defined name for the program.",
    "examples": [
      "// Generate the provider\nconst provider = cliWithName('my-program');\n// Register it on the container\ncontainer.register(provider);\n// Getting access to the service instance\nconst cli = container.get('cli');"
    ],
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the program."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 276,
    "kind": "variable",
    "name": "cli",
    "memberof": "src/services/cli/cli.js",
    "static": true,
    "longname": "src/services/cli/cli.js~cli",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cli.js",
    "importStyle": "{cli}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLI` as the `cli` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cli);\n// Getting access to the service instance\nconst cli = container.get('cli');"
    ],
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 277,
    "kind": "file",
    "name": "src/services/cli/cliAnalyze.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a fake command the app uses to show the information of the analyze task. In reality,\n * this command is handled by a shell script.\n * @extends {CLICommand}\n */\nclass CLIAnalyzeCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @ignore\n   */\n  constructor() {\n    super();\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'analyze [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Build a target that can be bundled and open the bundle analyzer';\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIAnalyzeCommand` as the `cliAnalyzeCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliAnalyzeCommand);\n * // Getting access to the service instance\n * const cliAnalyzeCommand = container.get('cliAnalyzeCommand');\n * @type {Provider}\n */\nconst cliAnalyzeCommand = provider((app) => {\n  app.set('cliAnalyzeCommand', () => new CLIAnalyzeCommand());\n});\n\nmodule.exports = {\n  CLIAnalyzeCommand,\n  cliAnalyzeCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliAnalyze.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 278,
    "kind": "class",
    "name": "CLIAnalyzeCommand",
    "memberof": "src/services/cli/cliAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliAnalyze.js",
    "importStyle": "{CLIAnalyzeCommand}",
    "description": "This is a fake command the app uses to show the information of the analyze task. In reality,\nthis command is handled by a shell script.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 279,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "ignore": true
  },
  {
    "__docId__": 280,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliAnalyze.js~CLIAnalyzeCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "cliAnalyzeCommand",
    "memberof": "src/services/cli/cliAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliAnalyze.js~cliAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliAnalyze.js",
    "importStyle": "{cliAnalyzeCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIAnalyzeCommand` as the `cliAnalyzeCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliAnalyzeCommand);\n// Getting access to the service instance\nconst cliAnalyzeCommand = container.get('cliAnalyzeCommand');"
    ],
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 284,
    "kind": "file",
    "name": "src/services/cli/cliBuild.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a fake command the app uses to show the information of the build task. In reality, this\n * command is handled by a shell script.\n * @extends {CLICommand}\n */\nclass CLIBuildCommand extends CLICommand {\n  /**\n   * Class constructor.\n   */\n  constructor() {\n    super();\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'build [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Build a target';\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n    this.addOption(\n      'run',\n      '-r, --run',\n      'Run the target after the build is completed. It only works when the ' +\n        'build type is development',\n      false\n    );\n    this.addOption(\n      'watch',\n      '-w, --watch',\n      'Rebuild the target every time one of its files changes. It only works ' +\n        'when the build type is development',\n      false\n    );\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector. It only works with Node targets',\n      false\n    );\n    this.addOption(\n      'analyze',\n      '-a, --analyze',\n      'Enables the bundle analyzer. It only works with targets with bundling',\n      false\n    );\n    /**\n     * Enable unknown options so other services can customize the build command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIBuildCommand` as the `cliBuildCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliBuildCommand);\n * // Getting access to the service instance\n * const cliBuildCommand = container.get('cliBuildCommand');\n * @type {Provider}\n */\nconst cliBuildCommand = provider((app) => {\n  app.set('cliBuildCommand', () => new CLIBuildCommand());\n});\n\nmodule.exports = {\n  CLIBuildCommand,\n  cliBuildCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliBuild.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 285,
    "kind": "class",
    "name": "CLIBuildCommand",
    "memberof": "src/services/cli/cliBuild.js",
    "static": true,
    "longname": "src/services/cli/cliBuild.js~CLIBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliBuild.js",
    "importStyle": "{CLIBuildCommand}",
    "description": "This is a fake command the app uses to show the information of the build task. In reality, this\ncommand is handled by a shell script.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 286,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliBuild.js~CLIBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliBuild.js~CLIBuildCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12
  },
  {
    "__docId__": 287,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliBuild.js~CLIBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliBuild.js~CLIBuildCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 288,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliBuild.js~CLIBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliBuild.js~CLIBuildCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 289,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliBuild.js~CLIBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliBuild.js~CLIBuildCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the build command.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 290,
    "kind": "variable",
    "name": "cliBuildCommand",
    "memberof": "src/services/cli/cliBuild.js",
    "static": true,
    "longname": "src/services/cli/cliBuild.js~cliBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliBuild.js",
    "importStyle": "{cliBuildCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIBuildCommand` as the `cliBuildCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliBuildCommand);\n// Getting access to the service instance\nconst cliBuildCommand = container.get('cliBuildCommand');"
    ],
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 291,
    "kind": "file",
    "name": "src/services/cli/cliClean.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the command used on the CLI interface to remove a target file(s) or the entire\n * distribution directory.\n * @extends {CLICommand}\n */\nclass CLICleanCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Builder}      builder      Needed to remove a target files.\n   * @param {BuildCleaner} buildCleaner Needed to remove the distribution directory.\n   * @param {Targets}      targets      To get the default target in case none is specified.\n   */\n  constructor(builder, buildCleaner, targets) {\n    super();\n    /**\n     * A local reference for the `builder` service function.\n     * @type {Builder}\n     */\n    this.builder = builder;\n    /**\n     * A local reference for the `buildCleaner` service function.\n     * @type {BuildCleaner}\n     */\n    this.buildCleaner = buildCleaner;\n    /**\n     * A local reference for the `targets` service function.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'clean [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Delete builded files from the distribution directory';\n    this.addOption(\n      'all',\n      '-a, --all',\n      'Delete the entire distribution directory',\n      false\n    );\n  }\n  /**\n   * Handle the execution of the command.\n   * @param {?string} name        The name of the target that will be removed from the distribution\n   *                              directory. If none is specified, it will fallback to the default\n   *                              target.\n   * @param {Command} command     The executed command (sent by `commander`).\n   * @param {Object}  options     The commands options.\n   * @param {boolean} options.all If this is `true`, instead of just removing the target files, the\n   *                              entire distribution directory will be deleted.\n   * @return {Promise<undefined,Error>}\n   */\n  handle(name, command, options) {\n    // Define the variable that will hold the return Promise.\n    let result;\n    // If the `all` flag was used...\n    if (options.all) {\n      // ...then remove the entire distribution directory.\n      result = this.buildCleaner.cleanAll();\n    } else {\n      // ...otherwise, check if a target name was specified, or fallback to the default target.\n      const target = name || this.targets.getDefaultTarget();\n      // Set the method to remove the targets files as return Promise.\n      result = this.builder.cleanTarget(target);\n    }\n\n    // Return the Promise for whichever clean method was used.\n    return result;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLICleanCommand` as the `cliCleanCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliCleanCommand);\n * // Getting access to the service instance\n * const cliCleanCommand = container.get('cliCleanCommand');\n * @type {Provider}\n */\nconst cliCleanCommand = provider((app) => {\n  app.set('cliCleanCommand', () => new CLICleanCommand(\n    app.get('builder'),\n    app.get('buildCleaner'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLICleanCommand,\n  cliCleanCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliClean.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 292,
    "kind": "class",
    "name": "CLICleanCommand",
    "memberof": "src/services/cli/cliClean.js",
    "static": true,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliClean.js",
    "importStyle": "{CLICleanCommand}",
    "description": "This is the command used on the CLI interface to remove a target file(s) or the entire\ndistribution directory.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 293,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Builder"
        ],
        "spread": false,
        "optional": false,
        "name": "builder",
        "description": "Needed to remove a target files."
      },
      {
        "nullable": null,
        "types": [
          "BuildCleaner"
        ],
        "spread": false,
        "optional": false,
        "name": "buildCleaner",
        "description": "Needed to remove the distribution directory."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the default target in case none is specified."
      }
    ]
  },
  {
    "__docId__": 294,
    "kind": "member",
    "name": "builder",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#builder",
    "access": "public",
    "description": "A local reference for the `builder` service function.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Builder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "buildCleaner",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#buildCleaner",
    "access": "public",
    "description": "A local reference for the `buildCleaner` service function.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "BuildCleaner"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service function.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 297,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliClean.js~CLICleanCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliClean.js~CLICleanCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target that will be removed from the distribution\n                             directory. If none is specified, it will fallback to the default\n                             target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The commands options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "options.all",
        "description": "If this is `true`, instead of just removing the target files, the\n                             entire distribution directory will be deleted."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "cliCleanCommand",
    "memberof": "src/services/cli/cliClean.js",
    "static": true,
    "longname": "src/services/cli/cliClean.js~cliCleanCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliClean.js",
    "importStyle": "{cliCleanCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLICleanCommand` as the `cliCleanCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliCleanCommand);\n// Getting access to the service instance\nconst cliCleanCommand = container.get('cliCleanCommand');"
    ],
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 301,
    "kind": "file",
    "name": "src/services/cli/cliCopyProjectFiles.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the command used on the CLI interface to copy the project files to the distribution\n * directory.\n * @extends {CLICommand}\n */\nclass CLICopyProjectFilesCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {BuildCopier} buildCopier Used to copy the files.\n   */\n  constructor(buildCopier) {\n    super();\n    /**\n     * A local reference for the `buildCopier` service function.\n     * @type {BuildCopier}\n     */\n    this.buildCopier = buildCopier;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'copy-project-files';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Copy the required project files into the build directory';\n  }\n  /**\n   * Handle the execution of the command and copies the project files to the distribution directory.\n   * @return {Promise<undefined,Error>}\n   */\n  handle() {\n    return this.buildCopier.copyFiles();\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLICopyProjectFilesCommand` as the `cliCopyProjectFilesCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliCopyProjectFilesCommand);\n * // Getting access to the service instance\n * const cliCopyProjectFilesCommand = container.get('cliCopyProjectFilesCommand');\n * @type {Provider}\n */\nconst cliCopyProjectFilesCommand = provider((app) => {\n  app.set('cliCopyProjectFilesCommand', () => new CLICopyProjectFilesCommand(\n    app.get('buildCopier')\n  ));\n});\n\nmodule.exports = {\n  CLICopyProjectFilesCommand,\n  cliCopyProjectFilesCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliCopyProjectFiles.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 302,
    "kind": "class",
    "name": "CLICopyProjectFilesCommand",
    "memberof": "src/services/cli/cliCopyProjectFiles.js",
    "static": true,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliCopyProjectFiles.js",
    "importStyle": "{CLICopyProjectFilesCommand}",
    "description": "This is the command used on the CLI interface to copy the project files to the distribution\ndirectory.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 303,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildCopier"
        ],
        "spread": false,
        "optional": false,
        "name": "buildCopier",
        "description": "Used to copy the files."
      }
    ]
  },
  {
    "__docId__": 304,
    "kind": "member",
    "name": "buildCopier",
    "memberof": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "static": false,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand#buildCopier",
    "access": "public",
    "description": "A local reference for the `buildCopier` service function.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "BuildCopier"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "static": false,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 306,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "static": false,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliCopyProjectFiles.js~CLICopyProjectFilesCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and copies the project files to the distribution directory.",
    "lineNumber": 35,
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 308,
    "kind": "variable",
    "name": "cliCopyProjectFilesCommand",
    "memberof": "src/services/cli/cliCopyProjectFiles.js",
    "static": true,
    "longname": "src/services/cli/cliCopyProjectFiles.js~cliCopyProjectFilesCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliCopyProjectFiles.js",
    "importStyle": "{cliCopyProjectFilesCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLICopyProjectFilesCommand` as the `cliCopyProjectFilesCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliCopyProjectFilesCommand);\n// Getting access to the service instance\nconst cliCopyProjectFilesCommand = container.get('cliCopyProjectFilesCommand');"
    ],
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 309,
    "kind": "file",
    "name": "src/services/cli/cliGenerate.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This commands allows the user to generate new projext resources by makeing use of _\"generators\"_,\n * which are subclasses of {@link CLISubCommand}.\n * @extends {CLICommand}\n */\nclass CLIGenerateCommand extends CLICommand {\n  /**\n   * Class constructor.\n   */\n  constructor() {\n    super();\n    /**\n     * A dictionary of the resource generators this command uses. The generators are added by using\n     * the `addGenerators` method and they key used to save them is their `resource` property.\n     * @type {Object}\n     */\n    this.generators = {};\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'generate [resource]';\n    /**\n     * A description of the command for the help interface. Take note that this command also has\n     * a `fullDescription` property, but it's generated every time `addGenerators` gets called so\n     * the detailed description can include the generators information.\n     * @type {string}\n     */\n    this.description = 'Generate a projext resource. Use the --help flag on this command ' +\n      'for more information';\n    /**\n     * Enable unknown options in order to pick the generator options.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Add the list of generators this command can use. After saving the reference to the services,\n   * this method will also update the `fullDescription` property with the generators information.\n   * @param {Array} generators A list of {@link CLISubCommand} services.\n   */\n  addGenerators(generators) {\n    // Register the generators on the local property.\n    generators.forEach((generator) => {\n      this.generators[generator.name] = generator;\n    });\n    // Set an empty description.\n    let descriptionList = '';\n    // Loop all the registered generators and add their help information to the description.\n    const resources = Object.keys(this.generators);\n    const lastResource = resources.length - 1;\n    resources.forEach((resource, index) => {\n      descriptionList += this.generators[resource].getHelpInformation();\n      if (index !== lastResource) {\n        descriptionList += '\\n\\n';\n      }\n    });\n    /**\n     * Update the detailed description of the command.\n     * @ignore\n     */\n    this.fullDescription = `Generate a projext resource:\\n\\n${descriptionList}`;\n  }\n  /**\n   * Handle the execution of the command and triggers the selected generator.\n   * @param {?string} resource       The name of the resource that needs to be generated. It needs\n   *                                 to match with the a generator key on the `generators`\n   *                                 dictionary.\n   * @param {Command} command        The executed command (sent by `commander`).\n   * @param {Object}  options        The command known options.\n   * @param {Object}  unknownOptions A dictionary of received unkown options. this method will\n   *                                 parse them and send them to the selected generator.\n   * @return {Promise<undefined,Error>}\n   */\n  handle(resource, command, options, unknownOptions) {\n    let result;\n    if (!resource || !this.generators[resource]) {\n      result = Promise.reject(new Error('Invalid resource type'));\n    } else {\n      const generator = this.generators[resource];\n      const generatorOptions = this._parseGeneratorOptions(generator, unknownOptions);\n      result = generator.handle(generatorOptions);\n    }\n\n    return result;\n  }\n  /**\n   * This method is called when the command is executed and it takes care of parse and match the\n   * received unkown options with the selected generator options, so they can be sent to the\n   * generator.\n   * @param {CLISubCommand} generator The generator from which options will be matched.\n   * @param {Object}        options   A dictionary of unkown options the command received.\n   * @return {Object}\n   * @ignore\n   * @access protected\n   */\n  _parseGeneratorOptions(generator, options) {\n    const generatorOptions = {};\n    const parameterRegex = /\\[[\\w-]+\\]/g;\n    const headerRegex = /^-(?:-)?/;\n    generator.options.forEach((optionName) => {\n      const option = generator.optionsByName[optionName];\n      if (typeof option.defaultValue !== 'undefined') {\n        generatorOptions[optionName] = option.defaultValue;\n      }\n\n      const headersStr = option.instruction.replace(parameterRegex, '').trim();\n      headersStr\n      .split(',')\n      .map((header) => header.replace(headerRegex, '').trim())\n      .some((header) => {\n        let result = false;\n        if (typeof options[header] !== 'undefined') {\n          generatorOptions[optionName] = options[header];\n          result = true;\n        }\n\n        return result;\n      });\n    });\n\n    return generatorOptions;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIGenerateCommand` as the `cliGenerateCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliGenerateCommand);\n * // Getting access to the service instance\n * const cliGenerateCommand = container.get('cliGenerateCommand');\n * @type {Provider}\n */\nconst cliGenerateCommand = provider((app) => {\n  app.set('cliGenerateCommand', () => new CLIGenerateCommand());\n});\n\nmodule.exports = {\n  CLIGenerateCommand,\n  cliGenerateCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliGenerate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 310,
    "kind": "class",
    "name": "CLIGenerateCommand",
    "memberof": "src/services/cli/cliGenerate.js",
    "static": true,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliGenerate.js",
    "importStyle": "{CLIGenerateCommand}",
    "description": "This commands allows the user to generate new projext resources by makeing use of _\"generators\"_,\nwhich are subclasses of {@link CLISubCommand}.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 311,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "generators",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#generators",
    "access": "public",
    "description": "A dictionary of the resource generators this command uses. The generators are added by using\nthe `addGenerators` method and they key used to save them is their `resource` property.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 313,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface. Take note that this command also has\na `fullDescription` property, but it's generated every time `addGenerators` gets called so\nthe detailed description can include the generators information.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 315,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options in order to pick the generator options.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "addGenerators",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#addGenerators",
    "access": "public",
    "description": "Add the list of generators this command can use. After saving the reference to the services,\nthis method will also update the `fullDescription` property with the generators information.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "generators",
        "description": "A list of {@link CLISubCommand} services."
      }
    ],
    "return": null
  },
  {
    "__docId__": 317,
    "kind": "member",
    "name": "fullDescription",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#fullDescription",
    "access": "public",
    "description": "Update the detailed description of the command.",
    "lineNumber": 64,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and triggers the selected generator.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resource",
        "description": "The name of the resource that needs to be generated. It needs\n                                to match with the a generator key on the `generators`\n                                dictionary."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command known options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of received unkown options. this method will\n                                parse them and send them to the selected generator."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "_parseGeneratorOptions",
    "memberof": "src/services/cli/cliGenerate.js~CLIGenerateCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliGenerate.js~CLIGenerateCommand#_parseGeneratorOptions",
    "access": "protected",
    "description": "This method is called when the command is executed and it takes care of parse and match the\nreceived unkown options with the selected generator options, so they can be sent to the\ngenerator.",
    "lineNumber": 99,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLISubCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "generator",
        "description": "The generator from which options will be matched."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "A dictionary of unkown options the command received."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 320,
    "kind": "variable",
    "name": "cliGenerateCommand",
    "memberof": "src/services/cli/cliGenerate.js",
    "static": true,
    "longname": "src/services/cli/cliGenerate.js~cliGenerateCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliGenerate.js",
    "importStyle": "{cliGenerateCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIGenerateCommand` as the `cliGenerateCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliGenerateCommand);\n// Getting access to the service instance\nconst cliGenerateCommand = container.get('cliGenerateCommand');"
    ],
    "lineNumber": 137,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 321,
    "kind": "file",
    "name": "src/services/cli/cliInfo.js",
    "content": "const util = require('util');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the command used on the CLI to show the contents of the project configuration.\n * @extends {CLICommand}\n */\nclass CLIInfoCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Logger}                       appLogger            To log the configuration on the\n   *                                                            console.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the configuration.\n   */\n  constructor(appLogger, projectConfiguration) {\n    super();\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'info [path]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Show the contents of the project configuration. ' +\n      'You can use a directory-like (/) path to see specific settings';\n  }\n  /**\n   * Handle the execution of the command and shows the project configuration.\n   * @param {?string} path The path to specific settings.\n   */\n  handle(path) {\n    let title;\n    let settings;\n    // If a path has been specified...\n    if (path) {\n      // ...use the `utils` service to get the settings on that path.\n      title = `Showing '${path}'`;\n      settings = ObjectUtils.get(this.projectConfiguration, path, '/', true);\n    } else {\n      // ...otherwise, show everything.\n      title = 'Showing all the project settings';\n      settings = this.projectConfiguration;\n    }\n    // Inform the user of what's going to be shown.\n    this.appLogger.success(title);\n    // Log the selected settings.\n    this.output(util.inspect(settings, {\n      colors: true,\n      depth: 7,\n    }));\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIInfoCommand` as the `cliInfoCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliInfoCommand);\n * // Getting access to the service instance\n * const cliInfoCommand = container.get('cliInfoCommand');\n * @type {Provider}\n */\nconst cliInfoCommand = provider((app) => {\n  app.set('cliInfoCommand', () => new CLIInfoCommand(\n    app.get('appLogger'),\n    app.get('projectConfiguration').getConfig()\n  ));\n});\n\nmodule.exports = {\n  CLIInfoCommand,\n  cliInfoCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliInfo.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 322,
    "kind": "class",
    "name": "CLIInfoCommand",
    "memberof": "src/services/cli/cliInfo.js",
    "static": true,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliInfo.js",
    "importStyle": "{CLIInfoCommand}",
    "description": "This is the command used on the CLI to show the contents of the project configuration.",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 323,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To log the configuration on the\n                                                           console."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the configuration."
      }
    ]
  },
  {
    "__docId__": 324,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 325,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 326,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 327,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliInfo.js~CLIInfoCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliInfo.js~CLIInfoCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and shows the project configuration.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to specific settings."
      }
    ],
    "return": null
  },
  {
    "__docId__": 329,
    "kind": "variable",
    "name": "cliInfoCommand",
    "memberof": "src/services/cli/cliInfo.js",
    "static": true,
    "longname": "src/services/cli/cliInfo.js~cliInfoCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliInfo.js",
    "importStyle": "{cliInfoCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIInfoCommand` as the `cliInfoCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliInfoCommand);\n// Getting access to the service instance\nconst cliInfoCommand = container.get('cliInfoCommand');"
    ],
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 330,
    "kind": "file",
    "name": "src/services/cli/cliInspect.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a fake command the app uses to show the information of the inspect task. In reality,\n * this command is handled by a shell script.\n * @extends {CLICommand}\n */\nclass CLIInspectCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @ignore\n   */\n  constructor() {\n    super();\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'inspect [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Run a Node target on a development build type and enable the inspector';\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIInspectCommand` as the `cliInspectCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliInspectCommand);\n * // Getting access to the service instance\n * const cliInspectCommand = container.get('cliInspectCommand');\n * @type {Provider}\n */\nconst cliInspectCommand = provider((app) => {\n  app.set('cliInspectCommand', () => new CLIInspectCommand());\n});\n\nmodule.exports = {\n  CLIInspectCommand,\n  cliInspectCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliInspect.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 331,
    "kind": "class",
    "name": "CLIInspectCommand",
    "memberof": "src/services/cli/cliInspect.js",
    "static": true,
    "longname": "src/services/cli/cliInspect.js~CLIInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliInspect.js",
    "importStyle": "{CLIInspectCommand}",
    "description": "This is a fake command the app uses to show the information of the inspect task. In reality,\nthis command is handled by a shell script.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 332,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliInspect.js~CLIInspectCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliInspect.js~CLIInspectCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "ignore": true
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliInspect.js~CLIInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliInspect.js~CLIInspectCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliInspect.js~CLIInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliInspect.js~CLIInspectCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 335,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliInspect.js~CLIInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliInspect.js~CLIInspectCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "cliInspectCommand",
    "memberof": "src/services/cli/cliInspect.js",
    "static": true,
    "longname": "src/services/cli/cliInspect.js~cliInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliInspect.js",
    "importStyle": "{cliInspectCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIInspectCommand` as the `cliInspectCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliInspectCommand);\n// Getting access to the service instance\nconst cliInspectCommand = container.get('cliInspectCommand');"
    ],
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 337,
    "kind": "file",
    "name": "src/services/cli/cliRevision.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the command used on the CLI interface to create the revision file.\n * @extends {CLICommand}\n */\nclass CLIRevisionCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {BuildVersion} buildVersion To call the method that writes the revision file.\n   */\n  constructor(buildVersion) {\n    super();\n    /**\n     * A local reference for the `buildVersion` service function.\n     * @type {BuildVersion}\n     */\n    this.buildVersion = buildVersion;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'create-revision';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Create the revision file with the project version';\n  }\n  /**\n   * Handles the execution of the command and creates the file.\n   * @return {Promise<string,Error>}\n   */\n  handle() {\n    return this.buildVersion.createRevision();\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIRevisionCommand` as the `cliRevisionCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliRevisionCommand);\n * // Getting access to the service instance\n * const cliRevisionCommand = container.get('cliRevisionCommand');\n * @type {Provider}\n */\nconst cliRevisionCommand = provider((app) => {\n  app.set('cliRevisionCommand', () => new CLIRevisionCommand(\n    app.get('buildVersion')\n  ));\n});\n\nmodule.exports = {\n  CLIRevisionCommand,\n  cliRevisionCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliRevision.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 338,
    "kind": "class",
    "name": "CLIRevisionCommand",
    "memberof": "src/services/cli/cliRevision.js",
    "static": true,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliRevision.js",
    "importStyle": "{CLIRevisionCommand}",
    "description": "This is the command used on the CLI interface to create the revision file.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 339,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildVersion"
        ],
        "spread": false,
        "optional": false,
        "name": "buildVersion",
        "description": "To call the method that writes the revision file."
      }
    ]
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "buildVersion",
    "memberof": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "static": false,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand#buildVersion",
    "access": "public",
    "description": "A local reference for the `buildVersion` service function.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "BuildVersion"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "static": false,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 342,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "static": false,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliRevision.js~CLIRevisionCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliRevision.js~CLIRevisionCommand#handle",
    "access": "public",
    "description": "Handles the execution of the command and creates the file.",
    "lineNumber": 34,
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 344,
    "kind": "variable",
    "name": "cliRevisionCommand",
    "memberof": "src/services/cli/cliRevision.js",
    "static": true,
    "longname": "src/services/cli/cliRevision.js~cliRevisionCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliRevision.js",
    "importStyle": "{cliRevisionCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIRevisionCommand` as the `cliRevisionCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliRevisionCommand);\n// Getting access to the service instance\nconst cliRevisionCommand = container.get('cliRevisionCommand');"
    ],
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 345,
    "kind": "file",
    "name": "src/services/cli/cliRun.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a fake command the app uses to show the information of the run task. In reality, this\n * command is handled by a shell script.\n * @extends {CLICommand}\n */\nclass CLIRunCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @ignore\n   */\n  constructor() {\n    super();\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'run [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Run a target on a development build type';\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector. It only works with Node targets',\n      false\n    );\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIRunCommand` as the `cliRunCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliRunCommand);\n * // Getting access to the service instance\n * const cliRunCommand = container.get('cliRunCommand');\n * @type {Provider}\n */\nconst cliRunCommand = provider((app) => {\n  app.set('cliRunCommand', () => new CLIRunCommand());\n});\n\nmodule.exports = {\n  CLIRunCommand,\n  cliRunCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliRun.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 346,
    "kind": "class",
    "name": "CLIRunCommand",
    "memberof": "src/services/cli/cliRun.js",
    "static": true,
    "longname": "src/services/cli/cliRun.js~CLIRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliRun.js",
    "importStyle": "{CLIRunCommand}",
    "description": "This is a fake command the app uses to show the information of the run task. In reality, this\ncommand is handled by a shell script.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 347,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliRun.js~CLIRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliRun.js~CLIRunCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "ignore": true
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliRun.js~CLIRunCommand",
    "static": false,
    "longname": "src/services/cli/cliRun.js~CLIRunCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliRun.js~CLIRunCommand",
    "static": false,
    "longname": "src/services/cli/cliRun.js~CLIRunCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliRun.js~CLIRunCommand",
    "static": false,
    "longname": "src/services/cli/cliRun.js~CLIRunCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "name": "cliRunCommand",
    "memberof": "src/services/cli/cliRun.js",
    "static": true,
    "longname": "src/services/cli/cliRun.js~cliRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliRun.js",
    "importStyle": "{cliRunCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIRunCommand` as the `cliRunCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliRunCommand);\n// Getting access to the service instance\nconst cliRunCommand = container.get('cliRunCommand');"
    ],
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 352,
    "kind": "file",
    "name": "src/services/cli/cliSHAnalyze.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the _'real analyze command'_. This is a private command the shell script executes in\n * order to get a list of commands it should execute.\n * @extends {CLICommand}\n */\nclass CLISHAnalyzeCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {CLIBuildCommand} cliBuildCommand The analyze command is actually an alias for the\n   *                                          build command with the `--analyze` flag set to true.\n   * @param {Targets}         targets         To get the name of the default target if no other is\n   *                                          specified.\n   */\n  constructor(cliBuildCommand, targets) {\n    super();\n    /**\n     * A local reference for the `cliBuildCommand` service.\n     * @type {CLIBuildCommand}\n     */\n    this.cliBuildCommand = cliBuildCommand;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-analyze [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Get the build commands for the shell program to execute';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n  }\n  /**\n   * Handle the execution of the command and outputs the list of commands to run.\n   * @param {?string} name The name of the target.\n   * @param {Command} command        The executed command (sent by `commander`).\n   * @param {Object}  options        The command options.\n   * @param {string}  options.type   The type of build.\n   * @param {Object}  unknownOptions A dictionary of extra options that command may have received.\n   */\n  handle(name, command, options, unknownOptions) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    this.output(this.cliBuildCommand.generate(Object.assign(\n      {},\n      unknownOptions,\n      {\n        target: target.name,\n        type: options.type,\n        analyze: true,\n      }\n    )));\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHAnalyzeCommand` as the `cliSHAnalyzeCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHAnalyzeCommand);\n * // Getting access to the service instance\n * const cliSHAnalyzeCommand = container.get('cliSHAnalyzeCommand');\n * @type {Provider}\n */\nconst cliSHAnalyzeCommand = provider((app) => {\n  app.set('cliSHAnalyzeCommand', () => new CLISHAnalyzeCommand(\n    app.get('cliBuildCommand'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHAnalyzeCommand,\n  cliSHAnalyzeCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHAnalyze.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 353,
    "kind": "class",
    "name": "CLISHAnalyzeCommand",
    "memberof": "src/services/cli/cliSHAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHAnalyze.js",
    "importStyle": "{CLISHAnalyzeCommand}",
    "description": "This is the _'real analyze command'_. This is a private command the shell script executes in\norder to get a list of commands it should execute.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 354,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliBuildCommand",
        "description": "The analyze command is actually an alias for the\n                                         build command with the `--analyze` flag set to true."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the name of the default target if no other is\n                                         specified."
      }
    ]
  },
  {
    "__docId__": 355,
    "kind": "member",
    "name": "cliBuildCommand",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#cliBuildCommand",
    "access": "public",
    "description": "A local reference for the `cliBuildCommand` service.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "CLIBuildCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 361,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHAnalyze.js~CLISHAnalyzeCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and outputs the list of commands to run.",
    "lineNumber": 64,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.type",
        "description": "The type of build."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of extra options that command may have received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 362,
    "kind": "variable",
    "name": "cliSHAnalyzeCommand",
    "memberof": "src/services/cli/cliSHAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliSHAnalyze.js~cliSHAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHAnalyze.js",
    "importStyle": "{cliSHAnalyzeCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHAnalyzeCommand` as the `cliSHAnalyzeCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHAnalyzeCommand);\n// Getting access to the service instance\nconst cliSHAnalyzeCommand = container.get('cliSHAnalyzeCommand');"
    ],
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 363,
    "kind": "file",
    "name": "src/services/cli/cliSHBuild.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the _'real build command'_. This is a private command the shell script executes in order\n * to get a list of commands to run.\n * @extends {CLICommand}\n * @todo This whole class needs a refactor (args and params are the same!).\n */\nclass CLISHBuildCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Builder}                      builder                    Needed to generate a target\n   *                                                                  build command.\n   * @param {CLICleanCommand}              cliCleanCommand            Needed to generate the command\n   *                                                                  that cleans a target files.\n   * @param {CLICopyProjectFilesCommand}   cliCopyProjectFilesCommand Needed to generate the command\n   *                                                                  to copy the project files if\n   *                                                                  the feature of copying on\n   *                                                                  build is enabled.\n   * @param {CLIRevisionCommand}           cliRevisionCommand         Needed to generate the command\n   *                                                                  that creates the revision file\n   *                                                                  if the feature of generating\n   *                                                                  it on build is enabled.\n   * @param {CLISHCopyCommand}             cliSHCopyCommand           Needed to generate the command\n   *                                                                  to copy the target files if\n   *                                                                  the target doesn't require\n   *                                                                  bundling.\n   * @param {CLISHNodeRunCommand}          cliSHNodeRunCommand        Needed to generate the command\n   *                                                                  to run a Node target if the\n   *                                                                  `run` option is used.\n   * @param {CLISHNodeWatchCommand}        cliSHNodeWatchCommand      Needed to generate the command\n   *                                                                  to watch a Node target files\n   *                                                                  if the `watch` option is used.\n   * @param {CLISHTranspileCommand}        cliSHTranspileCommand      Needed to generate the command\n   *                                                                  to transpile a Node target\n   *                                                                  code.\n   * @param {Events}                       events                     Used to reduce the list of\n   *                                                                  commands generated.\n   * @param {ProjectConfigurationSettings} projectConfiguration       Used to read and validate the\n   *                                                                  features.\n   * @param {Targets}                      targets                    Used to get the targets\n   *                                                                  information.\n   */\n  constructor(\n    builder,\n    buildTypeScriptHelper,\n    cliCleanCommand,\n    cliCopyProjectFilesCommand,\n    cliRevisionCommand,\n    cliSHCopyCommand,\n    cliSHNodeRunCommand,\n    cliSHNodeWatchCommand,\n    cliSHTranspileCommand,\n    events,\n    projectConfiguration,\n    targets\n  ) {\n    super();\n    /**\n     * A local reference for the `builder` service.\n     * @type {Builder}\n     */\n    this.builder = builder;\n    /**\n     * A local reference for the `buildTypeScriptHelper` service.\n     * @type {BuildTypeScriptHelper}\n     */\n    this.buildTypeScriptHelper = buildTypeScriptHelper;\n    /**\n     * A local reference for the `cliCleanCommand` service.\n     * @type {CliCleanCommand}\n     */\n    this.cliCleanCommand = cliCleanCommand;\n    /**\n     * A local reference for the `cliCopyProjectFilesCommand` service.\n     * @type {CliCopyProjectFilesCommand}\n     */\n    this.cliCopyProjectFilesCommand = cliCopyProjectFilesCommand;\n    /**\n     * A local reference for the `cliRevisionCommand` service.\n     * @type {CliRevisionCommand}\n     */\n    this.cliRevisionCommand = cliRevisionCommand;\n    /**\n     * A local reference for the `cliSHCopyCommand` service.\n     * @type {CliSHCopyCommand}\n     */\n    this.cliSHCopyCommand = cliSHCopyCommand;\n    /**\n     * A local reference for the `cliSHNodeRunCommand` service.\n     * @type {CliSHNodeRunCommand}\n     */\n    this.cliSHNodeRunCommand = cliSHNodeRunCommand;\n    /**\n     * A local reference for the `cliSHNodeWatchCommand` service.\n     * @type {CliSHNodeWatchCommand}\n     */\n    this.cliSHNodeWatchCommand = cliSHNodeWatchCommand;\n    /**\n     * A local reference for the `cliSHTranspileCommand` service.\n     * @type {CliSHTranspileCommand}\n     */\n    this.cliSHTranspileCommand = cliSHTranspileCommand;\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-build [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Get the build commands for the shell program to execute';\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n    this.addOption(\n      'run',\n      '-r, --run',\n      'Run the target after the build is completed. It only works when the ' +\n        'build type is development',\n      false\n    );\n    this.addOption(\n      'watch',\n      '-w, --watch',\n      'Rebuild the target every time one of its files changes. It only works ' +\n        'when the build type is development',\n      false\n    );\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector. It only works when running Node targets',\n      false\n    );\n    this.addOption(\n      'analyze',\n      '-a, --analyze',\n      'Enables the bundle analyzer. It only works with targets with bundling',\n      false\n    );\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the build command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and outputs the list of commands to run.\n   * This method emits the event reducer `build-target-commands-list` with the list of commands,\n   * the target information, the type of build and whether or not the target should be executed;\n   * and it expects a list of commands on return.\n   * @param {?string}                name           The name of the target.\n   * @param {Command}                command        The executed command (sent by `commander`).\n   * @param {CLIBuildCommandOptions} options        The command options.\n   * @param {Object}                 unknownOptions A dictionary of extra options that command may\n   *                                                have received.\n   */\n  handle(name, command, options, unknownOptions) {\n    const { type } = options;\n    // Get the target information\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    const {\n      development,\n      analyze,\n      run,\n      inspect,\n      watch,\n    } = this._normalizeOptions(options, target);\n    /**\n     * Check whether or not a build will be created. This is always `true` for browser targets, but\n     * it can be `false` for Node targets if bundling and transpiling is disabled.\n     */\n    let build = true;\n    if (target.is.node) {\n      build = !development || target.bundle || target.transpile;\n    }\n    // Define the parameters object to send to the other methods.\n    const params = {\n      target,\n      type,\n      run,\n      build,\n      watch,\n      inspect,\n      analyze,\n    };\n\n    // Based on the target type, get the list of commands.\n    const commands = target.is.node ?\n      this._getCommandsForNodeTarget(params) :\n      this._getCommandsForBrowserTarget(params);\n    // Reduce the list of commands.\n    const output = this.events.reduce(\n      'build-target-commands-list',\n      commands.filter((cmd) => !!cmd),\n      params,\n      unknownOptions\n    )\n    // Join the commands on a single string.\n    .join(';');\n    // Outputs all the commands\n    this.output(output);\n  }\n  /**\n   * Normalizes the options received by the command in order to resolve \"impossible combinations\",\n   * like trying to analyze a target that is not for bundling or trying to inspect a browser\n   * target.\n   * @param {CLIBuildCommandOptions} options The command options.\n   * @param {Target}                 target  The target information.\n   * @return {CLIBuildCommandNormalizedOptions}\n   * @access protected\n   * @ignore\n   */\n  _normalizeOptions(options, target) {\n    const development = options.type === 'development';\n    // Check if there's a reason to analyze the target bundle.\n    const analyze = options.analyze && (target.is.browser || target.bundle);\n    // Check if there's a reason for the target to be executed.\n    const run = !analyze && development && (target.runOnDevelopment || options.run);\n    // Check if there's a reason for the Node inspector to be enabled.\n    const inspect = run && target.is.node && (target.inspect.enabled || options.inspect);\n    // Check if the target files should be watched.\n    const watch = !run && (target.watch[options.type] || options.watch);\n\n    return {\n      development,\n      analyze,\n      run,\n      inspect,\n      watch,\n    };\n  }\n  /**\n   * Get the build (and run) commands for a Node target.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {Array}\n   * @access protected\n   * @ignore\n   */\n  _getCommandsForNodeTarget(params) {\n    // Get the base commands.\n    const commands = [\n      this._getCleanCommandIfNeeded(params),\n      this._getBuildCommandIfNeeded(params),\n      this._getCopyCommandIfNeeded(params),\n      this._getTranspileCommandIfNeeded(params),\n      this._getTypeScriptDeclarationsCommandIfNeeded(params),\n    ];\n    // If the target won't be executed nor their files will be watched...\n    if (!params.run && !params.watch) {\n      // ...push the commands to create the revision file and copy the project files.\n      commands.push(...[\n        this._getRevisionCommandIfNeeded(params),\n        this._getCopyProjectFilesCommand(params),\n      ]);\n    } else if (!params.target.bundle) {\n      /**\n       * If the target will be executed or their files will be watched, and is not a bundled target,\n       * push the command to either run or watch. The reason it's handled this ways is because if\n       * the target is bundled, the build engine will take care of the execution/watch.\n       */\n      if (params.run) {\n        // Run the target with `nodemon`.\n        commands.push(this._getNodeRunCommand(params));\n      } else if (params.type === 'production' || params.target.transpile) {\n        // Watch the target with `watchpack`.\n        commands.push(this._getNodeWatchCommand(params));\n      }\n    }\n\n    return commands;\n  }\n  /**\n   * Get the build (and run) commands for a browser target.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {Array}\n   * @access protected\n   * @ignore\n   */\n  _getCommandsForBrowserTarget(params) {\n    // Get the base commands.\n    const commands = [\n      this._getCleanCommandIfNeeded(params),\n      this._getBuildCommandIfNeeded(params),\n      this._getTypeScriptDeclarationsCommandIfNeeded(params),\n    ];\n    // If the target won't be executed...\n    if (!params.run && !params.watch) {\n      // ...push the commands to create the revision file and copy the project files.\n      commands.push(...[\n        this._getRevisionCommandIfNeeded(params),\n        this._getCopyProjectFilesCommand(params),\n      ]);\n    }\n\n    return commands;\n  }\n  /**\n   * Get the command to remove the previous build files of a target, but only if the target will be\n   * build, otherwise, it will return an empty string.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getCleanCommandIfNeeded(params) {\n    let command = '';\n    if (params.build && params.target.cleanBeforeBuild) {\n      command = this.cliCleanCommand.generate({\n        target: params.target.name,\n      });\n    }\n\n    return command;\n  }\n  /**\n   * Get the command to actually build a target.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getBuildCommandIfNeeded(params) {\n    return this.builder.getTargetBuildCommand(\n      params.target,\n      params.type,\n      params.run,\n      params.watch,\n      params.inspect,\n      params.analyze\n    );\n  }\n  /**\n   * Get the command to copy a target files, but only if the target will be _'build'_ (transpiled\n   * counts) and it doesn't support bundling, otherwise, it will return an empty string.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getCopyCommandIfNeeded(params) {\n    let command = '';\n    if (params.build && !params.target.bundle) {\n      command = this.cliSHCopyCommand.generate({\n        target: params.target.name,\n        type: params.type,\n      });\n    }\n\n    return command;\n  }\n  /**\n   * Get the command to transpile a target files, but only if the target will be _'build'_\n   * (transpiled counts) and it doesn't support bundling, otherwise, it will return an empty string.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getTranspileCommandIfNeeded(params) {\n    let command = '';\n    if (params.build && !params.target.bundle) {\n      command = this.cliSHTranspileCommand.generate({\n        target: params.target.name,\n        type: params.type,\n      });\n    }\n\n    return command;\n  }\n  /**\n   * Get the command to generate a TypeScript target type declarations, but only if the target\n   * uses TypeScript, won't run and won't be watched: The idea is to generate the declarations only\n   * when you build the target and not during all the development process.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getTypeScriptDeclarationsCommandIfNeeded(params) {\n    let command = '';\n    if (\n      params.target.typeScript &&\n      params.build &&\n      !params.run &&\n      !params.watch\n    ) {\n      command = this.buildTypeScriptHelper.getDeclarationsCommand(params.target);\n    }\n\n    return command;\n  }\n  /**\n   * Get the command to run a Node target.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getNodeRunCommand(params) {\n    return this.cliSHNodeRunCommand.generate({\n      target: params.target.name,\n      inspect: params.inspect,\n    });\n  }\n  /**\n   * Get the command to watch a Node target.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getNodeWatchCommand(params) {\n    return this.cliSHNodeWatchCommand.generate({\n      target: params.target.name,\n    });\n  }\n  /**\n   * Get the command to create the revision file, but only if the feature is enabled, otherwise,\n   * it will return an empty string.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getRevisionCommandIfNeeded(params) {\n    const {\n      enabled,\n      createRevisionOnBuild,\n    } = this.projectConfiguration.version.revision;\n    let command = '';\n    if (enabled && createRevisionOnBuild.enabled) {\n      const revisionEnvCheck = !createRevisionOnBuild.onlyOnProduction ||\n        (createRevisionOnBuild.onlyOnProduction && params.type === 'production');\n      const revisionTargetCheck = !createRevisionOnBuild.targets.length ||\n        createRevisionOnBuild.targets.includes(params.target.name);\n\n      if (revisionEnvCheck && revisionTargetCheck) {\n        command = this.cliRevisionCommand.generate();\n      }\n    }\n\n    return command;\n  }\n  /**\n   * Get the command to copy the project files, but only if the feature is enabled, otherwise,\n   * it will return an empty string.\n   * @param {CLIBuildCommandParams} params A dictionary with all the required information the\n   *                                       service needs to run the command: The target\n   *                                       information, the build type, whether or not the target\n   *                                       will be executed, etc.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getCopyProjectFilesCommand(params) {\n    const { enabled, copyOnBuild } = this.projectConfiguration.copy;\n    let command = '';\n    if (enabled && copyOnBuild.enabled) {\n      const copyEnvCheck = !copyOnBuild.onlyOnProduction ||\n        (copyOnBuild.onlyOnProduction && params.type === 'production');\n      const copyTargetCheck = !copyOnBuild.targets.length ||\n        copyOnBuild.targets.includes(params.target.name);\n\n      if (copyEnvCheck && copyTargetCheck) {\n        command = this.cliCopyProjectFilesCommand.generate();\n      }\n    }\n\n    return command;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHBuildCommand` as the `cliSHBuildCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHBuildCommand);\n * // Getting access to the service instance\n * const cliSHBuildCommand = container.get('cliSHBuildCommand');\n * @type {Provider}\n */\nconst cliSHBuildCommand = provider((app) => {\n  app.set('cliSHBuildCommand', () => new CLISHBuildCommand(\n    app.get('builder'),\n    app.get('buildTypeScriptHelper'),\n    app.get('cliCleanCommand'),\n    app.get('cliCopyProjectFilesCommand'),\n    app.get('cliRevisionCommand'),\n    app.get('cliSHCopyCommand'),\n    app.get('cliSHNodeRunCommand'),\n    app.get('cliSHNodeWatchCommand'),\n    app.get('cliSHTranspileCommand'),\n    app.get('events'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHBuildCommand,\n  cliSHBuildCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHBuild.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 364,
    "kind": "class",
    "name": "CLISHBuildCommand",
    "memberof": "src/services/cli/cliSHBuild.js",
    "static": true,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHBuild.js",
    "importStyle": "{CLISHBuildCommand}",
    "description": "This is the _'real build command'_. This is a private command the shell script executes in order\nto get a list of commands to run.",
    "lineNumber": 9,
    "todo": [
      "This whole class needs a refactor (args and params are the same!)."
    ],
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 365,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Builder"
        ],
        "spread": false,
        "optional": false,
        "name": "builder",
        "description": "Needed to generate a target\n                                                                 build command."
      },
      {
        "nullable": null,
        "types": [
          "CLICleanCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliCleanCommand",
        "description": "Needed to generate the command\n                                                                 that cleans a target files."
      },
      {
        "nullable": null,
        "types": [
          "CLICopyProjectFilesCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliCopyProjectFilesCommand",
        "description": "Needed to generate the command\n                                                                 to copy the project files if\n                                                                 the feature of copying on\n                                                                 build is enabled."
      },
      {
        "nullable": null,
        "types": [
          "CLIRevisionCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliRevisionCommand",
        "description": "Needed to generate the command\n                                                                 that creates the revision file\n                                                                 if the feature of generating\n                                                                 it on build is enabled."
      },
      {
        "nullable": null,
        "types": [
          "CLISHCopyCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliSHCopyCommand",
        "description": "Needed to generate the command\n                                                                 to copy the target files if\n                                                                 the target doesn't require\n                                                                 bundling."
      },
      {
        "nullable": null,
        "types": [
          "CLISHNodeRunCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliSHNodeRunCommand",
        "description": "Needed to generate the command\n                                                                 to run a Node target if the\n                                                                 `run` option is used."
      },
      {
        "nullable": null,
        "types": [
          "CLISHNodeWatchCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliSHNodeWatchCommand",
        "description": "Needed to generate the command\n                                                                 to watch a Node target files\n                                                                 if the `watch` option is used."
      },
      {
        "nullable": null,
        "types": [
          "CLISHTranspileCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliSHTranspileCommand",
        "description": "Needed to generate the command\n                                                                 to transpile a Node target\n                                                                 code."
      },
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "Used to reduce the list of\n                                                                 commands generated."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "Used to read and validate the\n                                                                 features."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "Used to get the targets\n                                                                 information."
      }
    ]
  },
  {
    "__docId__": 366,
    "kind": "member",
    "name": "builder",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#builder",
    "access": "public",
    "description": "A local reference for the `builder` service.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "Builder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 367,
    "kind": "member",
    "name": "buildTypeScriptHelper",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#buildTypeScriptHelper",
    "access": "public",
    "description": "A local reference for the `buildTypeScriptHelper` service.",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "BuildTypeScriptHelper"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 368,
    "kind": "member",
    "name": "cliCleanCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliCleanCommand",
    "access": "public",
    "description": "A local reference for the `cliCleanCommand` service.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "CliCleanCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 369,
    "kind": "member",
    "name": "cliCopyProjectFilesCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliCopyProjectFilesCommand",
    "access": "public",
    "description": "A local reference for the `cliCopyProjectFilesCommand` service.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "CliCopyProjectFilesCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 370,
    "kind": "member",
    "name": "cliRevisionCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliRevisionCommand",
    "access": "public",
    "description": "A local reference for the `cliRevisionCommand` service.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "CliRevisionCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 371,
    "kind": "member",
    "name": "cliSHCopyCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliSHCopyCommand",
    "access": "public",
    "description": "A local reference for the `cliSHCopyCommand` service.",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "CliSHCopyCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "cliSHNodeRunCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliSHNodeRunCommand",
    "access": "public",
    "description": "A local reference for the `cliSHNodeRunCommand` service.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "CliSHNodeRunCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "cliSHNodeWatchCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliSHNodeWatchCommand",
    "access": "public",
    "description": "A local reference for the `cliSHNodeWatchCommand` service.",
    "lineNumber": 98,
    "type": {
      "nullable": null,
      "types": [
        "CliSHNodeWatchCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "cliSHTranspileCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#cliSHTranspileCommand",
    "access": "public",
    "description": "A local reference for the `cliSHTranspileCommand` service.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "CliSHTranspileCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 113,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 118,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 123,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 166,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the build command.",
    "lineNumber": 171,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and outputs the list of commands to run.\nThis method emits the event reducer `build-target-commands-list` with the list of commands,\nthe target information, the type of build and whether or not the target should be executed;\nand it expects a list of commands on return.",
    "lineNumber": 184,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of extra options that command may\n                                               have received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "_normalizeOptions",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_normalizeOptions",
    "access": "protected",
    "description": "Normalizes the options received by the command in order to resolve \"impossible combinations\",\nlike trying to analyze a target that is not for bundling or trying to inspect a browser\ntarget.",
    "lineNumber": 245,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CLIBuildCommandNormalizedOptions"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "_getCommandsForNodeTarget",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getCommandsForNodeTarget",
    "access": "protected",
    "description": "Get the build (and run) commands for a Node target.",
    "lineNumber": 274,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "_getCommandsForBrowserTarget",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getCommandsForBrowserTarget",
    "access": "protected",
    "description": "Get the build (and run) commands for a browser target.",
    "lineNumber": 317,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "_getCleanCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getCleanCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to remove the previous build files of a target, but only if the target will be\nbuild, otherwise, it will return an empty string.",
    "lineNumber": 346,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "_getBuildCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getBuildCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to actually build a target.",
    "lineNumber": 366,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "_getCopyCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getCopyCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to copy a target files, but only if the target will be _'build'_ (transpiled\ncounts) and it doesn't support bundling, otherwise, it will return an empty string.",
    "lineNumber": 387,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "_getTranspileCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getTranspileCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to transpile a target files, but only if the target will be _'build'_\n(transpiled counts) and it doesn't support bundling, otherwise, it will return an empty string.",
    "lineNumber": 409,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "_getTypeScriptDeclarationsCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getTypeScriptDeclarationsCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to generate a TypeScript target type declarations, but only if the target\nuses TypeScript, won't run and won't be watched: The idea is to generate the declarations only\nwhen you build the target and not during all the development process.",
    "lineNumber": 432,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "_getNodeRunCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getNodeRunCommand",
    "access": "protected",
    "description": "Get the command to run a Node target.",
    "lineNumber": 455,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "_getNodeWatchCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getNodeWatchCommand",
    "access": "protected",
    "description": "Get the command to watch a Node target.",
    "lineNumber": 471,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "_getRevisionCommandIfNeeded",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getRevisionCommandIfNeeded",
    "access": "protected",
    "description": "Get the command to create the revision file, but only if the feature is enabled, otherwise,\nit will return an empty string.",
    "lineNumber": 487,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "_getCopyProjectFilesCommand",
    "memberof": "src/services/cli/cliSHBuild.js~CLISHBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHBuild.js~CLISHBuildCommand#_getCopyProjectFilesCommand",
    "access": "protected",
    "description": "Get the command to copy the project files, but only if the feature is enabled, otherwise,\nit will return an empty string.",
    "lineNumber": 517,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandParams"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "A dictionary with all the required information the\n                                      service needs to run the command: The target\n                                      information, the build type, whether or not the target\n                                      will be executed, etc."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 395,
    "kind": "variable",
    "name": "cliSHBuildCommand",
    "memberof": "src/services/cli/cliSHBuild.js",
    "static": true,
    "longname": "src/services/cli/cliSHBuild.js~cliSHBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHBuild.js",
    "importStyle": "{cliSHBuildCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHBuildCommand` as the `cliSHBuildCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHBuildCommand);\n// Getting access to the service instance\nconst cliSHBuildCommand = container.get('cliSHBuildCommand');"
    ],
    "lineNumber": 544,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 396,
    "kind": "file",
    "name": "src/services/cli/cliSHCopy.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes in order to copy a target files.\n * @extends {CLICommand}\n */\nclass CLISHCopyCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Builder} builder To copy the target files.\n   */\n  constructor(builder) {\n    super();\n    /**\n     * A local reference for the `builder` service.\n     * @type {Builder}\n     */\n    this.builder = builder;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-copy-target [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Copy a target files, only if the target requires' +\n      'transpilation or the `type` argument is production';\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n  }\n  /**\n   * Handle the execution of the command and copies a target files.\n   * @param {string}  target       The name of the target.\n   * @param {Command} command      The executed command (sent by `commander`).\n   * @param {Object}  options      The command options.\n   * @param {string}  options.type The type of build.\n   */\n  handle(target, command, options) {\n    return this.builder.copyTarget(target, options.type);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHCopyCommand` as the `cliSHCopyCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHCopyCommand);\n * // Getting access to the service instance\n * const cliSHCopyCommand = container.get('cliSHCopyCommand');\n * @type {Provider}\n */\nconst cliSHCopyCommand = provider((app) => {\n  app.set('cliSHCopyCommand', () => new CLISHCopyCommand(app.get('builder')));\n});\n\nmodule.exports = {\n  CLISHCopyCommand,\n  cliSHCopyCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHCopy.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 397,
    "kind": "class",
    "name": "CLISHCopyCommand",
    "memberof": "src/services/cli/cliSHCopy.js",
    "static": true,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHCopy.js",
    "importStyle": "{CLISHCopyCommand}",
    "description": "This is a private command the shell script executes in order to copy a target files.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 398,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Builder"
        ],
        "spread": false,
        "optional": false,
        "name": "builder",
        "description": "To copy the target files."
      }
    ]
  },
  {
    "__docId__": 399,
    "kind": "member",
    "name": "builder",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#builder",
    "access": "public",
    "description": "A local reference for the `builder` service.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Builder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 400,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 401,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 402,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHCopy.js~CLISHCopyCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHCopy.js~CLISHCopyCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and copies a target files.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.type",
        "description": "The type of build."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 404,
    "kind": "variable",
    "name": "cliSHCopyCommand",
    "memberof": "src/services/cli/cliSHCopy.js",
    "static": true,
    "longname": "src/services/cli/cliSHCopy.js~cliSHCopyCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHCopy.js",
    "importStyle": "{cliSHCopyCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHCopyCommand` as the `cliSHCopyCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHCopyCommand);\n// Getting access to the service instance\nconst cliSHCopyCommand = container.get('cliSHCopyCommand');"
    ],
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 405,
    "kind": "file",
    "name": "src/services/cli/cliSHInspect.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the _'real inspect command'_. This is a private command the shell script executes in\n * order to get a list of commands it should execute.\n * @extends {CLICommand}\n */\nclass CLISHInspectCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {CLIBuildCommand} cliBuildCommand The inspect command is actually an alias for the\n   *                                          build command with the `--run` and `--inspect` flags\n   *                                          set to true.\n   * @param {Targets}         targets         To get the name of the default target if no other is\n   *                                          specified.\n   */\n  constructor(cliBuildCommand, targets) {\n    super();\n    /**\n     * A local reference for the `cliBuildCommand` service.\n     * @type {CLIBuildCommand}\n     */\n    this.cliBuildCommand = cliBuildCommand;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-inspect [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Get the build commands for the shell program to execute';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and outputs the list of commands to run.\n   * @param {?string} name The name of the target.\n   * @param {Command} command        The executed command (sent by `commander`).\n   * @param {Object}  options        The command options.\n   * @param {Object}  unknownOptions A dictionary of extra options that command may have received.\n   */\n  handle(name, command, options, unknownOptions) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    this.output(this.cliBuildCommand.generate(Object.assign(\n      {},\n      unknownOptions,\n      {\n        target: target.name,\n        type: 'development',\n        run: true,\n        inspect: true,\n      }\n    )));\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHInspectCommand` as the `cliSHInspectCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHInspectCommand);\n * // Getting access to the service instance\n * const cliSHInspectCommand = container.get('cliSHInspectCommand');\n * @type {Provider}\n */\nconst cliSHInspectCommand = provider((app) => {\n  app.set('cliSHInspectCommand', () => new CLISHInspectCommand(\n    app.get('cliBuildCommand'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHInspectCommand,\n  cliSHInspectCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHInspect.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 406,
    "kind": "class",
    "name": "CLISHInspectCommand",
    "memberof": "src/services/cli/cliSHInspect.js",
    "static": true,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHInspect.js",
    "importStyle": "{CLISHInspectCommand}",
    "description": "This is the _'real inspect command'_. This is a private command the shell script executes in\norder to get a list of commands it should execute.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 407,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliBuildCommand",
        "description": "The inspect command is actually an alias for the\n                                         build command with the `--run` and `--inspect` flags\n                                         set to true."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the name of the default target if no other is\n                                         specified."
      }
    ]
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "cliBuildCommand",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#cliBuildCommand",
    "access": "public",
    "description": "A local reference for the `cliBuildCommand` service.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "CLIBuildCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 409,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 410,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 411,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 412,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 413,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHInspect.js~CLISHInspectCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHInspect.js~CLISHInspectCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and outputs the list of commands to run.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of extra options that command may have received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 415,
    "kind": "variable",
    "name": "cliSHInspectCommand",
    "memberof": "src/services/cli/cliSHInspect.js",
    "static": true,
    "longname": "src/services/cli/cliSHInspect.js~cliSHInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHInspect.js",
    "importStyle": "{cliSHInspectCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHInspectCommand` as the `cliSHInspectCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHInspectCommand);\n// Getting access to the service instance\nconst cliSHInspectCommand = container.get('cliSHInspectCommand');"
    ],
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 416,
    "kind": "file",
    "name": "src/services/cli/cliSHNodeRun.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes in order to run a Node target with `nodemon`.\n * @extends {CLICommand}\n */\nclass CLISHNodeRunCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {BuildNodeRunner} buildNodeRunner To actually run a target.\n   * @param {Targets}         targets         To get a target information.\n   */\n  constructor(buildNodeRunner, targets) {\n    super();\n    /**\n     * A local reference for the `buildNodeRunner` service.\n     * @type {BuildNodeRunner}\n     */\n    this.buildNodeRunner = buildNodeRunner;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-node-run [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Run a Node target that wasn\\'t bundled';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector',\n      false\n    );\n  }\n  /**\n   * Handle the execution of the command and runs a Node target.\n   * @param {string}  name            The name of the target.\n   * @param {Command} command         The executed command (sent by `commander`).\n   * @param {Object}  options         The command options.\n   * @param {boolean} options.inspect Whether or not to enable the Node inspector.\n   * @return {Nodemon}\n   */\n  handle(name, command, options) {\n    const target = this.targets.getTarget(name);\n    return this.buildNodeRunner.runTarget(target, options.inspect);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHNodeRunCommand` as the `cliSHNodeRunCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHNodeRunCommand);\n * // Getting access to the service instance\n * const cliSHNodeRunCommand = container.get('cliSHNodeRunCommand');\n * @type {Provider}\n */\nconst cliSHNodeRunCommand = provider((app) => {\n  app.set('cliSHNodeRunCommand', () => new CLISHNodeRunCommand(\n    app.get('buildNodeRunner'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHNodeRunCommand,\n  cliSHNodeRunCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHNodeRun.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 417,
    "kind": "class",
    "name": "CLISHNodeRunCommand",
    "memberof": "src/services/cli/cliSHNodeRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHNodeRun.js",
    "importStyle": "{CLISHNodeRunCommand}",
    "description": "This is a private command the shell script executes in order to run a Node target with `nodemon`.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 418,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildNodeRunner"
        ],
        "spread": false,
        "optional": false,
        "name": "buildNodeRunner",
        "description": "To actually run a target."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get a target information."
      }
    ]
  },
  {
    "__docId__": 419,
    "kind": "member",
    "name": "buildNodeRunner",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#buildNodeRunner",
    "access": "public",
    "description": "A local reference for the `buildNodeRunner` service.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "BuildNodeRunner"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 420,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 421,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 422,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 423,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHNodeRun.js~CLISHNodeRunCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and runs a Node target.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "options.inspect",
        "description": "Whether or not to enable the Node inspector."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Nodemon"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 426,
    "kind": "variable",
    "name": "cliSHNodeRunCommand",
    "memberof": "src/services/cli/cliSHNodeRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHNodeRun.js~cliSHNodeRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHNodeRun.js",
    "importStyle": "{cliSHNodeRunCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHNodeRunCommand` as the `cliSHNodeRunCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHNodeRunCommand);\n// Getting access to the service instance\nconst cliSHNodeRunCommand = container.get('cliSHNodeRunCommand');"
    ],
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 427,
    "kind": "file",
    "name": "src/services/cli/cliSHNodeWatch.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes in order to watch a Node target with\n * `watchpack`.\n * @extends {CLICommand}\n */\nclass CLISHNodeWatchCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {BuildNodeWatcher} buildNodeWatcher To actually run a target.\n   * @param {Targets}          targets         To get a target information.\n   */\n  constructor(buildNodeWatcher, targets) {\n    super();\n    /**\n     * A local reference for the `buildNodeWatcher` service.\n     * @type {BuildNodeRunner}\n     */\n    this.buildNodeWatcher = buildNodeWatcher;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-node-watch [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Watch a Node target that wasn\\'t bundled';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and runs a Node target.\n   * @param {string} name The name of the target.\n   * @return {Watchpack}\n   */\n  handle(name) {\n    const target = this.targets.getTarget(name);\n    return this.buildNodeWatcher.watchTarget(target);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHNodeWatchCommand` as the `cliSHNodeWatchCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHNodeWatchCommand);\n * // Getting access to the service instance\n * const cliSHNodeWatchCommand = container.get('cliSHNodeWatchCommand');\n * @type {Provider}\n */\nconst cliSHNodeWatchCommand = provider((app) => {\n  app.set('cliSHNodeWatchCommand', () => new CLISHNodeWatchCommand(\n    app.get('buildNodeWatcher'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHNodeWatchCommand,\n  cliSHNodeWatchCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHNodeWatch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 428,
    "kind": "class",
    "name": "CLISHNodeWatchCommand",
    "memberof": "src/services/cli/cliSHNodeWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHNodeWatch.js",
    "importStyle": "{CLISHNodeWatchCommand}",
    "description": "This is a private command the shell script executes in order to watch a Node target with\n`watchpack`.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 429,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "BuildNodeWatcher"
        ],
        "spread": false,
        "optional": false,
        "name": "buildNodeWatcher",
        "description": "To actually run a target."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get a target information."
      }
    ]
  },
  {
    "__docId__": 430,
    "kind": "member",
    "name": "buildNodeWatcher",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#buildNodeWatcher",
    "access": "public",
    "description": "A local reference for the `buildNodeWatcher` service.",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "BuildNodeRunner"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 431,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 432,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 433,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 434,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 435,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHNodeWatch.js~CLISHNodeWatchCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and runs a Node target.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Watchpack"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 437,
    "kind": "variable",
    "name": "cliSHNodeWatchCommand",
    "memberof": "src/services/cli/cliSHNodeWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHNodeWatch.js~cliSHNodeWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHNodeWatch.js",
    "importStyle": "{cliSHNodeWatchCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHNodeWatchCommand` as the `cliSHNodeWatchCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHNodeWatchCommand);\n// Getting access to the service instance\nconst cliSHNodeWatchCommand = container.get('cliSHNodeWatchCommand');"
    ],
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 438,
    "kind": "file",
    "name": "src/services/cli/cliSHRun.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the _'real run command'_. This is a private command the shell script executes in order\n * to get a list of commands it should execute.\n * @extends {CLICommand}\n */\nclass CLISHRunCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {CLIBuildCommand} cliBuildCommand The run command is actually an alias for the build\n   *                                          command with the `--run` option flag set to true.\n   * @param {Targets}         targets         To get the name of the default target if no other is\n   *                                          specified.\n   */\n  constructor(cliBuildCommand, targets) {\n    super();\n    /**\n     * A local reference for the `cliBuildCommand` service.\n     * @type {CLIBuildCommand}\n     */\n    this.cliBuildCommand = cliBuildCommand;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-run [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Get the build commands for the shell program to execute';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector. It only works with Node targets',\n      false\n    );\n  }\n  /**\n   * Handle the execution of the command and outputs the list of commands to run.\n   * @param {?string} name            The name of the target.\n   * @param {Command} command         The executed command (sent by `commander`).\n   * @param {Object}  options         The command options.\n   * @param {boolean} options.inspect Whether or not to enable the Node inspector.\n   * @param {Object}  unknownOptions  A dictionary of extra options that command may have received.\n   */\n  handle(name, command, options, unknownOptions) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    this.output(this.cliBuildCommand.generate(Object.assign(\n      {},\n      unknownOptions,\n      {\n        target: target.name,\n        type: 'development',\n        run: true,\n        inspect: options.inspect,\n      }\n    )));\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHRunCommand` as the `cliSHRunCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHRunCommand);\n * // Getting access to the service instance\n * const cliSHRunCommand = container.get('cliSHRunCommand');\n * @type {Provider}\n */\nconst cliSHRunCommand = provider((app) => {\n  app.set('cliSHRunCommand', () => new CLISHRunCommand(\n    app.get('cliBuildCommand'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHRunCommand,\n  cliSHRunCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHRun.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 439,
    "kind": "class",
    "name": "CLISHRunCommand",
    "memberof": "src/services/cli/cliSHRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHRun.js",
    "importStyle": "{CLISHRunCommand}",
    "description": "This is the _'real run command'_. This is a private command the shell script executes in order\nto get a list of commands it should execute.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 440,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliBuildCommand",
        "description": "The run command is actually an alias for the build\n                                         command with the `--run` option flag set to true."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the name of the default target if no other is\n                                         specified."
      }
    ]
  },
  {
    "__docId__": 441,
    "kind": "member",
    "name": "cliBuildCommand",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#cliBuildCommand",
    "access": "public",
    "description": "A local reference for the `cliBuildCommand` service.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "CLIBuildCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 442,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 443,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 444,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 445,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 446,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHRun.js~CLISHRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHRun.js~CLISHRunCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and outputs the list of commands to run.",
    "lineNumber": 64,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "options.inspect",
        "description": "Whether or not to enable the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of extra options that command may have received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 448,
    "kind": "variable",
    "name": "cliSHRunCommand",
    "memberof": "src/services/cli/cliSHRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHRun.js~cliSHRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHRun.js",
    "importStyle": "{cliSHRunCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHRunCommand` as the `cliSHRunCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHRunCommand);\n// Getting access to the service instance\nconst cliSHRunCommand = container.get('cliSHRunCommand');"
    ],
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 449,
    "kind": "file",
    "name": "src/services/cli/cliSHTranspile.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes in order to transpile a target.\n * @extends {CLICommand}\n */\nclass CLISHTranspileCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Builder} builder To copy the target files.\n   */\n  constructor(builder) {\n    super();\n    /**\n     * A local reference for the `builder` service.\n     * @type {Builder}\n     */\n    this.builder = builder;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-transpile-target [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Transpile a target code if needed';\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n  }\n  /**\n   * Handle the execution of the command and copies a target files.\n   * @param {string}  target       The name of the target.\n   * @param {Command} command      The executed command (sent by `commander`).\n   * @param {Object}  options      The command options.\n   * @param {string}  options.type The type of build.\n   */\n  handle(target, command, options) {\n    return this.builder.transpileTarget(target, options.type);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHTranspileCommand` as the `cliSHTranspileCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHTranspileCommand);\n * // Getting access to the service instance\n * const cliSHTranspileCommand = container.get('cliSHTranspileCommand');\n * @type {Provider}\n */\nconst cliSHTranspileCommand = provider((app) => {\n  app.set('cliSHTranspileCommand', () => new CLISHTranspileCommand(app.get('builder')));\n});\n\nmodule.exports = {\n  CLISHTranspileCommand,\n  cliSHTranspileCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHTranspile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 450,
    "kind": "class",
    "name": "CLISHTranspileCommand",
    "memberof": "src/services/cli/cliSHTranspile.js",
    "static": true,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHTranspile.js",
    "importStyle": "{CLISHTranspileCommand}",
    "description": "This is a private command the shell script executes in order to transpile a target.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 451,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Builder"
        ],
        "spread": false,
        "optional": false,
        "name": "builder",
        "description": "To copy the target files."
      }
    ]
  },
  {
    "__docId__": 452,
    "kind": "member",
    "name": "builder",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#builder",
    "access": "public",
    "description": "A local reference for the `builder` service.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Builder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 453,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 454,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 455,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHTranspile.js~CLISHTranspileCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and copies a target files.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.type",
        "description": "The type of build."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 457,
    "kind": "variable",
    "name": "cliSHTranspileCommand",
    "memberof": "src/services/cli/cliSHTranspile.js",
    "static": true,
    "longname": "src/services/cli/cliSHTranspile.js~cliSHTranspileCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHTranspile.js",
    "importStyle": "{cliSHTranspileCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHTranspileCommand` as the `cliSHTranspileCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHTranspileCommand);\n// Getting access to the service instance\nconst cliSHTranspileCommand = container.get('cliSHTranspileCommand');"
    ],
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 458,
    "kind": "file",
    "name": "src/services/cli/cliSHValidateAnalyze.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes before running the analyze command in order\n * to validate the arguments and throw any necessary error. The reason we do this in two separated\n * commands is that the shell script takes all the output of the run command and tries to execute\n * it, so we can't include execptions in there.\n * @extends {CLICommand}\n */\nclass CLISHValidateAnalyzeCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Targets} targets To validate a target existence.\n   */\n  constructor(targets) {\n    super();\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-validate-analyze [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Validate the arguments before the shell executes the task';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and validate the target existence.\n   * @param {?string} name The name of the target.\n   * @throws {Error} If the target type is `browser`.\n   */\n  handle(name) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    if (!target.is.browser && !target.bundle) {\n      throw new Error(`'${target.name}' doesn't do bundling, so it can't be analyzed`);\n    }\n\n    return target;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHValidateAnalyzeCommand` as the `cliSHValidateAnalyzeCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHValidateAnalyzeCommand);\n * // Getting access to the service instance\n * const cliSHValidateAnalyzeCommand = container.get('cliSHValidateAnalyzeCommand');\n * @type {Provider}\n */\nconst cliSHValidateAnalyzeCommand = provider((app) => {\n  app.set('cliSHValidateAnalyzeCommand', () => new CLISHValidateAnalyzeCommand(\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHValidateAnalyzeCommand,\n  cliSHValidateAnalyzeCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHValidateAnalyze.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 459,
    "kind": "class",
    "name": "CLISHValidateAnalyzeCommand",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateAnalyze.js",
    "importStyle": "{CLISHValidateAnalyzeCommand}",
    "description": "This is a private command the shell script executes before running the analyze command in order\nto validate the arguments and throw any necessary error. The reason we do this in two separated\ncommands is that the shell script takes all the output of the run command and tries to execute\nit, so we can't include execptions in there.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 460,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To validate a target existence."
      }
    ]
  },
  {
    "__docId__": 461,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 462,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 463,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 464,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 465,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~CLISHValidateAnalyzeCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and validate the target existence.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target type is `browser`."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 467,
    "kind": "variable",
    "name": "cliSHValidateAnalyzeCommand",
    "memberof": "src/services/cli/cliSHValidateAnalyze.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateAnalyze.js~cliSHValidateAnalyzeCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateAnalyze.js",
    "importStyle": "{cliSHValidateAnalyzeCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHValidateAnalyzeCommand` as the `cliSHValidateAnalyzeCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHValidateAnalyzeCommand);\n// Getting access to the service instance\nconst cliSHValidateAnalyzeCommand = container.get('cliSHValidateAnalyzeCommand');"
    ],
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 468,
    "kind": "file",
    "name": "src/services/cli/cliSHValidateBuild.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes before running the build command in order to\n * validate the arguments and throw any necessary error. The reason we do this in two separated\n * commands is that the shell script takes all the output of the build command and tries to execute\n * it, so we can't include execptions in there.\n * @extends {CLICommand}\n */\nclass CLISHValidateBuildCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Logger}      appLogger   To inform the user if something goes wrong.\n   * @param {Targets}     targets     To validate a target existence.\n   * @param {TargetsHTML} targetsHTML To validate a browser target HTML file.\n   * @param {TempFiles}   tempFiles   To validate that the temp directory can be created.\n   */\n  constructor(appLogger, targets, targetsHTML, tempFiles) {\n    super();\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * A local reference for the `targetsHTML` service.\n     * @type {TargetsHTML}\n     */\n    this.targetsHTML = targetsHTML;\n    /**\n     * A local reference for the `tempFiles` service.\n     * @type {TempFiles}\n     */\n    this.tempFiles = tempFiles;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-validate-build [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Validate the arguments before the shell executes the task';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the build command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n    this.addOption(\n      'run',\n      '-r, --run',\n      'Run the target after the build is completed. It only works when the ' +\n        'build type is development',\n      false\n    );\n    this.addOption(\n      'watch',\n      '-w, --watch',\n      'Rebuild the target every time one of its files changes. It only works ' +\n        'when the build type is development',\n      false\n    );\n    this.addOption(\n      'inspect',\n      '-i, --inspect',\n      'Enables the Node inspector. It only works with Node targets',\n      false\n    );\n  }\n  /**\n   * Handle the execution of the command and validate all the arguments.\n   * @param {?string}                name     The name of the target.\n   * @param {Command}                command  The executed command (sent by `commander`).\n   * @param {CLIBuildCommandOptions} options  The command options.\n   * @throws {Error} If the `inspect` option is used for a browser target.\n   */\n  handle(name, command, options) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    const useOptions = this._normalizeOptions(options, target);\n\n    if (target.is.node) {\n      const nodeValidations = this._getNodeTargetValidations(target, useOptions);\n      if (nodeValidations.invalidBuild) {\n        this.appLogger.warning(\n          `The target '${target.name}' doesn't need bundling nor transpilation, ` +\n          'so there\\'s no need to build it'\n        );\n      } else if (nodeValidations.invalidWatch) {\n        this.appLogger.warning(\n          `The target '${target.name}' doesn't need bundling nor transpilation, ` +\n          'so there\\'s no need to watch it'\n        );\n      }\n    } else if (useOptions.inspect) {\n      throw new Error(`'${target.name}' is not a Node target, so it can't be inspected`);\n    } else if (!(target.library && !useOptions.development)) {\n      this.tempFiles.ensureDirectorySync();\n      const htmlStatus = this.targetsHTML.validate(target);\n      if (!htmlStatus.exists) {\n        this.appLogger.warning(\n          `The target '${target.name}' doesn't have an HTML template, projext will generate ` +\n          'one for this build, but it would be best for you to create one. You can use the ' +\n          '\\'generate\\' command'\n        );\n      }\n    }\n  }\n  /**\n   * Normalizes the options received by the command in order to resolve \"impossible combinations\",\n   * like trying to analyze a target that is not for bundling or trying to inspect a browser\n   * target.\n   * @param {CLIBuildCommandOptions} options The command options.\n   * @param {Target}                 target  The target information.\n   * @return {CLIBuildCommandNormalizedOptions}\n   * @access protected\n   * @ignore\n   */\n  _normalizeOptions(options, target) {\n    const development = options.type === 'development';\n    const run = development && (target.runOnDevelopment || options.run);\n    const watch = !run && (target.watch[options.type] || options.watch);\n    const inspect = run && options.inspect;\n    return {\n      development,\n      run,\n      watch,\n      inspect,\n    };\n  }\n  /**\n   * Get validations for an specific Node target based on the options the command recevied (and\n   * normalized).\n   * @param {Target}                           target  The target information.\n   * @param {CLIBuildCommandNormalizedOptions} options The command (normalized) options.\n   * @return {Object} A dictionary of \"validation flags\".\n   * @property {Boolean} invalidBuild Whether or not there's no reason for building the target.\n   * @property {Boolean} invalidWatch Whether or not there's no reason for watching the target.\n   * @access protected\n   * @ignore\n   */\n  _getNodeTargetValidations(target, options) {\n    const invalidBuild = options.development &&\n      !options.run &&\n      !options.watch &&\n      !target.bundle &&\n      !target.transpile;\n    const invalidWatch = !invalidBuild &&\n      options.development &&\n      !options.run &&\n      options.watch &&\n      !target.bundle &&\n      !target.transpile;\n\n    return {\n      invalidBuild,\n      invalidWatch,\n    };\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHValidateBuildCommand` as the `cliSHValidateBuildCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHValidateBuildCommand);\n * // Getting access to the service instance\n * const cliSHValidateBuildCommand = container.get('cliSHValidateBuildCommand');\n * @type {Provider}\n */\nconst cliSHValidateBuildCommand = provider((app) => {\n  app.set('cliSHValidateBuildCommand', () => new CLISHValidateBuildCommand(\n    app.get('appLogger'),\n    app.get('targets'),\n    app.get('targetsHTML'),\n    app.get('tempFiles')\n  ));\n});\n\nmodule.exports = {\n  CLISHValidateBuildCommand,\n  cliSHValidateBuildCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHValidateBuild.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 469,
    "kind": "class",
    "name": "CLISHValidateBuildCommand",
    "memberof": "src/services/cli/cliSHValidateBuild.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateBuild.js",
    "importStyle": "{CLISHValidateBuildCommand}",
    "description": "This is a private command the shell script executes before running the build command in order to\nvalidate the arguments and throw any necessary error. The reason we do this in two separated\ncommands is that the shell script takes all the output of the build command and tries to execute\nit, so we can't include execptions in there.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 470,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To inform the user if something goes wrong."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To validate a target existence."
      },
      {
        "nullable": null,
        "types": [
          "TargetsHTML"
        ],
        "spread": false,
        "optional": false,
        "name": "targetsHTML",
        "description": "To validate a browser target HTML file."
      },
      {
        "nullable": null,
        "types": [
          "TempFiles"
        ],
        "spread": false,
        "optional": false,
        "name": "tempFiles",
        "description": "To validate that the temp directory can be created."
      }
    ]
  },
  {
    "__docId__": 471,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 472,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 473,
    "kind": "member",
    "name": "targetsHTML",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#targetsHTML",
    "access": "public",
    "description": "A local reference for the `targetsHTML` service.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "TargetsHTML"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 474,
    "kind": "member",
    "name": "tempFiles",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#tempFiles",
    "access": "public",
    "description": "A local reference for the `tempFiles` service.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "TempFiles"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 475,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 476,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 477,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 478,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the build command.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and validate all the arguments.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the `inspect` option is used for a browser target."
      }
    ],
    "return": null
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "_normalizeOptions",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#_normalizeOptions",
    "access": "protected",
    "description": "Normalizes the options received by the command in order to resolve \"impossible combinations\",\nlike trying to analyze a target that is not for bundling or trying to inspect a browser\ntarget.",
    "lineNumber": 141,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CLIBuildCommandNormalizedOptions"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "_getNodeTargetValidations",
    "memberof": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateBuild.js~CLISHValidateBuildCommand#_getNodeTargetValidations",
    "access": "protected",
    "description": "Get validations for an specific Node target based on the options the command recevied (and\nnormalized).",
    "lineNumber": 164,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "CLIBuildCommandNormalizedOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command (normalized) options."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "invalidBuild",
        "description": "Whether or not there's no reason for building the target."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "invalidWatch",
        "description": "Whether or not there's no reason for watching the target."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A dictionary of \"validation flags\"."
    }
  },
  {
    "__docId__": 482,
    "kind": "variable",
    "name": "cliSHValidateBuildCommand",
    "memberof": "src/services/cli/cliSHValidateBuild.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateBuild.js~cliSHValidateBuildCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateBuild.js",
    "importStyle": "{cliSHValidateBuildCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHValidateBuildCommand` as the `cliSHValidateBuildCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHValidateBuildCommand);\n// Getting access to the service instance\nconst cliSHValidateBuildCommand = container.get('cliSHValidateBuildCommand');"
    ],
    "lineNumber": 193,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 483,
    "kind": "file",
    "name": "src/services/cli/cliSHValidateInspect.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes before running the inspect command in order\n * to validate the arguments and throw any necessary error. The reason we do this in two separated\n * commands is that the shell script takes all the output of the run command and tries to execute\n * it, so we can't include execptions in there.\n * @extends {CLICommand}\n */\nclass CLISHValidateInspectCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Targets} targets To validate a target existence.\n   */\n  constructor(targets) {\n    super();\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-validate-inspect [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Validate the arguments before the shell executes the task';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and validate the target existence.\n   * @param {?string} name The name of the target.\n   * @throws {Error} If the target type is `browser`.\n   */\n  handle(name) {\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    if (target.is.browser) {\n      throw new Error(`'${target.name}' is not a Node target, so it can't be inspected`);\n    }\n\n    return target;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHValidateInspectCommand` as the `cliSHValidateInspectCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHValidateInspectCommand);\n * // Getting access to the service instance\n * const cliSHValidateInspectCommand = container.get('cliSHValidateInspectCommand');\n * @type {Provider}\n */\nconst cliSHValidateInspectCommand = provider((app) => {\n  app.set('cliSHValidateInspectCommand', () => new CLISHValidateInspectCommand(\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHValidateInspectCommand,\n  cliSHValidateInspectCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHValidateInspect.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 484,
    "kind": "class",
    "name": "CLISHValidateInspectCommand",
    "memberof": "src/services/cli/cliSHValidateInspect.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateInspect.js",
    "importStyle": "{CLISHValidateInspectCommand}",
    "description": "This is a private command the shell script executes before running the inspect command in order\nto validate the arguments and throw any necessary error. The reason we do this in two separated\ncommands is that the shell script takes all the output of the run command and tries to execute\nit, so we can't include execptions in there.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 485,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To validate a target existence."
      }
    ]
  },
  {
    "__docId__": 486,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 487,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 488,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 489,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 490,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 491,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateInspect.js~CLISHValidateInspectCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and validate the target existence.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target type is `browser`."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 492,
    "kind": "variable",
    "name": "cliSHValidateInspectCommand",
    "memberof": "src/services/cli/cliSHValidateInspect.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateInspect.js~cliSHValidateInspectCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateInspect.js",
    "importStyle": "{cliSHValidateInspectCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHValidateInspectCommand` as the `cliSHValidateInspectCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHValidateInspectCommand);\n// Getting access to the service instance\nconst cliSHValidateInspectCommand = container.get('cliSHValidateInspectCommand');"
    ],
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 493,
    "kind": "file",
    "name": "src/services/cli/cliSHValidateRun.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes before running the run command in order to\n * validate the arguments and throw any necessary error. The reason we do this in two separated\n * commands is that the shell script takes all the output of the run command and tries to execute\n * it, so we can't include execptions in there.\n * @extends {CLICommand}\n */\nclass CLISHValidateRunCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {Targets} targets To validate a target existence.\n   */\n  constructor(targets) {\n    super();\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-validate-run [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Validate the arguments before the shell executes the task';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the run command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n  }\n  /**\n   * Handle the execution of the command and validate the target existence.\n   * @param {?string} name The name of the target.\n   */\n  handle(name) {\n    return name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHValidateRunCommand` as the `cliSHValidateRunCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHValidateRunCommand);\n * // Getting access to the service instance\n * const cliSHValidateRunCommand = container.get('cliSHValidateRunCommand');\n * @type {Provider}\n */\nconst cliSHValidateRunCommand = provider((app) => {\n  app.set('cliSHValidateRunCommand', () => new CLISHValidateRunCommand(\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHValidateRunCommand,\n  cliSHValidateRunCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHValidateRun.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 494,
    "kind": "class",
    "name": "CLISHValidateRunCommand",
    "memberof": "src/services/cli/cliSHValidateRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateRun.js",
    "importStyle": "{CLISHValidateRunCommand}",
    "description": "This is a private command the shell script executes before running the run command in order to\nvalidate the arguments and throw any necessary error. The reason we do this in two separated\ncommands is that the shell script takes all the output of the run command and tries to execute\nit, so we can't include execptions in there.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 495,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To validate a target existence."
      }
    ]
  },
  {
    "__docId__": 496,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 497,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 498,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 499,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 500,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the run command.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateRun.js~CLISHValidateRunCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and validate the target existence.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 502,
    "kind": "variable",
    "name": "cliSHValidateRunCommand",
    "memberof": "src/services/cli/cliSHValidateRun.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateRun.js~cliSHValidateRunCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateRun.js",
    "importStyle": "{cliSHValidateRunCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHValidateRunCommand` as the `cliSHValidateRunCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHValidateRunCommand);\n// Getting access to the service instance\nconst cliSHValidateRunCommand = container.get('cliSHValidateRunCommand');"
    ],
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 503,
    "kind": "file",
    "name": "src/services/cli/cliSHValidateWatch.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a private command the shell script executes before running the watch command in order to\n * validate the arguments and throw any necessary error. The reason we do this in two separated\n * commands is that the shell script takes all the output of the run command and tries to execute\n * it, so we can't include execptions in there.\n * @extends {CLICommand}\n */\nclass CLISHValidateWatchCommand extends CLICommand {\n  /**\n   * @param {Targets} targets To validate a target existence.\n   */\n  constructor(targets) {\n    super();\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-validate-watch [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Validate the arguments before the shell executes the task';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the watch command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n  }\n  /**\n   * Handle the execution of the command and validate the target existence.\n   * @param {?string} name The name of the target.\n   */\n  handle(name) {\n    return name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHValidateWatchCommand` as the `cliSHValidateWatchCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHValidateWatchCommand);\n * // Getting access to the service instance\n * const cliSHValidateWatchCommand = container.get('cliSHValidateWatchCommand');\n * @type {Provider}\n */\nconst cliSHValidateWatchCommand = provider((app) => {\n  app.set('cliSHValidateWatchCommand', () => new CLISHValidateWatchCommand(\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHValidateWatchCommand,\n  cliSHValidateWatchCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHValidateWatch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 504,
    "kind": "class",
    "name": "CLISHValidateWatchCommand",
    "memberof": "src/services/cli/cliSHValidateWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateWatch.js",
    "importStyle": "{CLISHValidateWatchCommand}",
    "description": "This is a private command the shell script executes before running the watch command in order to\nvalidate the arguments and throw any necessary error. The reason we do this in two separated\ncommands is that the shell script takes all the output of the run command and tries to execute\nit, so we can't include execptions in there.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 505,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To validate a target existence."
      }
    ]
  },
  {
    "__docId__": 506,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 507,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 508,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 509,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 510,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the watch command.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHValidateWatch.js~CLISHValidateWatchCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and validate the target existence.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "variable",
    "name": "cliSHValidateWatchCommand",
    "memberof": "src/services/cli/cliSHValidateWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHValidateWatch.js~cliSHValidateWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHValidateWatch.js",
    "importStyle": "{cliSHValidateWatchCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHValidateWatchCommand` as the `cliSHValidateWatchCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHValidateWatchCommand);\n// Getting access to the service instance\nconst cliSHValidateWatchCommand = container.get('cliSHValidateWatchCommand');"
    ],
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 513,
    "kind": "file",
    "name": "src/services/cli/cliSHWatch.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is the _'real watch command'_. This is a private command the shell script executes in order\n * to get a list of commands it should execute.\n * @extends {CLICommand}\n */\nclass CLISHWatchCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @param {CLIBuildCommand} cliBuildCommand The run command is actually an alias for the build\n   *                                          command with the `--watch` option flag set to true.\n   * @param {Targets}         targets         To get the name of the default target if no other is\n   *                                          specified.\n   */\n  constructor(cliBuildCommand, targets) {\n    super();\n    /**\n     * A local reference for the `cliBuildCommand` service.\n     * @type {CLIBuildCommand}\n     */\n    this.cliBuildCommand = cliBuildCommand;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'sh-watch [target]';\n    /**\n     * A description of the command, just to follow the interface as the command won't show up on\n     * the help interface.\n     * @type {string}\n     */\n    this.description = 'Get the build commands for the shell program to execute';\n    /**\n     * Hide the command from the help interface.\n     * @type {boolean}\n     */\n    this.hidden = true;\n    /**\n     * Enable unknown options so other services can customize the watch command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n  }\n  /**\n   * Handle the execution of the command and outputs the list of commands to run.\n   * @param {?string} name           The name of the target.\n   * @param {Command} command        The executed command (sent by `commander`).\n   * @param {Object}  options        The command options.\n   * @param {Object}  unknownOptions A dictionary of extra options that command may have received.\n   */\n  handle(name, command, options, unknownOptions) {\n    const { type } = options;\n    const target = name ?\n      // If the target doesn't exist, this will throw an error.\n      this.targets.getTarget(name) :\n      // Get the default target or throw an error if the project doesn't have targets.\n      this.targets.getDefaultTarget();\n\n    this.output(this.cliBuildCommand.generate(Object.assign(\n      {},\n      unknownOptions,\n      {\n        target: target.name,\n        type,\n        watch: true,\n      }\n    )));\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLISHWatchCommand` as the `cliSHWatchCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliSHWatchCommand);\n * // Getting access to the service instance\n * const cliSHWatchCommand = container.get('cliSHWatchCommand');\n * @type {Provider}\n */\nconst cliSHWatchCommand = provider((app) => {\n  app.set('cliSHWatchCommand', () => new CLISHWatchCommand(\n    app.get('cliBuildCommand'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  CLISHWatchCommand,\n  cliSHWatchCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliSHWatch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 514,
    "kind": "class",
    "name": "CLISHWatchCommand",
    "memberof": "src/services/cli/cliSHWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHWatch.js",
    "importStyle": "{CLISHWatchCommand}",
    "description": "This is the _'real watch command'_. This is a private command the shell script executes in order\nto get a list of commands it should execute.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 515,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "CLIBuildCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "cliBuildCommand",
        "description": "The run command is actually an alias for the build\n                                         command with the `--watch` option flag set to true."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the name of the default target if no other is\n                                         specified."
      }
    ]
  },
  {
    "__docId__": 516,
    "kind": "member",
    "name": "cliBuildCommand",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#cliBuildCommand",
    "access": "public",
    "description": "A local reference for the `cliBuildCommand` service.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "CLIBuildCommand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 517,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 518,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 519,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#description",
    "access": "public",
    "description": "A description of the command, just to follow the interface as the command won't show up on\nthe help interface.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 520,
    "kind": "member",
    "name": "hidden",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#hidden",
    "access": "public",
    "description": "Hide the command from the help interface.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 521,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the watch command.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/cliSHWatch.js~CLISHWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliSHWatch.js~CLISHWatchCommand#handle",
    "access": "public",
    "description": "Handle the execution of the command and outputs the list of commands to run.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The executed command (sent by `commander`)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The command options."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "unknownOptions",
        "description": "A dictionary of extra options that command may have received."
      }
    ],
    "return": null
  },
  {
    "__docId__": 523,
    "kind": "variable",
    "name": "cliSHWatchCommand",
    "memberof": "src/services/cli/cliSHWatch.js",
    "static": true,
    "longname": "src/services/cli/cliSHWatch.js~cliSHWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliSHWatch.js",
    "importStyle": "{cliSHWatchCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLISHWatchCommand` as the `cliSHWatchCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliSHWatchCommand);\n// Getting access to the service instance\nconst cliSHWatchCommand = container.get('cliSHWatchCommand');"
    ],
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 524,
    "kind": "file",
    "name": "src/services/cli/cliWatch.js",
    "content": "const { provider } = require('jimple');\nconst CLICommand = require('../../abstracts/cliCommand');\n/**\n * This is a fake command the app uses to show the information of the watch task. In reality, this\n * command is handled by a shell script.\n * @extends {CLICommand}\n */\nclass CLIWatchCommand extends CLICommand {\n  /**\n   * Class constructor.\n   * @ignore\n   */\n  constructor() {\n    super();\n    /**\n     * The instruction needed to trigger the command.\n     * @type {string}\n     */\n    this.command = 'watch [target]';\n    /**\n     * A description of the command for the help interface.\n     * @type {string}\n     */\n    this.description = 'Run a target on a development build type';\n    /**\n     * Enable unknown options so other services can customize the watch command.\n     * @type {boolean}\n     */\n    this.allowUnknownOptions = true;\n    this.addOption(\n      'type',\n      '-t, --type [type]',\n      'Which build type: development (default) or production',\n      'development'\n    );\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `CLIWatchCommand` as the `cliWatchCommand` service.\n * @example\n * // Register it on the container\n * container.register(cliWatchCommand);\n * // Getting access to the service instance\n * const cliWatchCommand = container.get('cliWatchCommand');\n * @type {Provider}\n */\nconst cliWatchCommand = provider((app) => {\n  app.set('cliWatchCommand', () => new CLIWatchCommand());\n});\n\nmodule.exports = {\n  CLIWatchCommand,\n  cliWatchCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/cliWatch.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 525,
    "kind": "class",
    "name": "CLIWatchCommand",
    "memberof": "src/services/cli/cliWatch.js",
    "static": true,
    "longname": "src/services/cli/cliWatch.js~CLIWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliWatch.js",
    "importStyle": "{CLIWatchCommand}",
    "description": "This is a fake command the app uses to show the information of the watch task. In reality, this\ncommand is handled by a shell script.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "CLICommand"
    ]
  },
  {
    "__docId__": 526,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/cliWatch.js~CLIWatchCommand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/cliWatch.js~CLIWatchCommand#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "ignore": true
  },
  {
    "__docId__": 527,
    "kind": "member",
    "name": "command",
    "memberof": "src/services/cli/cliWatch.js~CLIWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliWatch.js~CLIWatchCommand#command",
    "access": "public",
    "description": "The instruction needed to trigger the command.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 528,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/cliWatch.js~CLIWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliWatch.js~CLIWatchCommand#description",
    "access": "public",
    "description": "A description of the command for the help interface.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 529,
    "kind": "member",
    "name": "allowUnknownOptions",
    "memberof": "src/services/cli/cliWatch.js~CLIWatchCommand",
    "static": false,
    "longname": "src/services/cli/cliWatch.js~CLIWatchCommand#allowUnknownOptions",
    "access": "public",
    "description": "Enable unknown options so other services can customize the watch command.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 530,
    "kind": "variable",
    "name": "cliWatchCommand",
    "memberof": "src/services/cli/cliWatch.js",
    "static": true,
    "longname": "src/services/cli/cliWatch.js~cliWatchCommand",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/cliWatch.js",
    "importStyle": "{cliWatchCommand}",
    "description": "The service provider that once registered on the app container will set an instance of\n`CLIWatchCommand` as the `cliWatchCommand` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cliWatchCommand);\n// Getting access to the service instance\nconst cliWatchCommand = container.get('cliWatchCommand');"
    ],
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 531,
    "kind": "file",
    "name": "src/services/cli/generators/index.js",
    "content": "const { projectConfigurationFileGenerator } = require('./projectConfigurationFile');\nconst { targetHTMLGenerator } = require('./targetHTML');\n\nmodule.exports = {\n  targetHTMLGenerator,\n  projectConfigurationFileGenerator,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/generators/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 532,
    "kind": "file",
    "name": "src/services/cli/generators/projectConfigurationFile.js",
    "content": "const ObjectUtils = require('wootils/shared/objectUtils');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\nconst CLISubCommand = require('../../../abstracts/cliSubCommand');\n/**\n * This is a CLI generator that allows the user to create a configuration file with all the\n * default settings and all the information projext assumes about the project.\n * @extends {CLISubCommand}\n */\nclass ProjectConfigurationFileGenerator extends CLISubCommand {\n  /**\n   * Class constructor.\n   * @param {Logger}                       appLogger            To inform the user when the file\n   *                                                            has been generated, or if something\n   *                                                            went wrong.\n   * @param {Prompt}                       appPrompt            To ask the user the path to the\n   *                                                            file.\n   * @param {PathUtils}                    pathUtils            To build the absolute path for the\n   *                                                            file.\n   * @param {ProjectConfigurationSettings} projectConfiguration To get all the settings that are\n   *                                                            going to go on the file.\n   * @param {Utils}                        utils                To format some of the options\n   *                                                            into human readable descriptions.\n   */\n  constructor(appLogger, appPrompt, pathUtils, projectConfiguration, utils) {\n    super();\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `appPrompt` service.\n     * @type {Prompt}\n     */\n    this.appPrompt = appPrompt;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `utils` service.\n     * @type {Utils}\n     */\n    this.utils = utils;\n    /**\n     * The resource type the user will have to select on the CLI command that manages the\n     * generator.\n     * @type {string}\n     */\n    this.name = 'config';\n    /**\n     * A short description of what the generator does.\n     * @type {string}\n     */\n    this.description = 'Generate a configuration based on what projext knows of your project';\n    /**\n     * A list with the names the configuration file can have and that projext supports.\n     * @type {Array}\n     * @ignore\n     * @access protected\n     */\n    this._nameOptions = [\n      'projext.config.js',\n      'config/projext.config.js',\n      'config/project.config.js',\n    ];\n\n    this.addOption(\n      'all',\n      '-a, --all',\n      'Save the file with all the project settings instead of just the targets',\n      false\n    );\n    this.addOption(\n      'include',\n      '-i, --include',\n      'A list of directory-like paths of the specific settings you want to include. ' +\n        'To use without -all',\n      'targets'\n    );\n    this.addOption(\n      'exclude',\n      '-e, --exclude',\n      'A list of directory-like paths of the specific settings you want to exclude. ' +\n        'To use with -all',\n      ''\n    );\n  }\n  /**\n   * This method first prompts the user for the name of configuration file, it needs to be one\n   * supported by projext, after that, if the file already exists it asks for confirmation, and then\n   * it finally writes it.\n   * @param {Object}  options         A dictionary with the received options for the generator.\n   * @param {boolean} options.all     Whether to save all the settings or just the targets.\n   * @param {?string} options.include A list of directory-like paths for specific settings to save.\n   * @param {?string} options.exclude A list of directory-like paths for specific settings to\n   *                                  ignore.\n   * @return {Promise<undefined,Error>}\n   */\n  handle(options = {}) {\n    // Define the variable for the promise that will be returned.\n    let result;\n    // Define the variable for the object that will contain the settings to write.\n    let settings;\n\n    // Validate that the required settings exist.\n    try {\n      settings = options.all ?\n        this._getAllSettings(options.exclude) :\n        this._getSettings(options.include);\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    // Continue with the execution only if the wasn't an error obtaining the settings.\n    if (!result) {\n      // Get the first name option to use as default.\n      const [firstNameOption] = this._nameOptions;\n      /**\n       * Format the list so it can be added as an error message in case the user selects an\n       * invalid name.\n       */\n      const nameOptionsStr = this.utils.humanReadableList(\n        this._nameOptions.map((option) => `'${option}'`)\n      );\n      // Define the prompt schema.\n      const schema = {\n        filename: {\n          default: firstNameOption,\n          description: 'Filename',\n          message: `It can only be one of these: ${nameOptionsStr}`,\n          required: true,\n          // Validate that the selected name is supported by projext.\n          conform: (value) => this._nameOptions.includes(value.toLowerCase()),\n          // Always save the selected name on lower case.\n          before: (value) => value.toLowerCase(),\n        },\n        overwrite: {\n          type: 'boolean',\n          default: 'yes',\n          description: 'Overwrite existing file',\n          required: true,\n          // Only ask for an overwrite confirmation if the file already exists.\n          ask: () => {\n            const filename = this.appPrompt.getValue('filename');\n            return fs.pathExistsSync(this.pathUtils.join(filename));\n          },\n        },\n      };\n\n      let filepath;\n      let creating = false;\n      // Ask the user...\n      return this.appPrompt.ask(schema)\n      .then((results) => {\n        // Build the path to the file.\n        filepath = this.pathUtils.join(results.filename);\n        // Check if the file already exists.\n        const exists = fs.pathExistsSync(filepath);\n        let nextStep;\n        // If the file doesn't exist or if it exists but the user choose to overwrite it...\n        if (!exists || (exists && results.overwrite)) {\n          creating = true;\n          // ...write the file.\n          nextStep = this._writeSettings(filepath, settings);\n        }\n\n        return nextStep;\n      })\n      .then(() => {\n        // If the file was created, inform the user.\n        if (creating) {\n          this.appLogger.success(`The configuration file was successfully generted: ${filepath}`);\n        }\n      })\n      .catch((error) => {\n        let nextStep;\n        // If the process failed and it wasn't because the user canceled the input...\n        if (error.message !== 'canceled') {\n          // ...show the error.\n          this.appLogger.error('There was an error while generating the configuration file');\n          nextStep = Promise.reject(error);\n        }\n\n        return nextStep;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get all the settings on the project configuration, with the possibility of excluding some\n   * of them.\n   * @param {string} [exclude=''] A list of comma separated paths for settings that should be\n   *                              excluded.\n   *                              For example: `'targetsTemplates/browser,copy,version'`.\n   * @return {Object}\n   * @ignore\n   * @access protected\n   */\n  _getAllSettings(exclude = '') {\n    return exclude\n    .split(',')\n    .reduce(\n      (obj, objPath) => (objPath ? ObjectUtils.delete(obj, objPath, '/', true, true) : obj),\n      ObjectUtils.copy(this.projectConfiguration)\n    );\n  }\n  /**\n   * Get specific settings from the project configuration.\n   * @param {string} [settings='targets'] A list of comma separated paths for the required settings\n   *                                      For example: `'targetsTemplates/browser,copy,version'`.\n   * @return {Object}\n   * @ignore\n   * @access protected\n   */\n  _getSettings(settings = 'targets') {\n    return settings\n    .split(',')\n    .reduce(\n      (obj, objPath) => {\n        const value = ObjectUtils.get(this.projectConfiguration, objPath, '/', true);\n        return ObjectUtils.set(obj, objPath, value, '/', true);\n      },\n      {}\n    );\n  }\n  /**\n   * Formats a settings dictionary in order to write it as a JS object on an specific file.\n   * @param {string} filepath The path to the file where the configuration should be written.\n   * @param {Object} settings The dictionary of settings to write on the file.\n   * @return {Promise<undefined,Error>}\n   * @private\n   * @access protected\n   */\n  _writeSettings(filepath, settings) {\n    // Convert the configuration into a string with proper indentation.\n    const jsonIndentation = 2;\n    const json = JSON.stringify(settings, undefined, jsonIndentation)\n    // Escape single quotes.\n    .replace(/'/g, '\\\\\\'')\n    // Replace double quotes with single quotes.\n    .replace(/\"/g, '\\'')\n    // Remove single quotes from keys.\n    .replace(/^(\\s+)?(')(\\w+)('): /mg, '$1$3: ')\n    /**\n     * Add trailing commas. The reason the regex is executed twice is because matches can't\n     * intersect other matches, and since the regex uses a closing symbol as delimiter, that same\n     * delimiter can't be fixed unless we run the regex again.\n     */\n    .replace(/([\\]|}|\\w|'])(\\n(?:\\s+)?[}|\\]])/g, '$1,$2')\n    .replace(/([\\]|}])(\\n(?:\\s+)?[}|\\]])/g, '$1,$2');\n\n    const template = `module.exports = ${json};\\n`;\n\n    return fs.writeFile(filepath, template);\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `ProjectConfigurationFileGenerator` as the `projectConfigurationFileGenerator` service.\n * @example\n * // Register it on the container\n * container.register(projectConfigurationFileGenerator);\n * // Getting access to the service instance\n * const projectConfigurationFileGenerator = container.get('projectConfigurationFileGenerator');\n * @type {Provider}\n */\nconst projectConfigurationFileGenerator = provider((app) => {\n  app.set('projectConfigurationFileGenerator', () => new ProjectConfigurationFileGenerator(\n    app.get('appLogger'),\n    app.get('appPrompt'),\n    app.get('pathUtils'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('utils')\n  ));\n});\n\nmodule.exports = {\n  ProjectConfigurationFileGenerator,\n  projectConfigurationFileGenerator,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/generators/projectConfigurationFile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 533,
    "kind": "class",
    "name": "ProjectConfigurationFileGenerator",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js",
    "static": true,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/generators/projectConfigurationFile.js",
    "importStyle": "{ProjectConfigurationFileGenerator}",
    "description": "This is a CLI generator that allows the user to create a configuration file with all the\ndefault settings and all the information projext assumes about the project.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "CLISubCommand"
    ]
  },
  {
    "__docId__": 534,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To inform the user when the file\n                                                           has been generated, or if something\n                                                           went wrong."
      },
      {
        "nullable": null,
        "types": [
          "Prompt"
        ],
        "spread": false,
        "optional": false,
        "name": "appPrompt",
        "description": "To ask the user the path to the\n                                                           file."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build the absolute path for the\n                                                           file."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To get all the settings that are\n                                                           going to go on the file."
      },
      {
        "nullable": null,
        "types": [
          "Utils"
        ],
        "spread": false,
        "optional": false,
        "name": "utils",
        "description": "To format some of the options\n                                                           into human readable descriptions."
      }
    ]
  },
  {
    "__docId__": 535,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 536,
    "kind": "member",
    "name": "appPrompt",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#appPrompt",
    "access": "public",
    "description": "A local reference for the `appPrompt` service.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "Prompt"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 537,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 538,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 539,
    "kind": "member",
    "name": "utils",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#utils",
    "access": "public",
    "description": "A local reference for the `utils` service.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "Utils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 540,
    "kind": "member",
    "name": "name",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#name",
    "access": "public",
    "description": "The resource type the user will have to select on the CLI command that manages the\ngenerator.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 541,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#description",
    "access": "public",
    "description": "A short description of what the generator does.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 542,
    "kind": "member",
    "name": "_nameOptions",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#_nameOptions",
    "access": "protected",
    "description": "A list with the names the configuration file can have and that projext supports.",
    "lineNumber": 69,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#handle",
    "access": "public",
    "description": "This method first prompts the user for the name of configuration file, it needs to be one\nsupported by projext, after that, if the file already exists it asks for confirmation, and then\nit finally writes it.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "A dictionary with the received options for the generator."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "options.all",
        "description": "Whether to save all the settings or just the targets."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.include",
        "description": "A list of directory-like paths for specific settings to save."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.exclude",
        "description": "A list of directory-like paths for specific settings to\n                                 ignore."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "_getAllSettings",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#_getAllSettings",
    "access": "protected",
    "description": "Get all the settings on the project configuration, with the possibility of excluding some\nof them.",
    "lineNumber": 208,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "exclude",
        "description": "A list of comma separated paths for settings that should be\n                             excluded.\n                             For example: `'targetsTemplates/browser,copy,version'`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "_getSettings",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#_getSettings",
    "access": "protected",
    "description": "Get specific settings from the project configuration.",
    "lineNumber": 224,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'targets'",
        "defaultRaw": "'targets'",
        "name": "settings",
        "description": "A list of comma separated paths for the required settings\n                                     For example: `'targetsTemplates/browser,copy,version'`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 546,
    "kind": "method",
    "name": "_writeSettings",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~ProjectConfigurationFileGenerator#_writeSettings",
    "access": "protected",
    "description": "Formats a settings dictionary in order to write it as a JS object on an specific file.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file where the configuration should be written."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "The dictionary of settings to write on the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 547,
    "kind": "variable",
    "name": "projectConfigurationFileGenerator",
    "memberof": "src/services/cli/generators/projectConfigurationFile.js",
    "static": true,
    "longname": "src/services/cli/generators/projectConfigurationFile.js~projectConfigurationFileGenerator",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/generators/projectConfigurationFile.js",
    "importStyle": "{projectConfigurationFileGenerator}",
    "description": "The service provider that once registered on the app container will set an instance of\n`ProjectConfigurationFileGenerator` as the `projectConfigurationFileGenerator` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(projectConfigurationFileGenerator);\n// Getting access to the service instance\nconst projectConfigurationFileGenerator = container.get('projectConfigurationFileGenerator');"
    ],
    "lineNumber": 276,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 548,
    "kind": "file",
    "name": "src/services/cli/generators/targetHTML.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\nconst CLISubCommand = require('../../../abstracts/cliSubCommand');\n/**\n * This is a CLI generator that allows the user to create an HTML file for a browser target.\n * What it does is to force projext to create the default HTML file it would create if the target\n * didn't have one and then it moves it to the target directory.\n * @extends {CLISubCommand}\n */\nclass TargetHTMLGenerator extends CLISubCommand {\n  /**\n   * Class constructor.\n   * @param {Logger}      appLogger   To inform the user when the file has been generated, or if\n   *                                  something went wrong.\n   * @param {Prompt}      appPrompt   To ask the user for the arget name and the file path.\n   * @param {Targets}     targets     To get the selected target information.\n   * @param {TargetsHTML} targetsHTML To generate the HTML file.\n   */\n  constructor(appLogger, appPrompt, targets, targetsHTML) {\n    super();\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `appPrompt` service.\n     * @type {Prompt}\n     */\n    this.appPrompt = appPrompt;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    /**\n     * A local reference for the `targetsHTML` service.\n     * @type {TargetsHTML}\n     */\n    this.targetsHTML = targetsHTML;\n    /**\n     * The resource type the user will have to select on the CLI command that manages the\n     * generator.\n     * @type {string}\n     */\n    this.name = 'html';\n    /**\n     * A short description of what the generator does.\n     * @type {string}\n     */\n    this.description = 'Generate a browser target HTML template';\n  }\n  /**\n   * This method first prompts the user for information about the target and the file that is\n   * going to create, then uses the {@link TargetsHTML} to create a _\"default HTML file\"_, and it\n   * finally moves it to the selected path.\n   * @return {Promise<undefined,Error>}\n   */\n  handle() {\n    // Get the _\"default browser target\"_.\n    const defaultTarget = this.targets.getDefaultTarget('browser');\n    // Define the prompt schema.\n    const schema = {\n      target: {\n        default: defaultTarget.name,\n        description: 'Target',\n        message: 'It should be the name of valid browser target',\n        required: true,\n        // Validate that the selected target exists and its type is `browser`.\n        conform: (value) => (\n          this.targets.targetExists(value) &&\n          this.targets.getTarget(value).is.browser\n        ),\n      },\n      filename: {\n        default: defaultTarget.html.template,\n        // Validate the name of the HTML file.\n        pattern: /^[a-zA-Z0-9\\.-_]+\\.html$/i,\n        description: 'Filename',\n        message: 'It should be a valid name for an HTML file',\n        required: true,\n      },\n      overwrite: {\n        type: 'boolean',\n        default: 'yes',\n        description: 'Overwrite existing file',\n        required: true,\n        // Only ask for an overwrite confirmation if the file already exists.\n        ask: () => {\n          const target = this.targets.getTarget(this.appPrompt.getValue('target'));\n          const filename = this.appPrompt.getValue('filename');\n          return fs.pathExistsSync(path.join(target.paths.source, filename));\n        },\n      },\n    };\n\n    let filepath;\n    let moving = false;\n    // Ask the user...\n    return this.appPrompt.ask(schema)\n    .then((results) => {\n      // Get the selected target information.\n      const target = this.targets.getTarget(results.target);\n      // Build the HTML file absolute path.\n      filepath = path.join(target.paths.source, results.filename);\n      // Check if the file already exists.\n      const exists = fs.pathExistsSync(filepath);\n      let nextStep;\n      // If the file doesn't exist or if it exists but the user choose to overwrite it...\n      if (!exists || (exists && results.overwrite)) {\n        // Generate it on the temp directory.\n        const tempPath = this.targetsHTML.getFilepath(target, true);\n        moving = true;\n        // Move the HTML file from the temp directory to the selected path.\n        nextStep = fs.move(tempPath, filepath);\n      }\n\n      return nextStep;\n    })\n    .then(() => {\n      // If the file was successfully moved, inform the user.\n      if (moving) {\n        this.appLogger.success(`The HTML file was successfully generated: ${filepath}`);\n      }\n    })\n    .catch((error) => {\n      let result;\n      // If the process failed and it wasn't because the user canceled the input...\n      if (error.message !== 'canceled') {\n        // ...show the error.\n        this.appLogger.error('There was an error while generating the HTML file');\n        result = Promise.reject(error);\n      }\n\n      return result;\n    });\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `TargetHTMLGenerator` as the `targetHTMLGenerator` service.\n * @example\n * // Register it on the container\n * container.register(targetHTMLGenerator);\n * // Getting access to the service instance\n * const targetHTMLGenerator = container.get('targetHTMLGenerator');\n * @type {Provider}\n */\nconst targetHTMLGenerator = provider((app) => {\n  app.set('targetHTMLGenerator', () => new TargetHTMLGenerator(\n    app.get('appLogger'),\n    app.get('appPrompt'),\n    app.get('targets'),\n    app.get('targetsHTML')\n  ));\n});\n\nmodule.exports = {\n  TargetHTMLGenerator,\n  targetHTMLGenerator,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/generators/targetHTML.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 549,
    "kind": "class",
    "name": "TargetHTMLGenerator",
    "memberof": "src/services/cli/generators/targetHTML.js",
    "static": true,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/generators/targetHTML.js",
    "importStyle": "{TargetHTMLGenerator}",
    "description": "This is a CLI generator that allows the user to create an HTML file for a browser target.\nWhat it does is to force projext to create the default HTML file it would create if the target\ndidn't have one and then it moves it to the target directory.",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "CLISubCommand"
    ]
  },
  {
    "__docId__": 550,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To inform the user when the file has been generated, or if\n                                 something went wrong."
      },
      {
        "nullable": null,
        "types": [
          "Prompt"
        ],
        "spread": false,
        "optional": false,
        "name": "appPrompt",
        "description": "To ask the user for the arget name and the file path."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the selected target information."
      },
      {
        "nullable": null,
        "types": [
          "TargetsHTML"
        ],
        "spread": false,
        "optional": false,
        "name": "targetsHTML",
        "description": "To generate the HTML file."
      }
    ]
  },
  {
    "__docId__": 551,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 552,
    "kind": "member",
    "name": "appPrompt",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#appPrompt",
    "access": "public",
    "description": "A local reference for the `appPrompt` service.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Prompt"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 553,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 554,
    "kind": "member",
    "name": "targetsHTML",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#targetsHTML",
    "access": "public",
    "description": "A local reference for the `targetsHTML` service.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "TargetsHTML"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 555,
    "kind": "member",
    "name": "name",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#name",
    "access": "public",
    "description": "The resource type the user will have to select on the CLI command that manages the\ngenerator.",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 556,
    "kind": "member",
    "name": "description",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#description",
    "access": "public",
    "description": "A short description of what the generator does.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 557,
    "kind": "method",
    "name": "handle",
    "memberof": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/cli/generators/targetHTML.js~TargetHTMLGenerator#handle",
    "access": "public",
    "description": "This method first prompts the user for information about the target and the file that is\ngoing to create, then uses the {@link TargetsHTML} to create a _\"default HTML file\"_, and it\nfinally moves it to the selected path.",
    "lineNumber": 60,
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 558,
    "kind": "variable",
    "name": "targetHTMLGenerator",
    "memberof": "src/services/cli/generators/targetHTML.js",
    "static": true,
    "longname": "src/services/cli/generators/targetHTML.js~targetHTMLGenerator",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/cli/generators/targetHTML.js",
    "importStyle": "{targetHTMLGenerator}",
    "description": "The service provider that once registered on the app container will set an instance of\n`TargetHTMLGenerator` as the `targetHTMLGenerator` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targetHTMLGenerator);\n// Getting access to the service instance\nconst targetHTMLGenerator = container.get('targetHTMLGenerator');"
    ],
    "lineNumber": 150,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 559,
    "kind": "file",
    "name": "src/services/cli/index.js",
    "content": "const { cliWithName, cli } = require('./cli');\nconst { cliAnalyzeCommand } = require('./cliAnalyze');\nconst { cliBuildCommand } = require('./cliBuild');\nconst { cliCleanCommand } = require('./cliClean');\nconst { cliCopyProjectFilesCommand } = require('./cliCopyProjectFiles');\nconst { cliGenerateCommand } = require('./cliGenerate');\nconst { cliInfoCommand } = require('./cliInfo');\nconst { cliInspectCommand } = require('./cliInspect');\nconst { cliRevisionCommand } = require('./cliRevision');\nconst { cliRunCommand } = require('./cliRun');\nconst { cliSHAnalyzeCommand } = require('./cliSHAnalyze');\nconst { cliSHBuildCommand } = require('./cliSHBuild');\nconst { cliSHCopyCommand } = require('./cliSHCopy');\nconst { cliSHInspectCommand } = require('./cliSHInspect');\nconst { cliSHNodeRunCommand } = require('./cliSHNodeRun');\nconst { cliSHNodeWatchCommand } = require('./cliSHNodeWatch');\nconst { cliSHRunCommand } = require('./cliSHRun');\nconst { cliSHTranspileCommand } = require('./cliSHTranspile');\nconst { cliSHValidateAnalyzeCommand } = require('./cliSHValidateAnalyze');\nconst { cliSHValidateBuildCommand } = require('./cliSHValidateBuild');\nconst { cliSHValidateInspectCommand } = require('./cliSHValidateInspect');\nconst { cliSHValidateRunCommand } = require('./cliSHValidateRun');\nconst { cliSHValidateWatchCommand } = require('./cliSHValidateWatch');\nconst { cliSHWatchCommand } = require('./cliSHWatch');\nconst { cliWatchCommand } = require('./cliWatch');\nconst cliGenerators = require('./generators');\n\nmodule.exports = {\n  cliWithName,\n  cli,\n  cliAnalyzeCommand,\n  cliBuildCommand,\n  cliCleanCommand,\n  cliCopyProjectFilesCommand,\n  cliGenerateCommand,\n  cliInfoCommand,\n  cliInspectCommand,\n  cliRevisionCommand,\n  cliRunCommand,\n  cliSHAnalyzeCommand,\n  cliSHBuildCommand,\n  cliSHCopyCommand,\n  cliSHInspectCommand,\n  cliSHNodeRunCommand,\n  cliSHNodeWatchCommand,\n  cliSHRunCommand,\n  cliSHTranspileCommand,\n  cliSHValidateAnalyzeCommand,\n  cliSHValidateBuildCommand,\n  cliSHValidateInspectCommand,\n  cliSHValidateRunCommand,\n  cliGenerators,\n  cliSHValidateWatchCommand,\n  cliSHWatchCommand,\n  cliWatchCommand,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/cli/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 560,
    "kind": "file",
    "name": "src/services/common/babelHelper.js",
    "content": "const { provider } = require('jimple');\n\n/**\n * @typedef {function} UpdateEnvPresetFunction\n * @param {Object} options The current options of the `env` preset.\n * @return {Object} The updated options for the `env` preset.\n */\n\n/**\n * A set of utilities to easily modify a Babel configuration.\n */\nclass BabelHelper {\n  /**\n   * Adds a plugin or a list of them to a Babel configuration. If the `plugins` option doesn't\n   * exist, the method will create it.\n   * @param {Object}       configuration The configuration to update.\n   * @param {string|Array} plugin        A plugin name or configuration `Array` (`[name, options]`),\n   *                                     or a list of them.\n   * @return {Object} The updated configuration.\n   */\n  static addPlugin(configuration, plugin) {\n    return this._addConfigurationItem(configuration, plugin, 'plugins');\n  }\n  /**\n   * Adds a preset or a list of them to a Babel configuration. If the `presets` option doesn't\n   * exist, the method will create it.\n   * @param {Object}       configuration The configuration to update.\n   * @param {string|Array} preset        A plugin name or configuration `Array` (`[name, options]`),\n   *                                     or a list of them.\n   * @return {Object} The updated configuration.\n   */\n  static addPreset(configuration, preset) {\n    return this._addConfigurationItem(configuration, preset, 'presets');\n  }\n  /**\n   * Update the options of the `env` preset on a Babel configuration. If the `presets` option\n   * doesn't exist, it will create one and add the preset. If `presets` exists and there's\n   * already an `env` preset, it will update it. But if `presets` exists but there's no `env`\n   * preset, it won't do anything.\n   * @param {Object}                  configuration The configuration to update.\n   * @param {UpdateEnvPresetFunction} updateFn      The function called in order to update the\n   *                                                `env` preset options.\n   * @return {Object} The updated configuration.\n   */\n  static updateEnvPreset(configuration, updateFn) {\n    // Get a new reference for the configuration.\n    const updatedConfiguration = Object.assign({}, configuration);\n    /**\n     * Define a flag that will eventually indicate whether the configuration needs the `presets`\n     * option or not.\n     */\n    let needsPresets = false;\n    // Define a flag that will eventually tell if the configuration has the `env` preset or not.\n    let hasEnvPreset = false;\n    /**\n     * Define the variable that, if the configuration has an `env` preset, indicate the index of\n     * the preset on the list.\n     */\n    let envPresetIndex = -1;\n    // Define the name of `env` preset; to avoid having the string on multiple places.\n    const envPresetName = '@babel/preset-env';\n    // If the configuration has presets...\n    if (updatedConfiguration.presets && updatedConfiguration.presets.length) {\n      // ...get the index of the `env` preset.\n      envPresetIndex = updatedConfiguration.presets.findIndex((preset) => {\n        const [presetName] = preset;\n        return presetName === envPresetName;\n      });\n      // Set the value of the flag that indicates if the `env` preset exists.\n      hasEnvPreset = envPresetIndex > -1;\n    } else {\n      // ...otherwise, set the flag that indicates the configuration doesn't have presets.\n      needsPresets = true;\n    }\n    /**\n     * This is the important part: Only proceed with the update if the configuration doesn't have\n     * presets or if it already has an `env` preset.\n     * If the configuration already has a list of presets that doesn't include the `env` preset,\n     * then it's probably a custom setup and adding it may cause conflicts.\n     */\n    if (needsPresets) {\n      /**\n       * Invoke the callback with an empty dictionary and add a new `presets` options with just the\n       * `env` preset.\n       */\n      updatedConfiguration.presets = [\n        [envPresetName, updateFn({})],\n      ];\n    } else if (hasEnvPreset) {\n      /**\n       * If the `env` preset already existed, invoke the callback with the current options in order\n       * to get new ones, define a new `env` preset and replace it on the list.\n       */\n      const [, currentEnvPresetOptions] = updatedConfiguration.presets[envPresetIndex];\n      updatedConfiguration.presets[envPresetIndex] = [\n        envPresetName,\n        updateFn(currentEnvPresetOptions),\n      ];\n    }\n    // Return the updated configuration.\n    return updatedConfiguration;\n  }\n  /**\n   * Add a required feature to the `env` preset options (it will go on the `include` option).\n   * @param {Object}       configuration The configuration to update.\n   * @param {string|Array} feature       The name of the feature to add or a list of them.\n   * @return {Object} The updated configuration.\n   */\n  static addEnvPresetFeature(configuration, feature) {\n    // Call the method to update the `env` preset options.\n    return this.updateEnvPreset(configuration, (options) => {\n      // Normalize the received `feature` parameter into an `Array`.\n      const features = Array.isArray(feature) ? feature : [feature];\n      // Generate a new reference for the options.\n      const updatedOptions = Object.assign({}, options);\n      // If the options already include a list of required features...\n      if (updatedOptions.include) {\n        // ...push only those that are not already present.\n        updatedOptions.include.push(\n          ...features.filter((name) => !updatedOptions.include.includes(name))\n        );\n      } else {\n        // ...otherwise, copy the entire list of features into the option.\n        updatedOptions.include = features.slice();\n      }\n\n      // Return the updated options.\n      return updatedOptions;\n    });\n  }\n  /**\n   * Disable the `env` preset `modules` option as it may cause conflict with some packages.\n   * @param {Object} configuration The configuration to update.\n   * @return {Object} The updated configuration.\n   */\n  static disableEnvPresetModules(configuration) {\n    // Call the method to update the `env` preset options.\n    return this.updateEnvPreset(\n      configuration,\n      // Return an updated dictionary of options with `modules` disabled.\n      (options) => Object.assign({}, options, { modules: false })\n    );\n  }\n  /**\n   * This is a helper method for adding things that share the same structure on a Babel\n   * configuration, like plugins and presets: They can be a `string` with the plugin/preset name\n   * or an `Array` with the name and its options.\n   * @param {Object}       configuration The configuration to update.\n   * @param {string|Array} item          An item name or configuration `Array` (`[name, options]`),\n   *                                     or a list of them.\n   * @param {string}       property      The name of the items property (like `plugins` or\n   *                                     `presets`).\n   * @return {Object} The updated configuration.\n   * @access protected\n   * @ignore\n   */\n  static _addConfigurationItem(configuration, item, property) {\n    let singleItem = true;\n    if (Array.isArray(item)) {\n      const [itemName, itemOptions] = item;\n      const itemAndOptionsLength = 2;\n      if (\n        item.length !== itemAndOptionsLength ||\n        typeof itemName !== 'string' ||\n        Array.isArray(itemOptions) ||\n        typeof itemOptions !== 'object'\n      ) {\n        singleItem = false;\n      }\n    }\n\n    // Normalize the received `item` parameter into an `Array`.\n    const items = singleItem ? [item] : item;\n    // Get a new reference for the configuration.\n    const updatedConfiguration = Object.assign({}, configuration);\n    // Define the variable for the list where the new plugin(s) will be added.\n    let newItemsList;\n    /**\n     * Define a variable that may contain a list of the existing items' names. The reason for\n     * this is that when adding new items (like presets or plugins), the method can validate if\n     * they already are on the list by calling `.includes`; otherwise, and because most of Babel\n     * items can be either a `string` or an `Array` (`[name, options]`), it would have to do a\n     * `.some` or `.find` with a callback that checks the type of the existing item.\n     */\n    let existingItems;\n    // If the configuration already has a property for the items...\n    if (updatedConfiguration[property]) {\n      // ...set the existing list as the one where the new items are going to be added.\n      newItemsList = updatedConfiguration[property];\n      // And generate a list with the names of the existing items.\n      existingItems = newItemsList.map((existingItem) => (\n        (Array.isArray(existingItem) ? existingItem[0] : existingItem)\n      ));\n    } else {\n      // ...otherwise, set a empty list.\n      newItemsList = [];\n    }\n    // Loop all the items that should be added.\n    items.forEach((itemInfo) => {\n      // Get the item name.\n      const name = Array.isArray(itemInfo) ? itemInfo[0] : itemInfo;\n      /**\n       * If the configuration didn't have the required items property, or the item is not on the\n       * list...\n       */\n      if (!existingItems || !existingItems.includes(name)) {\n        // ...add it to the list.\n        newItemsList.push(itemInfo);\n      }\n    });\n\n    // Replace the items property on the configuration with the updated list.\n    updatedConfiguration[property] = newItemsList;\n    // Return the updated configuration.\n    return updatedConfiguration;\n  }\n}\n/**\n * The service provider that once registered on the app container will set a reference of\n * `BabelHelper` as the `babelHelper` service.\n * @example\n * // Register it on the container\n * container.register(babelHelper);\n * // Getting access to the service reference\n * const babelHelper = container.get('babelHelper');\n * @type {Provider}\n */\nconst babelHelper = provider((app) => {\n  app.set('babelHelper', () => BabelHelper);\n});\n\nmodule.exports = {\n  BabelHelper,\n  babelHelper,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/babelHelper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 561,
    "kind": "typedef",
    "name": "UpdateEnvPresetFunction",
    "memberof": "src/services/common/babelHelper.js",
    "static": true,
    "longname": "src/services/common/babelHelper.js~UpdateEnvPresetFunction",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The current options of the `env` preset."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated options for the `env` preset."
    },
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "UpdateEnvPresetFunction"
    }
  },
  {
    "__docId__": 562,
    "kind": "class",
    "name": "BabelHelper",
    "memberof": "src/services/common/babelHelper.js",
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/babelHelper.js",
    "importStyle": "{BabelHelper}",
    "description": "A set of utilities to easily modify a Babel configuration.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 563,
    "kind": "method",
    "name": "addPlugin",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper.addPlugin",
    "access": "public",
    "description": "Adds a plugin or a list of them to a Babel configuration. If the `plugins` option doesn't\nexist, the method will create it.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "plugin",
        "description": "A plugin name or configuration `Array` (`[name, options]`),\n                                    or a list of them."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 564,
    "kind": "method",
    "name": "addPreset",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper.addPreset",
    "access": "public",
    "description": "Adds a preset or a list of them to a Babel configuration. If the `presets` option doesn't\nexist, the method will create it.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "preset",
        "description": "A plugin name or configuration `Array` (`[name, options]`),\n                                    or a list of them."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "updateEnvPreset",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper.updateEnvPreset",
    "access": "public",
    "description": "Update the options of the `env` preset on a Babel configuration. If the `presets` option\ndoesn't exist, it will create one and add the preset. If `presets` exists and there's\nalready an `env` preset, it will update it. But if `presets` exists but there's no `env`\npreset, it won't do anything.",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      },
      {
        "nullable": null,
        "types": [
          "UpdateEnvPresetFunction"
        ],
        "spread": false,
        "optional": false,
        "name": "updateFn",
        "description": "The function called in order to update the\n                                               `env` preset options."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 566,
    "kind": "method",
    "name": "addEnvPresetFeature",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper.addEnvPresetFeature",
    "access": "public",
    "description": "Add a required feature to the `env` preset options (it will go on the `include` option).",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "feature",
        "description": "The name of the feature to add or a list of them."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "disableEnvPresetModules",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper.disableEnvPresetModules",
    "access": "public",
    "description": "Disable the `env` preset `modules` option as it may cause conflict with some packages.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "_addConfigurationItem",
    "memberof": "src/services/common/babelHelper.js~BabelHelper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/babelHelper.js~BabelHelper._addConfigurationItem",
    "access": "protected",
    "description": "This is a helper method for adding things that share the same structure on a Babel\nconfiguration, like plugins and presets: They can be a `string` with the plugin/preset name\nor an `Array` with the name and its options.",
    "lineNumber": 157,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The configuration to update."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "An item name or configuration `Array` (`[name, options]`),\n                                    or a list of them."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "The name of the items property (like `plugins` or\n                                    `presets`)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated configuration."
    }
  },
  {
    "__docId__": 569,
    "kind": "variable",
    "name": "babelHelper",
    "memberof": "src/services/common/babelHelper.js",
    "static": true,
    "longname": "src/services/common/babelHelper.js~babelHelper",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/babelHelper.js",
    "importStyle": "{babelHelper}",
    "description": "The service provider that once registered on the app container will set a reference of\n`BabelHelper` as the `babelHelper` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(babelHelper);\n// Getting access to the service reference\nconst babelHelper = container.get('babelHelper');"
    ],
    "lineNumber": 228,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 570,
    "kind": "file",
    "name": "src/services/common/cleaner.js",
    "content": "const del = require('del');\nconst { provider } = require('jimple');\n/**\n * A simple class with only one static method that removes items from directories.\n */\nclass Cleaner {\n  /**\n   * Remove items that match a glob pattern from a given directory.\n   * @param {string}  directory            The path to the target directory.\n   * @param {Array}   files                The list of files/folders to remove.\n   * @param {boolean} [removeOthers=false] If `true`, it will remove everything but the specified\n   *                                       `files`.\n   * @return {Promise<undefined,Error>}\n   */\n  static clean(directory, files, removeOthers = false) {\n    const items = [];\n    let flag = '';\n    if (removeOthers) {\n      items.push(`${directory}/**`);\n      items.push(`!${directory}`);\n      flag = '!';\n    }\n\n    if (Array.isArray(files)) {\n      files.forEach((file) => {\n        items.push(`${flag}${directory}/${file}`);\n      });\n    } else {\n      items.push(`${directory}/${files}`);\n    }\n\n    return del(items);\n  }\n}\n/**\n * The service provider that once registered on the app container will set `Cleaner.clean` as the\n * `cleaner` service.\n * @example\n * // Register it on the container\n * container.register(cleaner);\n * // Getting access to the service instance\n * const cleaner = container.get('cleaner');\n * @type {Provider}\n */\nconst cleaner = provider((app) => {\n  app.set('cleaner', () => Cleaner.clean);\n});\n\nmodule.exports = {\n  Cleaner,\n  cleaner,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/cleaner.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 571,
    "kind": "class",
    "name": "Cleaner",
    "memberof": "src/services/common/cleaner.js",
    "static": true,
    "longname": "src/services/common/cleaner.js~Cleaner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/cleaner.js",
    "importStyle": "{Cleaner}",
    "description": "A simple class with only one static method that removes items from directories.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 572,
    "kind": "method",
    "name": "clean",
    "memberof": "src/services/common/cleaner.js~Cleaner",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/cleaner.js~Cleaner.clean",
    "access": "public",
    "description": "Remove items that match a glob pattern from a given directory.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "directory",
        "description": "The path to the target directory."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "The list of files/folders to remove."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "removeOthers",
        "description": "If `true`, it will remove everything but the specified\n                                      `files`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 573,
    "kind": "variable",
    "name": "cleaner",
    "memberof": "src/services/common/cleaner.js",
    "static": true,
    "longname": "src/services/common/cleaner.js~cleaner",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/cleaner.js",
    "importStyle": "{cleaner}",
    "description": "The service provider that once registered on the app container will set `Cleaner.clean` as the\n`cleaner` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(cleaner);\n// Getting access to the service instance\nconst cleaner = container.get('cleaner');"
    ],
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 574,
    "kind": "file",
    "name": "src/services/common/copier.js",
    "content": "const fs = require('fs-extra');\nconst path = require('path');\nconst { provider } = require('jimple');\n/**\n * A service to copy items.\n */\nclass Copier {\n  /**\n   * Copy a list of items between an `origin` directory and a `target` directory.\n   * @param {string} origin The path to the origin directory.\n   * @param {string} target The path to the target directory.\n   * @param {Array}  items  The list of items to copy. Each item can be a `string` with the path to\n   *                        the item, or an object with origin path of the file as key and the\n   *                        target path as value.\n   * @return {Promise<Array,Error>} If everything goes well, the promise will resolve on a list\n   *                                with the information of every item it copied.\n   */\n  static copy(origin, target, items) {\n    const paths = [];\n    const list = items.map((item) => {\n      const result = {\n        from: '',\n        to: '',\n      };\n\n      if (typeof item === 'string') {\n        result.from = path.join(origin, item);\n        result.to = path.join(target, item);\n        result.isModule = item.startsWith('node_modules');\n      } else {\n        const [name] = Object.keys(item);\n        result.from = path.join(origin, name);\n        result.to = path.join(target, item[name]);\n        result.isModule = name.startsWith('node_modules');\n      }\n\n      paths.push(result.from);\n      return result;\n    });\n\n    return this.findMissingItems(paths)\n    .then(() => Promise.all(list.map((item) => (item.isModule ?\n      this.copyModule(item.from, item.to) :\n      this.copyFile(item.from, item.to)\n    ))));\n  }\n  /**\n   * Copy a single file from one location to another.\n   * @param {string} from The current location of the file.\n   * @param {string} to   The location of the copy.\n   * @return {Promise<Object,Object>} The promise will resolve on an object with the information of\n   *                                  the process: `from`, `to` and `success`.\n   */\n  static copyFile(from, to) {\n    return fs.copy(from, to)\n    .then(() => ({\n      from,\n      to,\n      success: true,\n    }))\n    .catch((error) => ({\n      from,\n      to,\n      error,\n      success: false,\n    }));\n  }\n  /**\n   * Copy a Node module. The reason this is different from `copyFile` is because instead of copying\n   * the entire module, we first read all the files on its directory, remove its modules and the\n   * lock files and then copy all the rest.\n   * @param {string} from The module path.\n   * @param {string} to   The path to where it will be copied.\n   * @return {Promise<Object,Object>} The promise will resolve on an object with the information of\n   *                                  the process: `from`, `to` and `success`.\n   */\n  static copyModule(from, to) {\n    const ignore = ['yarn.lock', 'package-lock.json', 'node_modules'];\n    return fs.ensureDir(to)\n    .then(() => fs.readdir(from))\n    .then((files) => Promise.all(\n      files\n      .filter((file) => !ignore.includes(file))\n      .map((file) => fs.copy(path.join(from, file), path.join(to, file)))\n    ))\n    .then(() => ({\n      from,\n      to,\n      success: true,\n    }))\n    .catch((error) => ({\n      from,\n      to,\n      error,\n      success: false,\n    }));\n  }\n  /**\n   * Given a list of items, find if any of them doesn't exist.\n   * @param {Array} items A list of paths.\n   * @return {Promise<Array,Error>} If everything goes well, the promise will resolve on a list of\n   *                                objects with the path for the `item` and a flag to indicate if\n   *                                they `exists`.\n   */\n  static findMissingItems(items) {\n    return Promise.all(items.map((item) => this.pathExists(item)))\n    .then((results) => {\n      let result = {};\n      const missing = results.find((item) => !item.exists);\n      if (missing) {\n        result = Promise.reject(\n          new Error(`Error: ${missing.item} can't be copied because it doesn't exist`)\n        );\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Check if an item exists.\n   * @param  {string} item The path for the item.\n   * @return {Promise<Object,Error>} If everything goes well, the promise will resolve on an object\n   *                                 with the keys `item`, for the item path, and `exists` to\n   *                                 indicate whether the item exists or not.\n   */\n  static pathExists(item) {\n    return fs.pathExists(item)\n    .then((exists) => ({\n      item,\n      exists,\n    }));\n  }\n}\n/**\n * The service provider that once registered on the app container will set `Copier.copy` as the\n * `copier` service.\n * @example\n * // Register it on the container\n * container.register(copier);\n * // Getting access to the service instance\n * const copier = container.get('copier');\n * @type {Provider}\n */\nconst copier = provider((app) => {\n  app.set('copier', () => Copier.copy.bind(Copier));\n});\n\nmodule.exports = {\n  Copier,\n  copier,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/copier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 575,
    "kind": "class",
    "name": "Copier",
    "memberof": "src/services/common/copier.js",
    "static": true,
    "longname": "src/services/common/copier.js~Copier",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/copier.js",
    "importStyle": "{Copier}",
    "description": "A service to copy items.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "copy",
    "memberof": "src/services/common/copier.js~Copier",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/copier.js~Copier.copy",
    "access": "public",
    "description": "Copy a list of items between an `origin` directory and a `target` directory.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "origin",
        "description": "The path to the origin directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The path to the target directory."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "The list of items to copy. Each item can be a `string` with the path to\n                       the item, or an object with origin path of the file as key and the\n                       target path as value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the promise will resolve on a list\n                               with the information of every item it copied."
    }
  },
  {
    "__docId__": 577,
    "kind": "method",
    "name": "copyFile",
    "memberof": "src/services/common/copier.js~Copier",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/copier.js~Copier.copyFile",
    "access": "public",
    "description": "Copy a single file from one location to another.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The current location of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The location of the copy."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object,Object>"
      ],
      "spread": false,
      "description": "The promise will resolve on an object with the information of\n                                 the process: `from`, `to` and `success`."
    }
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "copyModule",
    "memberof": "src/services/common/copier.js~Copier",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/copier.js~Copier.copyModule",
    "access": "public",
    "description": "Copy a Node module. The reason this is different from `copyFile` is because instead of copying\nthe entire module, we first read all the files on its directory, remove its modules and the\nlock files and then copy all the rest.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The module path."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The path to where it will be copied."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object,Object>"
      ],
      "spread": false,
      "description": "The promise will resolve on an object with the information of\n                                 the process: `from`, `to` and `success`."
    }
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "findMissingItems",
    "memberof": "src/services/common/copier.js~Copier",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/copier.js~Copier.findMissingItems",
    "access": "public",
    "description": "Given a list of items, find if any of them doesn't exist.",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "A list of paths."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the promise will resolve on a list of\n                               objects with the path for the `item` and a flag to indicate if\n                               they `exists`."
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "pathExists",
    "memberof": "src/services/common/copier.js~Copier",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/copier.js~Copier.pathExists",
    "access": "public",
    "description": "Check if an item exists.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The path for the item."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the promise will resolve on an object\n                                with the keys `item`, for the item path, and `exists` to\n                                indicate whether the item exists or not."
    }
  },
  {
    "__docId__": 581,
    "kind": "variable",
    "name": "copier",
    "memberof": "src/services/common/copier.js",
    "static": true,
    "longname": "src/services/common/copier.js~copier",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/copier.js",
    "importStyle": "{copier}",
    "description": "The service provider that once registered on the app container will set `Copier.copy` as the\n`copier` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(copier);\n// Getting access to the service instance\nconst copier = container.get('copier');"
    ],
    "lineNumber": 144,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 582,
    "kind": "file",
    "name": "src/services/common/dotEnvUtils.js",
    "content": "const fs = require('fs-extra');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst dotenv = require('dotenv');\nconst dotenvExpand = require('dotenv-expand');\nconst { provider } = require('jimple');\n\n/**\n * @typedef {Object} DotEnvUtilsFileInfo\n * @property {string} name The name of the file.\n * @property {string} path The absolute path of the file.\n * @ignore\n */\n\n/**\n * A utility class/service to work with .env files for environment variables.\n */\nclass DotEnvUtils {\n  /**\n   * @param {EnvironmentUtils} environmentUtils To set variables in the environment.\n   * @param {AppLogger}        appLogger        To log information messages when files are loaded\n   *                                            or when there's a problem loading them.\n   * @param {PathUtils}        pathUtils        To get paths relative to the project root.\n   */\n  constructor(environmentUtils, appLogger, pathUtils) {\n    /**\n     * A local reference for the `environmentUtils` service.\n     * @type {EnvironmentUtils}\n     * @access protected\n     * @ignore\n     */\n    this._environmentUtils = environmentUtils;\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {AppLogger}\n     * @access protected\n     * @ignore\n     */\n    this._appLogger = appLogger;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     * @access protected\n     * @ignore\n     */\n    this._pathUtils = pathUtils;\n  }\n  /**\n   * Given a list of `.env` files (relative to the project root directory), this method will\n   * validate if they exist, load them, merge them (if `extend` is `true`) and return an object\n   * with all the variable declarations it found.\n   * @param {Array}   files         The list of file names relative to the project root directory.\n   * @param {boolean} [extend=true] Whether or not the variables found on the files should be\n   *                                merged on a single object. If this is `true`, it will reverse\n   *                                the list of files and merge all the variables in top of\n   *                                each other (to ensure that the final overwrite is from the\n   *                                file that was first on the list). If this is `false`, even\n   *                                if multiple files were found, it will only use the first one.\n   * @return {Object}\n   * @property {boolean} loaded    Whether or not variables were loaded.\n   * @property {Object}  variables A dictionary with all the loaded variables.\n   */\n  load(files, extend = true) {\n    const filesInfo = files\n    .map((file) => ({\n      name: file,\n      path: this._pathUtils.join(file),\n    }))\n    .filter((info) => fs.pathExistsSync(info.path));\n\n    const result = {\n      loaded: true,\n      variables: {},\n    };\n\n    if (filesInfo.length) {\n      const useFiles = extend ? filesInfo : [filesInfo[0]];\n      result.variables = this._parseFiles(useFiles);\n      result.loaded = !!Object.keys(result.variables).length;\n    } else {\n      result.loaded = false;\n    }\n\n    return result;\n  }\n  /**\n   * Given a dictionary of variables, this method will inject all of them on the environment.\n   * @param {Object}  variables        A dictionary with the variables to inject.\n   * @param {boolean} [overwrite=true] If `true`, and a variable is already declared, it will\n   *                                   overwrite it, otherwise, it will skip it.\n   */\n  inject(variables, overwrite = true) {\n    Object.keys(variables).forEach((name) => {\n      const value = variables[name];\n      this._environmentUtils.set(name, value, overwrite);\n    });\n  }\n  /**\n   * Given a list of files, the method will reverse the list, load the variables from each file\n   * and then merge them on top of each other. The reason the method first reverses the list is\n   * so the files with higher priority (lower index) are merged on top of the ones with lower\n   * priority (higher index). For example, `[fileOne, fileTwo]` will result on `fileOne` being\n   * merged in top of `fileTwo`, because it was first on the list.\n   * @param {Array} files A list of {@link DotEnvUtilsFileInfo} elements.\n   * @return {Object}\n   * @access protected\n   * @ignore\n   */\n  _parseFiles(files) {\n    const parsed = files\n    .reverse()\n    .reduce(\n      (current, fileInfo) => ObjectUtils.merge(current, this._parseFile(fileInfo)),\n      {}\n    );\n\n    return dotenvExpand({ parsed, ignoreProcessEnv: true }).parsed;\n  }\n  /**\n   * Loads and parses a single environment file.\n   * @param {DotEnvUtilsFileInfo} fileInfo The information for the file to load.\n   * @return {Object} The variables from the file.\n   * @throws {Error} If the file can't be read.\n   * @access protected\n   * @ignore\n   */\n  _parseFile(fileInfo) {\n    let result;\n    try {\n      const contents = fs.readFileSync(fileInfo.path);\n      result = dotenv.parse(contents);\n    } catch (error) {\n      this._appLogger.error(`Error: The environment file couldn't be read: ${fileInfo.name}`);\n      throw error;\n    }\n\n    return result;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `DotEnvUtils` as the `dotEnvUtils` service.\n * @example\n * // Register it on the container\n * container.register(dotEnvUtils);\n * // Getting access to the service instance\n * const dotEnvUtils = container.get('dotEnvUtils');\n * @type {Provider}\n */\nconst dotEnvUtils = provider((app) => {\n  app.set('dotEnvUtils', () => new DotEnvUtils(\n    app.get('environmentUtils'),\n    app.get('appLogger'),\n    app.get('pathUtils')\n  ));\n});\n\nmodule.exports = {\n  DotEnvUtils,\n  dotEnvUtils,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/dotEnvUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 583,
    "kind": "typedef",
    "name": "DotEnvUtilsFileInfo",
    "memberof": "src/services/common/dotEnvUtils.js",
    "static": true,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtilsFileInfo",
    "access": "public",
    "description": "",
    "ignore": true,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The absolute path of the file."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "DotEnvUtilsFileInfo"
    }
  },
  {
    "__docId__": 584,
    "kind": "class",
    "name": "DotEnvUtils",
    "memberof": "src/services/common/dotEnvUtils.js",
    "static": true,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/dotEnvUtils.js",
    "importStyle": "{DotEnvUtils}",
    "description": "A utility class/service to work with .env files for environment variables.",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 585,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "EnvironmentUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentUtils",
        "description": "To set variables in the environment."
      },
      {
        "nullable": null,
        "types": [
          "AppLogger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To log information messages when files are loaded\n                                           or when there's a problem loading them."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To get paths relative to the project root."
      }
    ]
  },
  {
    "__docId__": 586,
    "kind": "member",
    "name": "_environmentUtils",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#_environmentUtils",
    "access": "protected",
    "description": "A local reference for the `environmentUtils` service.",
    "lineNumber": 31,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "EnvironmentUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 587,
    "kind": "member",
    "name": "_appLogger",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#_appLogger",
    "access": "protected",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 38,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "AppLogger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 588,
    "kind": "member",
    "name": "_pathUtils",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#_pathUtils",
    "access": "protected",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 45,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "load",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#load",
    "access": "public",
    "description": "Given a list of `.env` files (relative to the project root directory), this method will\nvalidate if they exist, load them, merge them (if `extend` is `true`) and return an object\nwith all the variable declarations it found.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "The list of file names relative to the project root directory."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "extend",
        "description": "Whether or not the variables found on the files should be\n                               merged on a single object. If this is `true`, it will reverse\n                               the list of files and merge all the variables in top of\n                               each other (to ensure that the final overwrite is from the\n                               file that was first on the list). If this is `false`, even\n                               if multiple files were found, it will only use the first one."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "loaded",
        "description": "Whether or not variables were loaded."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "variables",
        "description": "A dictionary with all the loaded variables."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "inject",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#inject",
    "access": "public",
    "description": "Given a dictionary of variables, this method will inject all of them on the environment.",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "variables",
        "description": "A dictionary with the variables to inject."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "overwrite",
        "description": "If `true`, and a variable is already declared, it will\n                                  overwrite it, otherwise, it will skip it."
      }
    ],
    "return": null
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "_parseFiles",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#_parseFiles",
    "access": "protected",
    "description": "Given a list of files, the method will reverse the list, load the variables from each file\nand then merge them on top of each other. The reason the method first reverses the list is\nso the files with higher priority (lower index) are merged on top of the ones with lower\npriority (higher index). For example, `[fileOne, fileTwo]` will result on `fileOne` being\nmerged in top of `fileTwo`, because it was first on the list.",
    "lineNumber": 108,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "A list of {@link DotEnvUtilsFileInfo} elements."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "_parseFile",
    "memberof": "src/services/common/dotEnvUtils.js~DotEnvUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/dotEnvUtils.js~DotEnvUtils#_parseFile",
    "access": "protected",
    "description": "Loads and parses a single environment file.",
    "lineNumber": 126,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "DotEnvUtilsFileInfo"
        ],
        "spread": false,
        "optional": false,
        "name": "fileInfo",
        "description": "The information for the file to load."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The variables from the file."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the file can't be read."
      }
    ]
  },
  {
    "__docId__": 593,
    "kind": "variable",
    "name": "dotEnvUtils",
    "memberof": "src/services/common/dotEnvUtils.js",
    "static": true,
    "longname": "src/services/common/dotEnvUtils.js~dotEnvUtils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/dotEnvUtils.js",
    "importStyle": "{dotEnvUtils}",
    "description": "The service provider that once registered on the app container will set an instance of\n`DotEnvUtils` as the `dotEnvUtils` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(dotEnvUtils);\n// Getting access to the service instance\nconst dotEnvUtils = container.get('dotEnvUtils');"
    ],
    "lineNumber": 149,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 594,
    "kind": "file",
    "name": "src/services/common/events.js",
    "content": "const { provider } = require('jimple');\nconst { EventsHub } = require('wootils/shared');\n/**\n * A simple events hub to manage the app events.\n * @extends {EventsHub}\n */\nclass Events extends EventsHub {}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `Events` as the `events` service.\n * @example\n * // Register it on the container\n * container.register(events);\n * // Getting access to the service instance\n * const events = container.get('events');\n * @type {Provider}\n */\nconst events = provider((app) => {\n  app.set('events', () => new Events());\n});\n\nmodule.exports = {\n  Events,\n  events,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/events.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 595,
    "kind": "class",
    "name": "Events",
    "memberof": "src/services/common/events.js",
    "static": true,
    "longname": "src/services/common/events.js~Events",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/events.js",
    "importStyle": "{Events}",
    "description": "A simple events hub to manage the app events.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "EventsHub"
    ]
  },
  {
    "__docId__": 596,
    "kind": "variable",
    "name": "events",
    "memberof": "src/services/common/events.js",
    "static": true,
    "longname": "src/services/common/events.js~events",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/events.js",
    "importStyle": "{events}",
    "description": "The service provider that once registered on the app container will set an instance of\n`Events` as the `events` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(events);\n// Getting access to the service instance\nconst events = container.get('events');"
    ],
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 597,
    "kind": "file",
    "name": "src/services/common/index.js",
    "content": "const { babelHelper } = require('./babelHelper');\nconst { cleaner } = require('./cleaner');\nconst { copier } = require('./copier');\nconst { dotEnvUtils } = require('./dotEnvUtils');\nconst { events } = require('./events');\nconst { plugins } = require('./plugins');\nconst { promptWithOptions, prompt, appPrompt } = require('./prompt');\nconst { tempFiles } = require('./tempFiles');\nconst { utils } = require('./utils');\nconst { versionUtils } = require('./versionUtils');\n\nmodule.exports = {\n  appPrompt,\n  babelHelper,\n  cleaner,\n  copier,\n  dotEnvUtils,\n  events,\n  plugins,\n  promptWithOptions,\n  prompt,\n  tempFiles,\n  utils,\n  versionUtils,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 598,
    "kind": "file",
    "name": "src/services/common/plugins.js",
    "content": "const path = require('path');\nconst { provider } = require('jimple');\n/**\n * This service is in charge of looking for, loading and registering plugins for the app.\n */\nclass Plugins {\n  /**\n   * Class constructor.\n   * @param {string}    prefix      The prefix the dependencies need to have in order to be\n   *                                identified as plugins.\n   * @param {Projext}   app         To send to the plugis so they can register their services.\n   * @param {Logger}    appLogger   To indicate if a plugin couldn't be loaded.\n   * @param {Object}    packageInfo To read the dependencies list.\n   * @param {PathUtils} pathUtils   To build the dependencies paths.\n   */\n  constructor(prefix, app, appLogger, packageInfo, pathUtils) {\n    /**\n     * The prefix the dependencies need to have in order to be identified as plugins.\n     * @type {string}\n     */\n    this.prefix = prefix;\n    /**\n     * The local reference to the main app.\n     * @type {Projext}\n     */\n    this.app = app;\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * The implementation `package.json`\n     * @type {Object}\n     */\n    this.packageInfo = packageInfo;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * After the plugins are loaded, this property will have a list with the plugins names.\n     * @type {Array}\n     * @access protected\n     * @ignore\n     */\n    this._loadedPlugins = [];\n  }\n  /**\n   * Search for plugins on the `package.json` and loads them.\n   * @param  {boolean} [dependencies=true]    Whether or not to look for plugins on the\n   *                                          `dependencies`.\n   * @param  {boolean} [devDependencies=true] Whether or not to look for plugins on the\n   *                                          `devDependencies`.\n   */\n  load(dependencies = true, devDependencies = true) {\n    const packages = [];\n    if (dependencies && this.packageInfo.dependencies) {\n      packages.push(...Object.keys(this.packageInfo.dependencies));\n    }\n\n    if (devDependencies && this.packageInfo.devDependencies) {\n      packages.push(...Object.keys(this.packageInfo.devDependencies));\n    }\n\n    packages\n    .filter((name) => name.startsWith(this.prefix))\n    .forEach((name) => this._loadPlugin(name));\n  }\n  /**\n   * Loads a plugin from a file relative to the project root directory.\n   * @param {string} filePath The path to the file.\n   */\n  loadFromFile(filePath) {\n    this._loadPluginFile(\n      filePath,\n      path.basename(filePath),\n      this.pathUtils.join(filePath)\n    );\n  }\n  /**\n   * Gets the names of the loaded plugins.\n   * @return {string}\n   */\n  getLoadedPlugins() {\n    return this._loadedPlugins;\n  }\n  /**\n   * Checks whether a plugin was loaded or not.\n   * @param {string} name The plugin's name.\n   * @return {boolean}\n   */\n  loaded(name) {\n    return this.getLoadedPlugins().includes(name);\n  }\n  /**\n   * Loads a plugin by its package name.\n   * @param {string} packageName The name of the plugin.\n   * @ignore\n   * @access protected\n   */\n  _loadPlugin(packageName) {\n    this._loadPluginFile(\n      packageName,\n      packageName.substr(this.prefix.length),\n      this.pathUtils.join('node_modules', packageName)\n    );\n  }\n  /**\n   * Loads a plugin form an specific file.\n   * @param {string} reference A name for the plugin to show in case the plugin can't be loaded.\n   *                           In the case of a plugin from the `node_modules`, it should be the\n   *                           package name; on any other case, it should be the file path.\n   * @param {string} name      The name the service will use to save it on the list of loaded\n   *                           plugins.\n   * @param {string} filepath  The path to the file to `require`.\n   * @throws {Error} If the plugin can't be loaded or registered.\n   * @ignore\n   * @access protected\n   */\n  _loadPluginFile(reference, name, filepath) {\n    try {\n      // eslint-disable-next-line global-require,import/no-dynamic-require\n      const plugin = require(filepath);\n      if (plugin.plugin && typeof plugin.plugin === 'function') {\n        plugin.plugin(this.app);\n      } else {\n        plugin(this.app);\n      }\n    } catch (error) {\n      this.appLogger.error(`The plugin ${reference} couldn't be loaded`);\n      throw error;\n    }\n\n    this._loadedPlugins.push(name);\n  }\n}\n/**\n * Generate a `Provider` with an already defined prefix for the plugins.\n * @example\n * // Generate the provider\n * const provider = plugins('my-plugin-');\n * // Register it on the container\n * container.register(provider);\n * // Getting access to the service instance\n * const plugins = container.get('plugins');\n * @param {string} prefix The prefix the dependencies need to have in order to\n *                        be identified as plugins.\n * @return {Provider}\n */\nconst plugins = (prefix) => provider((app) => {\n  app.set('plugins', () => new Plugins(\n    prefix,\n    app,\n    app.get('appLogger'),\n    app.get('packageInfo'),\n    app.get('pathUtils')\n  ));\n});\n\nmodule.exports = {\n  Plugins,\n  plugins,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/plugins.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 599,
    "kind": "class",
    "name": "Plugins",
    "memberof": "src/services/common/plugins.js",
    "static": true,
    "longname": "src/services/common/plugins.js~Plugins",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/plugins.js",
    "importStyle": "{Plugins}",
    "description": "This service is in charge of looking for, loading and registering plugins for the app.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 600,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": "The prefix the dependencies need to have in order to be\n                               identified as plugins."
      },
      {
        "nullable": null,
        "types": [
          "Projext"
        ],
        "spread": false,
        "optional": false,
        "name": "app",
        "description": "To send to the plugis so they can register their services."
      },
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To indicate if a plugin couldn't be loaded."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "packageInfo",
        "description": "To read the dependencies list."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build the dependencies paths."
      }
    ]
  },
  {
    "__docId__": 601,
    "kind": "member",
    "name": "prefix",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#prefix",
    "access": "public",
    "description": "The prefix the dependencies need to have in order to be identified as plugins.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 602,
    "kind": "member",
    "name": "app",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#app",
    "access": "public",
    "description": "The local reference to the main app.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Projext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 603,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 604,
    "kind": "member",
    "name": "packageInfo",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#packageInfo",
    "access": "public",
    "description": "The implementation `package.json`",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 605,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 606,
    "kind": "member",
    "name": "_loadedPlugins",
    "memberof": "src/services/common/plugins.js~Plugins",
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#_loadedPlugins",
    "access": "protected",
    "description": "After the plugins are loaded, this property will have a list with the plugins names.",
    "lineNumber": 48,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 607,
    "kind": "method",
    "name": "load",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#load",
    "access": "public",
    "description": "Search for plugins on the `package.json` and loads them.",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "dependencies",
        "description": "Whether or not to look for plugins on the\n                                         `dependencies`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "devDependencies",
        "description": "Whether or not to look for plugins on the\n                                         `devDependencies`."
      }
    ],
    "return": null
  },
  {
    "__docId__": 608,
    "kind": "method",
    "name": "loadFromFile",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#loadFromFile",
    "access": "public",
    "description": "Loads a plugin from a file relative to the project root directory.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file."
      }
    ],
    "return": null
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "getLoadedPlugins",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#getLoadedPlugins",
    "access": "public",
    "description": "Gets the names of the loaded plugins.",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "loaded",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#loaded",
    "access": "public",
    "description": "Checks whether a plugin was loaded or not.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The plugin's name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "_loadPlugin",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#_loadPlugin",
    "access": "protected",
    "description": "Loads a plugin by its package name.",
    "lineNumber": 103,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "packageName",
        "description": "The name of the plugin."
      }
    ],
    "return": null
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "_loadPluginFile",
    "memberof": "src/services/common/plugins.js~Plugins",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/plugins.js~Plugins#_loadPluginFile",
    "access": "protected",
    "description": "Loads a plugin form an specific file.",
    "lineNumber": 122,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reference",
        "description": "A name for the plugin to show in case the plugin can't be loaded.\n                          In the case of a plugin from the `node_modules`, it should be the\n                          package name; on any other case, it should be the file path."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name the service will use to save it on the list of loaded\n                          plugins."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file to `require`."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the plugin can't be loaded or registered."
      }
    ],
    "return": null
  },
  {
    "__docId__": 613,
    "kind": "function",
    "name": "plugins",
    "memberof": "src/services/common/plugins.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/plugins.js~plugins",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/plugins.js",
    "importStyle": "{plugins}",
    "description": "Generate a `Provider` with an already defined prefix for the plugins.",
    "examples": [
      "// Generate the provider\nconst provider = plugins('my-plugin-');\n// Register it on the container\ncontainer.register(provider);\n// Getting access to the service instance\nconst plugins = container.get('plugins');"
    ],
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": "The prefix the dependencies need to have in order to\n                       be identified as plugins."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 614,
    "kind": "file",
    "name": "src/services/common/prompt.js",
    "content": "const promptTool = require('prompt');\nconst { provider } = require('jimple');\n/**\n * This services works as an abstraction of the `prompt` package in order to add support for\n * Promises, fix some quirks regarding boolean options, customize the interface just once and,\n * finally, integrate it withe Jimple.\n */\nclass Prompt {\n  /**\n   * Class constructor.\n   * @param {string} [messagesPrefix=''] A prefix text that will be shown before each message.\n   */\n  constructor(messagesPrefix = '') {\n    // Overwrite the default prefix.\n    promptTool.message = messagesPrefix;\n    /**\n     * Set a single space as a delimiter between the messages components (prefix, question and\n     * default value).\n     */\n    promptTool.delimiter = ' ';\n    // Disable colors because `prompt` has a hardcoded gray on the texts.\n    promptTool.colors = false;\n  }\n  /**\n   * Invoke the `prompt` package and ask the user for input.\n   * @param {Object} schema The input data schema. For more information on how to build it, you\n   *                        should check the `prompt` package documentation, it's pretty complete.\n   *                        IMPORTANT: On the `prompt` documentation, this object would be the\n   *                        `properties` inside their `schema` object.\n   * @return {Promise<Object,Error>} If everything goes well, the resolved value is an object with\n   *                                 the values the user entered; and if the user cancels the input,\n   *                                 you'll get an error with the message `canceled`.\n   */\n  ask(schema) {\n    // Copy the schema into a new object in order to modify it.\n    const newSchema = Object.assign({}, schema);\n    // Loop all the properties.\n    Object.keys(newSchema).forEach((name) => {\n      const property = newSchema[name];\n      // If the property type is `boolean`, use the helper method to add the validation properties.\n      if (property.type === 'boolean') {\n        newSchema[name] = this._booleanHelper(property);\n      }\n    });\n    // Return a _\"promisified\"_ implementation of `prompt`.\n    return new Promise((resolve, reject) => {\n      promptTool.get({ properties: newSchema }, (error, result) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n  /**\n   * Access the history of the prompt.\n   * @param {string} property The name of the property you want to look on the history.\n   * @return {?Object} If the property is present, it will return an object with the name as\n   *                   `property` and its `value`, otherwise it will return `undefined`.\n   */\n  history(property) {\n    return promptTool.history(property);\n  }\n  /**\n   * Get a property value from the history.\n   * @param {string} property The name of the property.\n   * @return {?string} If the property is on the history, it will return its value, otherwise it\n   *                   will return `undefined`.\n   */\n  getValue(property) {\n    const saved = this.history(property);\n    let result;\n    if (saved && typeof saved.value !== 'undefined') {\n      result = saved.value;\n    }\n\n    return result;\n  }\n  /**\n   * The default implementation of boolean properties is not very friendly and it only accepts\n   * `true`, `t`, `false` or `f`, which is not _\"human friendly\"_, so this method changes boolean\n   * properties into string properties and add validations for `yes`, `y`, `no` and `n`. It also\n   * _\"booleanizes\"_ the input so when the results are resolved, the value will be a real `boolean`.\n   * @param {Object} property The property to format.\n   * @return {Object} The updated property.\n   * @ignore\n   * @access protected\n   */\n  _booleanHelper(property) {\n    return Object.assign({}, property, {\n      type: 'string',\n      message: 'You can only answer with \\'yes\\' or \\'no\\'',\n      conform: (value) => ['yes', 'y', 'no', 'n'].includes(value.toLowerCase()),\n      before: (value) => ['yes', 'y'].includes(value.toLowerCase()),\n    });\n  }\n}\n/**\n * Generates a `Provider` with an already defined message prefix.\n * @example\n * // Generate the provider\n * const provider = promptWithOptions('my-prefix');\n * // Register it on the container\n * container.register(provider);\n * // Getting access to the service instance\n * const prompt = container.get('prompt');\n * @param {string} [messagesPrefix] A prefix to include in front of all the messages.\n * @return {Provider}\n */\nconst promptWithOptions = (messagesPrefix) => provider((app) => {\n  app.set('prompt', () => new Prompt(messagesPrefix));\n});\n/**\n * The service provider that once registered on the app container will set an instance of\n * `Prompt` as the `prompt` service.\n * @example\n * // Register it on the container\n * container.register(prompt);\n * // Getting access to the service instance\n * const prompt = container.get('prompt');\n * @type {Provider}\n */\nconst prompt = promptWithOptions();\n/**\n * The service provider that once registered on the app container will set an instance of\n * `Prompt` as the `appPrompt` service. The difference with the regular `prompt` is that this one\n * uses the `packageInfo` service in order to retrieve the name of the project and use it as\n * messages prefix.\n * @example\n * // Register it on the container\n * container.register(appPrompt);\n * // Getting access to the service instance\n * const appPrompt = container.get('appPrompt');\n * @type {Provider}\n */\nconst appPrompt = provider((app) => {\n  app.set('appPrompt', () => {\n    const packageInfo = app.get('packageInfo');\n    const prefix = packageInfo.nameForCLI || packageInfo.name;\n    return new Prompt(prefix);\n  });\n});\n\nmodule.exports = {\n  Prompt,\n  promptWithOptions,\n  prompt,\n  appPrompt,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/prompt.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 615,
    "kind": "class",
    "name": "Prompt",
    "memberof": "src/services/common/prompt.js",
    "static": true,
    "longname": "src/services/common/prompt.js~Prompt",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/prompt.js",
    "importStyle": "{Prompt}",
    "description": "This services works as an abstraction of the `prompt` package in order to add support for\nPromises, fix some quirks regarding boolean options, customize the interface just once and,\nfinally, integrate it withe Jimple.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 616,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/common/prompt.js~Prompt",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/prompt.js~Prompt#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "messagesPrefix",
        "description": "A prefix text that will be shown before each message."
      }
    ]
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "ask",
    "memberof": "src/services/common/prompt.js~Prompt",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/prompt.js~Prompt#ask",
    "access": "public",
    "description": "Invoke the `prompt` package and ask the user for input.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "The input data schema. For more information on how to build it, you\n                       should check the `prompt` package documentation, it's pretty complete.\n                       IMPORTANT: On the `prompt` documentation, this object would be the\n                       `properties` inside their `schema` object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the resolved value is an object with\n                                the values the user entered; and if the user cancels the input,\n                                you'll get an error with the message `canceled`."
    }
  },
  {
    "__docId__": 618,
    "kind": "method",
    "name": "history",
    "memberof": "src/services/common/prompt.js~Prompt",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/prompt.js~Prompt#history",
    "access": "public",
    "description": "Access the history of the prompt.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "The name of the property you want to look on the history."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "If the property is present, it will return an object with the name as\n                  `property` and its `value`, otherwise it will return `undefined`."
    }
  },
  {
    "__docId__": 619,
    "kind": "method",
    "name": "getValue",
    "memberof": "src/services/common/prompt.js~Prompt",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/prompt.js~Prompt#getValue",
    "access": "public",
    "description": "Get a property value from the history.",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "The name of the property."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "If the property is on the history, it will return its value, otherwise it\n                  will return `undefined`."
    }
  },
  {
    "__docId__": 620,
    "kind": "method",
    "name": "_booleanHelper",
    "memberof": "src/services/common/prompt.js~Prompt",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/prompt.js~Prompt#_booleanHelper",
    "access": "protected",
    "description": "The default implementation of boolean properties is not very friendly and it only accepts\n`true`, `t`, `false` or `f`, which is not _\"human friendly\"_, so this method changes boolean\nproperties into string properties and add validations for `yes`, `y`, `no` and `n`. It also\n_\"booleanizes\"_ the input so when the results are resolved, the value will be a real `boolean`.",
    "lineNumber": 90,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "property",
        "description": "The property to format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The updated property."
    }
  },
  {
    "__docId__": 621,
    "kind": "function",
    "name": "promptWithOptions",
    "memberof": "src/services/common/prompt.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/prompt.js~promptWithOptions",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/prompt.js",
    "importStyle": "{promptWithOptions}",
    "description": "Generates a `Provider` with an already defined message prefix.",
    "examples": [
      "// Generate the provider\nconst provider = promptWithOptions('my-prefix');\n// Register it on the container\ncontainer.register(provider);\n// Getting access to the service instance\nconst prompt = container.get('prompt');"
    ],
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "messagesPrefix",
        "description": "A prefix to include in front of all the messages."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 622,
    "kind": "variable",
    "name": "prompt",
    "memberof": "src/services/common/prompt.js",
    "static": true,
    "longname": "src/services/common/prompt.js~prompt",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/prompt.js",
    "importStyle": "{prompt}",
    "description": "The service provider that once registered on the app container will set an instance of\n`Prompt` as the `prompt` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(prompt);\n// Getting access to the service instance\nconst prompt = container.get('prompt');"
    ],
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 623,
    "kind": "variable",
    "name": "appPrompt",
    "memberof": "src/services/common/prompt.js",
    "static": true,
    "longname": "src/services/common/prompt.js~appPrompt",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/prompt.js",
    "importStyle": "{appPrompt}",
    "description": "The service provider that once registered on the app container will set an instance of\n`Prompt` as the `appPrompt` service. The difference with the regular `prompt` is that this one\nuses the `packageInfo` service in order to retrieve the name of the project and use it as\nmessages prefix.",
    "examples": [
      "// Register it on the container\ncontainer.register(appPrompt);\n// Getting access to the service instance\nconst appPrompt = container.get('appPrompt');"
    ],
    "lineNumber": 137,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 624,
    "kind": "file",
    "name": "src/services/common/tempFiles.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\n/**\n * A utility service to read, write and delete temporary files.\n */\nclass TempFiles {\n  /**\n   * Class constructor.\n   * @param {Object}    info                  The application `package.json`, necessary to get the\n   *                                          module name and build the path of the temp directory.\n   * @param {PathUtils} pathUtils             To Register the temp directory location and build the\n   *                                          paths to the files.\n   * @param {string}    [directory='.tmp']    The name of the temp directory.\n   * @param {string}    [locationName='temp'] The name that will be used to register the temp\n   *                                          directory path as a location on the `pathUtils`\n   *                                          service.\n   */\n  constructor(info, pathUtils, directory = '.tmp', locationName = 'temp') {\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * The location name for the temp directory path on the `pathUtils` service.\n     * @type {string}\n     */\n    this.locationName = locationName;\n\n    this.pathUtils.addLocation(locationName, path.join(\n      'node_modules',\n      info.name,\n      directory\n    ));\n  }\n  /**\n   * Generate a path for the temp directory.\n   * @param {Array} rest The rest of the components that will be added to the path after the one\n   *                     for the temp directory.\n   * @return {string}\n   */\n  path(...rest) {\n    return this.pathUtils.joinFrom(this.locationName, ...rest);\n  }\n  /**\n   * Read a file from the temp directory.\n   * @param {string} filepath           The path to the file.\n   * @param {string} [encoding='utf-8'] The text encoding in which the file should be read.\n   * @return {Promise<string,Error>}\n   */\n  read(filepath, encoding = 'utf-8') {\n    return this.ensureDirectory()\n    .then(() => fs.readFile(this.path(filepath), encoding));\n  }\n  /**\n   * Read a file from the temp directory, sync version.\n   * @param {string} filepath           The path to the file.\n   * @param {string} [encoding='utf-8'] The text encoding in which the file should be read.\n   * @return {string}\n   * @throws {Error} If the file can't be read.\n   */\n  readSync(filepath, encoding = 'utf-8') {\n    this.ensureDirectorySync();\n    return fs.readFileSync(this.path(filepath), encoding);\n  }\n  /**\n   * Write a file on the temp directory.\n   * @param {string} filepath The path to the file.\n   * @param {string} data     The contents of the file.\n   * @return {Promise<string,Error>} On success, the promise resolves with the absolute path to\n   *                                 the file.\n   */\n  write(filepath, data) {\n    const tempFilepath = this.path(filepath);\n    return this.ensureDirectory()\n    .then(() => fs.writeFile(tempFilepath, data))\n    .then(() => tempFilepath);\n  }\n  /**\n   * Write a file on the temp directory, sync version.\n   * @param {string} filepath The path to the file.\n   * @param {string} data     The contents of the file.\n   * @return {string} The absolute path to the file.\n   * @throws {Error} If the method couldn't write on the file.\n   */\n  writeSync(filepath, data) {\n    this.ensureDirectorySync();\n    const tempFilepath = this.path(filepath);\n    fs.writeFileSync(tempFilepath, data);\n    return tempFilepath;\n  }\n  /**\n   * Delete a file from the temp directory.\n   * @param {string} filepath The path to the file.\n   * @return {Promise<string,Error>} On success, the promise resolves with the absolute path to\n   *                                 the file.\n   */\n  delete(filepath) {\n    const tempFilepath = this.path(filepath);\n    return this.ensureDirectory()\n    .then(() => fs.unlink(tempFilepath))\n    .then(() => tempFilepath);\n  }\n  /**\n   * Delete a file from the temp directory, sync version.\n   * @param {string} filepath The path to the file.\n   * @return {string} The absolute path to the file.\n   * @throws {Error} If the method couldn't delete the file.\n   */\n  deleteSync(filepath) {\n    this.ensureDirectorySync();\n    const tempFilepath = this.path(filepath);\n    fs.unlinkSync(tempFilepath);\n    return tempFilepath;\n  }\n  /**\n   * Ensure that the temp directory exists\n   * @return {Promise<undefined,Error>}\n   */\n  ensureDirectory() {\n    return fs.ensureDir(this.pathUtils.getLocation(this.locationName));\n  }\n  /**\n   * Ensure that the temp directory exists, sync version.\n   * @throws {Error} If the directory can't be created.\n   */\n  ensureDirectorySync() {\n    return fs.ensureDirSync(this.pathUtils.getLocation(this.locationName));\n  }\n}\n/**\n * Generates a {@link Provider} with a custom directory and/or location name for the temp directory.\n * You can also specify a custom service name, which can be helpfull if you want to create multiple\n * services for temp files.\n * @example\n * // Generate the provider\n * const provider = tempFilesCustom('.my-files', 'myTempFiles', 'myTempFiles');\n * // Register it on the container\n * container.register(provider);\n * // Get access to the service instance\n * const myTempFiles = container.get('myTempFiles');\n * @param {string} [directory]               The name of the temp directory.\n * @param {string} [locationName]            The name that will be used to register the temp\n *                                           directory path as a location on the `pathUtils`\n *                                           service.\n * @param {string} [serviceName='tempFiles'] The name that will be used to register the\n *                                           {@link TempFiles} instance as a service.\n * @return {Provider}\n */\nconst tempFilesCustom = (directory, locationName, serviceName = 'tempFiles') => provider((app) => {\n  app.set(serviceName, () => new TempFiles(\n    app.get('info'),\n    app.get('pathUtils'),\n    directory,\n    locationName\n  ));\n});\n/**\n * The service provider that once registered on the app container will set an instance of\n * {@link TempFiles} as the `tempFiles` service.\n * @example\n * // Register it on the container\n * container.register(tempFiles);\n * // Getting access to the service instance\n * const tempFiles = container.get('tempFiles');\n * @type {Provider}\n */\nconst tempFiles = tempFilesCustom();\n\nmodule.exports = {\n  TempFiles,\n  tempFilesCustom,\n  tempFiles,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/tempFiles.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 625,
    "kind": "class",
    "name": "TempFiles",
    "memberof": "src/services/common/tempFiles.js",
    "static": true,
    "longname": "src/services/common/tempFiles.js~TempFiles",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/tempFiles.js",
    "importStyle": "{TempFiles}",
    "description": "A utility service to read, write and delete temporary files.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 626,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The application `package.json`, necessary to get the\n                                         module name and build the path of the temp directory."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To Register the temp directory location and build the\n                                         paths to the files."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'.tmp'",
        "defaultRaw": "'.tmp'",
        "name": "directory",
        "description": "The name of the temp directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'temp'",
        "defaultRaw": "'temp'",
        "name": "locationName",
        "description": "The name that will be used to register the temp\n                                         directory path as a location on the `pathUtils`\n                                         service."
      }
    ]
  },
  {
    "__docId__": 627,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 628,
    "kind": "member",
    "name": "locationName",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#locationName",
    "access": "public",
    "description": "The location name for the temp directory path on the `pathUtils` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "path",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#path",
    "access": "public",
    "description": "Generate a path for the temp directory.",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "rest",
        "description": "The rest of the components that will be added to the path after the one\n                    for the temp directory."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 630,
    "kind": "method",
    "name": "read",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#read",
    "access": "public",
    "description": "Read a file from the temp directory.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'utf-8'",
        "defaultRaw": "'utf-8'",
        "name": "encoding",
        "description": "The text encoding in which the file should be read."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 631,
    "kind": "method",
    "name": "readSync",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#readSync",
    "access": "public",
    "description": "Read a file from the temp directory, sync version.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'utf-8'",
        "defaultRaw": "'utf-8'",
        "name": "encoding",
        "description": "The text encoding in which the file should be read."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the file can't be read."
      }
    ]
  },
  {
    "__docId__": 632,
    "kind": "method",
    "name": "write",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#write",
    "access": "public",
    "description": "Write a file on the temp directory.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The contents of the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": "On success, the promise resolves with the absolute path to\n                                the file."
    }
  },
  {
    "__docId__": 633,
    "kind": "method",
    "name": "writeSync",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#writeSync",
    "access": "public",
    "description": "Write a file on the temp directory, sync version.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The contents of the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The absolute path to the file."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the method couldn't write on the file."
      }
    ]
  },
  {
    "__docId__": 634,
    "kind": "method",
    "name": "delete",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#delete",
    "access": "public",
    "description": "Delete a file from the temp directory.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": "On success, the promise resolves with the absolute path to\n                                the file."
    }
  },
  {
    "__docId__": 635,
    "kind": "method",
    "name": "deleteSync",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#deleteSync",
    "access": "public",
    "description": "Delete a file from the temp directory, sync version.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path to the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The absolute path to the file."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the method couldn't delete the file."
      }
    ]
  },
  {
    "__docId__": 636,
    "kind": "method",
    "name": "ensureDirectory",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#ensureDirectory",
    "access": "public",
    "description": "Ensure that the temp directory exists",
    "lineNumber": 121,
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined,Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 637,
    "kind": "method",
    "name": "ensureDirectorySync",
    "memberof": "src/services/common/tempFiles.js~TempFiles",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/tempFiles.js~TempFiles#ensureDirectorySync",
    "access": "public",
    "description": "Ensure that the temp directory exists, sync version.",
    "lineNumber": 128,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the directory can't be created."
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "function",
    "name": "tempFilesCustom",
    "memberof": "src/services/common/tempFiles.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/tempFiles.js~tempFilesCustom",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/tempFiles.js",
    "importStyle": "{tempFilesCustom}",
    "description": "Generates a {@link Provider} with a custom directory and/or location name for the temp directory.\nYou can also specify a custom service name, which can be helpfull if you want to create multiple\nservices for temp files.",
    "examples": [
      "// Generate the provider\nconst provider = tempFilesCustom('.my-files', 'myTempFiles', 'myTempFiles');\n// Register it on the container\ncontainer.register(provider);\n// Get access to the service instance\nconst myTempFiles = container.get('myTempFiles');"
    ],
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "directory",
        "description": "The name of the temp directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "locationName",
        "description": "The name that will be used to register the temp\n                                          directory path as a location on the `pathUtils`\n                                          service."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'tempFiles'",
        "defaultRaw": "'tempFiles'",
        "name": "serviceName",
        "description": "The name that will be used to register the\n                                          {@link TempFiles} instance as a service."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 639,
    "kind": "variable",
    "name": "tempFiles",
    "memberof": "src/services/common/tempFiles.js",
    "static": true,
    "longname": "src/services/common/tempFiles.js~tempFiles",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/tempFiles.js",
    "importStyle": "{tempFiles}",
    "description": "The service provider that once registered on the app container will set an instance of\n{@link TempFiles} as the `tempFiles` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(tempFiles);\n// Getting access to the service instance\nconst tempFiles = container.get('tempFiles');"
    ],
    "lineNumber": 169,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 640,
    "kind": "file",
    "name": "src/services/common/utils.js",
    "content": "const path = require('path');\nconst { provider } = require('jimple');\n/**\n * A set of generic utilities that can be used in any context.\n */\nclass Utils {\n  /**\n   * Replace a dictionary of given placeholders on a string.\n   * @param  {string} string              The target string where the placeholders will be\n   *                                      replaced.\n   * @param  {Object} placeholders        A dictionary with its placholders and their values.\n   * @param  {String} [beforePlaceholder] Optional. The left limiter for the placeholder. This will\n   *                                      end up on a regular expression, so if it includes special\n   *                                      symbols (`[]{}/.`), they neeed to be escaped.\n   *                                      The default value is `\\\\[`.\n   * @param  {String} [afterPlaceholder]  Optional. The right limiter for the placeholder. This will\n   *                                      end up on a regular expression, so if it includes special\n   *                                      symbols (`[]{}/.`), they neeed to be escaped.\n   *                                      The default value is `\\\\[`.\n   * @return {string}\n   */\n  static replacePlaceholders(\n    string,\n    placeholders,\n    beforePlaceholder = '\\\\[',\n    afterPlaceholder = '\\\\]'\n  ) {\n    let newString = string;\n    Object.keys(placeholders).forEach((name) => {\n      newString = newString.replace(\n        RegExp(`${beforePlaceholder}${name}${afterPlaceholder}`, 'ig'),\n        placeholders[name]\n      );\n    });\n\n    return newString;\n  }\n  /**\n   * Formats a list of strings into a _\"human readable list\".\n   * @example\n   * console.log(Utils.humanReadableList(['one', 'two', 'three']));\n   * // Will output 'one, two or three'\n   *\n   * console.log(Utils.humanReadableList(['one', 'two', 'three'], 'and'));\n   * // Will output 'one, two and three'\n   *\n   * @param {Array}  list                A list of strings to format.\n   * @param {string} [conjunction='or'] The conjunction to be added between the last two items.\n   * @return {string}\n   */\n  static humanReadableList(list, conjunction = 'or') {\n    let result = '';\n    if (list.length === 1) {\n      [result] = list;\n    } else if (list.length > 1) {\n      const comma = ', ';\n      const str = list.join(comma);\n      const lastComma = str.lastIndexOf(comma);\n      const before = str.substr(0, lastComma);\n      const after = str.substr(lastComma + comma.length);\n      result = `${before} ${conjunction} ${after}`;\n    }\n\n    return result;\n  }\n  /**\n   * This a helper for when projext deals with non-JS files, like `.jsx` or `.ts`. Given a path for\n   * a file, the method will make sure that the extension used is the one specified (`js by\n   * default).\n   * @example\n   * console.log(Utils.ensureExtension('my/file/path.ts');\n   * // Will output `my/file/path.js`\n   *\n   * @param {string} filepath         The path for the file.\n   * @param {string} [extension='js'] The extension to validate.\n   * @return {string}\n   */\n  static ensureExtension(filepath, extension = 'js') {\n    let result;\n    const parsed = path.parse(filepath);\n    if (parsed.ext.toLowerCase().endsWith(`.${extension}`)) {\n      result = filepath;\n    } else {\n      result = path.join(parsed.dir, `${parsed.name}.${extension}`);\n    }\n\n    return result;\n  }\n}\n/**\n * The service provider that once registered on the app container will set a reference of\n * `Utils` as the `utils` service.\n * @example\n * // Register it on the container\n * container.register(utils);\n * // Getting access to the service reference\n * const utils = container.get('utils');\n * @type {Provider}\n */\nconst utils = provider((app) => {\n  app.set('utils', () => Utils);\n});\n\nmodule.exports = {\n  Utils,\n  utils,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 641,
    "kind": "class",
    "name": "Utils",
    "memberof": "src/services/common/utils.js",
    "static": true,
    "longname": "src/services/common/utils.js~Utils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/utils.js",
    "importStyle": "{Utils}",
    "description": "A set of generic utilities that can be used in any context.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "replacePlaceholders",
    "memberof": "src/services/common/utils.js~Utils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/utils.js~Utils.replacePlaceholders",
    "access": "public",
    "description": "Replace a dictionary of given placeholders on a string.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "The target string where the placeholders will be\n                                     replaced."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "placeholders",
        "description": "A dictionary with its placholders and their values."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "beforePlaceholder",
        "description": "Optional. The left limiter for the placeholder. This will\n                                     end up on a regular expression, so if it includes special\n                                     symbols (`[]{}/.`), they neeed to be escaped.\n                                     The default value is `\\\\[`."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "afterPlaceholder",
        "description": "Optional. The right limiter for the placeholder. This will\n                                     end up on a regular expression, so if it includes special\n                                     symbols (`[]{}/.`), they neeed to be escaped.\n                                     The default value is `\\\\[`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "humanReadableList",
    "memberof": "src/services/common/utils.js~Utils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/utils.js~Utils.humanReadableList",
    "access": "public",
    "description": "Formats a list of strings into a _\"human readable list\".",
    "examples": [
      "console.log(Utils.humanReadableList(['one', 'two', 'three']));\n// Will output 'one, two or three'\n\nconsole.log(Utils.humanReadableList(['one', 'two', 'three'], 'and'));\n// Will output 'one, two and three'"
    ],
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "list",
        "description": "A list of strings to format."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'or'",
        "defaultRaw": "'or'",
        "name": "conjunction",
        "description": "The conjunction to be added between the last two items."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "ensureExtension",
    "memberof": "src/services/common/utils.js~Utils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/services/common/utils.js~Utils.ensureExtension",
    "access": "public",
    "description": "This a helper for when projext deals with non-JS files, like `.jsx` or `.ts`. Given a path for\na file, the method will make sure that the extension used is the one specified (`js by\ndefault).",
    "examples": [
      "console.log(Utils.ensureExtension('my/file/path.ts');\n// Will output `my/file/path.js`"
    ],
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filepath",
        "description": "The path for the file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'js'",
        "defaultRaw": "'js'",
        "name": "extension",
        "description": "The extension to validate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 645,
    "kind": "variable",
    "name": "utils",
    "memberof": "src/services/common/utils.js",
    "static": true,
    "longname": "src/services/common/utils.js~utils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/utils.js",
    "importStyle": "{utils}",
    "description": "The service provider that once registered on the app container will set a reference of\n`Utils` as the `utils` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(utils);\n// Getting access to the service reference\nconst utils = container.get('utils');"
    ],
    "lineNumber": 100,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 646,
    "kind": "file",
    "name": "src/services/common/versionUtils.js",
    "content": "const fs = require('fs-extra');\nconst shell = require('shelljs');\nconst { provider } = require('jimple');\n/**\n * A set of utilities to work with the version of the project.\n */\nclass VersionUtils {\n  /**\n   * Class constructor.\n   * @param {EnvironmentUtils} environmentUtils To read the environment variables.\n   * @param {Logger}           appLogger        To inform the user if something goes wrong.\n   * @param {PathUtils}        pathUtils        To build paths for the revision file.\n   */\n  constructor(environmentUtils, appLogger, pathUtils) {\n    /**\n     * A local reference for the `environmentUtils` service.\n     * @type {EnvironmentUtils}\n     */\n    this.environmentUtils = environmentUtils;\n    /**\n     * A local reference for the `appLogger` service.\n     * @type {Logger}\n     */\n    this.appLogger = appLogger;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * The default fallback version in case none can be retrieved.\n     * @type {string}\n     */\n    this.fallbackVersion = 'development';\n    /**\n     * This will be filled with the version on the revision file, if it exists.\n     * @type {null|string}\n     * @ignore\n     * @access protected\n     */\n    this._loadedVersion = null;\n  }\n  /**\n   * Get the version from an environment variable.\n   * @param {string}  environmentVariable The name of the environment variable.\n   * @param {boolean} [withFallback=true] If `true` and there's no version on the variable, it will\n   *                                       return the fallback version.\n   * @return {string}\n   */\n  getEnvironmentVersion(environmentVariable, withFallback = true) {\n    const fallback = withFallback ? this.fallbackVersion : undefined;\n    return this.environmentUtils.get(environmentVariable, fallback).trim();\n  }\n  /**\n   * Get the version from the revision file. If the revision file doesn't exist or can't be loaded,\n   * it will return an empty string.\n   * @param  {string} filename The path to the revision file.\n   * @return {string}\n   */\n  getVersionFromFile(filename) {\n    let version;\n    try {\n      const filepath = this.pathUtils.join(filename);\n      version = fs\n      .readFileSync(filepath, 'utf-8')\n      .trim();\n    } catch (e) {\n      version = '';\n    }\n\n    return version;\n  }\n  /**\n   * Look for a version on both the revision file and the environment variable.\n   * @param {string} revisionFilename    The path to the revision file.\n   * @param {string} environmentVariable The name of the environment variable.\n   * @return {string}\n   */\n  getVersion(revisionFilename, environmentVariable) {\n    if (!this._loadedVersion || this._loadedVersion === this.fallbackVersion) {\n      this._loadedVersion = this.getVersionFromFile(revisionFilename) ||\n        this.getEnvironmentVersion(environmentVariable);\n    }\n\n    return this._loadedVersion;\n  }\n  /**\n   * Create the revision file with either the version from the environment or, if the project is\n   * on a GIT repository, with the first `7` letters of the last commit hash.\n   * @param {string} revisionFilename    The path to where the revision file will be created.\n   * @param {string} environmentVariable The name of the environment variable.\n   * @return {Promise<string,Error>} If everything goes well, the promise will resolve with the\n   *                                 version the method wrote on the file.\n   */\n  createRevisionFile(revisionFilename, environmentVariable) {\n    let inRepository = true;\n    try {\n      fs.statSync('./.git');\n    } catch (e) {\n      inRepository = false;\n    }\n\n    let version = '';\n    const envVersion = this.getEnvironmentVersion(environmentVariable, false);\n    if (envVersion) {\n      version = envVersion;\n    } else if (shell.which('git') && inRepository) {\n      const commitHash = shell.exec('git rev-parse HEAD', { silent: true });\n      if (commitHash && commitHash.code === 0) {\n        const hashLength = 7;\n        version = commitHash.trim().substr(0, hashLength);\n      }\n    }\n\n    let write;\n    if (version) {\n      const filepath = this.pathUtils.join(revisionFilename);\n      write = fs.writeFile(filepath, version)\n      .then(() => {\n        this.appLogger.success(\n          `The revision file was successfully created (${filepath})`\n        );\n\n        return version;\n      })\n      .catch((error) => {\n        this.appLogger.error(\n          `There was an error creating the revision file (${filepath})`\n        );\n        return Promise.reject(error);\n      });\n    } else {\n      this.appLogger.error('The revision file couldn\\'t be created');\n      const errorMessage = 'The project is not running on a GIT environment and there\\'s no ' +\n        `${environmentVariable} variable set`;\n      write = Promise.reject(new Error(errorMessage));\n    }\n\n    return write;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `VersionUtils` as the `versionUtils` service.\n * @example\n * // Register it on the container\n * container.register(versionUtils);\n * // Getting access to the service instance\n * const versionUtils = container.get('versionUtils');\n * @type {Provider}\n */\nconst versionUtils = provider((app) => {\n  app.set('versionUtils', () => new VersionUtils(\n    app.get('environmentUtils'),\n    app.get('appLogger'),\n    app.get('pathUtils')\n  ));\n});\n\nmodule.exports = {\n  VersionUtils,\n  versionUtils,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/common/versionUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 647,
    "kind": "class",
    "name": "VersionUtils",
    "memberof": "src/services/common/versionUtils.js",
    "static": true,
    "longname": "src/services/common/versionUtils.js~VersionUtils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/versionUtils.js",
    "importStyle": "{VersionUtils}",
    "description": "A set of utilities to work with the version of the project.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 648,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "EnvironmentUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentUtils",
        "description": "To read the environment variables."
      },
      {
        "nullable": null,
        "types": [
          "Logger"
        ],
        "spread": false,
        "optional": false,
        "name": "appLogger",
        "description": "To inform the user if something goes wrong."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build paths for the revision file."
      }
    ]
  },
  {
    "__docId__": 649,
    "kind": "member",
    "name": "environmentUtils",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#environmentUtils",
    "access": "public",
    "description": "A local reference for the `environmentUtils` service.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "EnvironmentUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 650,
    "kind": "member",
    "name": "appLogger",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#appLogger",
    "access": "public",
    "description": "A local reference for the `appLogger` service.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "Logger"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 651,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 652,
    "kind": "member",
    "name": "fallbackVersion",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#fallbackVersion",
    "access": "public",
    "description": "The default fallback version in case none can be retrieved.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 653,
    "kind": "member",
    "name": "_loadedVersion",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#_loadedVersion",
    "access": "protected",
    "description": "This will be filled with the version on the revision file, if it exists.",
    "lineNumber": 41,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "null",
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "getEnvironmentVersion",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#getEnvironmentVersion",
    "access": "public",
    "description": "Get the version from an environment variable.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentVariable",
        "description": "The name of the environment variable."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "withFallback",
        "description": "If `true` and there's no version on the variable, it will\n                                      return the fallback version."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "getVersionFromFile",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#getVersionFromFile",
    "access": "public",
    "description": "Get the version from the revision file. If the revision file doesn't exist or can't be loaded,\nit will return an empty string.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filename",
        "description": "The path to the revision file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 656,
    "kind": "method",
    "name": "getVersion",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#getVersion",
    "access": "public",
    "description": "Look for a version on both the revision file and the environment variable.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "revisionFilename",
        "description": "The path to the revision file."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentVariable",
        "description": "The name of the environment variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "createRevisionFile",
    "memberof": "src/services/common/versionUtils.js~VersionUtils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/common/versionUtils.js~VersionUtils#createRevisionFile",
    "access": "public",
    "description": "Create the revision file with either the version from the environment or, if the project is\non a GIT repository, with the first `7` letters of the last commit hash.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "revisionFilename",
        "description": "The path to where the revision file will be created."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentVariable",
        "description": "The name of the environment variable."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": "If everything goes well, the promise will resolve with the\n                                version the method wrote on the file."
    }
  },
  {
    "__docId__": 659,
    "kind": "variable",
    "name": "versionUtils",
    "memberof": "src/services/common/versionUtils.js",
    "static": true,
    "longname": "src/services/common/versionUtils.js~versionUtils",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/common/versionUtils.js",
    "importStyle": "{versionUtils}",
    "description": "The service provider that once registered on the app container will set an instance of\n`VersionUtils` as the `versionUtils` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(versionUtils);\n// Getting access to the service instance\nconst versionUtils = container.get('versionUtils');"
    ],
    "lineNumber": 152,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 660,
    "kind": "file",
    "name": "src/services/configurations/babelConfiguration.js",
    "content": "const { provider } = require('jimple');\n/**\n * This service is in charge of creating Babel configurations for targets.\n */\nclass BabelConfiguration {\n  /**\n   * Class constructor.\n   * @param {Events} events To reduce the configurations.\n   */\n  constructor(events) {\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A dictionary with familiar names for Babel plugins.\n     * @type {Object}\n     * @access protected\n     * @ignore\n     */\n    this._plugins = {\n      decorators: {\n        name: '@babel/plugin-proposal-decorators',\n        options: {\n          legacy: true,\n        },\n      },\n      classProperties: {\n        name: '@babel/plugin-proposal-class-properties',\n        options: {\n          loose: true,\n        },\n      },\n      dynamicImports: {\n        name: '@babel/plugin-syntax-dynamic-import',\n        options: {},\n      },\n      objectRestSpread: {\n        name: '@babel/plugin-proposal-object-rest-spread',\n        options: {},\n      },\n    };\n    /**\n     * A dictionary with familiar names for Babel presets for type check.\n     * @type {Object}\n     * @access protected\n     * @ignore\n     */\n    this._typesPresets = {\n      flow: '@babel/preset-flow',\n      typeScript: '@babel/preset-typescript',\n    };\n  }\n  /**\n   * Get a Babel configuration for a target.\n   * This method uses the event reducer `babel-configuration`, which sends a Babel configuration\n   * and a target information, and expects a Babel configuration on return.\n   * @param {Target} target The target information.\n   * @return {Object}\n   */\n  getConfigForTarget(target) {\n    // Get the target settings we need.\n    const {\n      babel: {\n        features,\n        overwrites,\n      },\n      flow,\n      typeScript,\n      framework,\n    } = target;\n    // Define the configuration we are going to _'update'_.\n    const config = Object.assign({}, overwrites || {});\n    // Define the list of presets.\n    const presets = config.presets || [];\n    // Define the list of plugins.\n    const plugins = config.plugins || [];\n    // Define the name of `env` preset; to avoid having the string on multiple places.\n    const envPresetName = '@babel/preset-env';\n    // Check whether or not the presets include the `env` preset.\n    const hasEnv = presets\n    .find((preset) => (Array.isArray(preset) && preset[0] === envPresetName));\n\n    // If it doesn't have the `env` preset...\n    if (!hasEnv) {\n      // ... create an `env` preset for the target and add it to the top of the list.\n      presets.unshift([envPresetName, this._createEnvPresetForTarget(target)]);\n    }\n\n    // Check if the configuration should include any _'known plugin'_.\n    Object.keys(features).forEach((feature) => {\n      if (features[feature] && this._plugins[feature]) {\n        const featurePlugin = this._plugins[feature];\n        if (!this._includesConfigurationItem(plugins, featurePlugin.name)) {\n          if (Object.keys(featurePlugin.options).length) {\n            plugins.push([featurePlugin.name, featurePlugin.options]);\n          } else {\n            plugins.push(featurePlugin.name);\n          }\n        }\n      }\n    });\n\n    // Check if the target uses Flow or TypeScript.\n    if (flow) {\n      const flowConfig = this._getFlowConfiguration({ presets, plugins });\n      presets.push(...flowConfig.presets);\n      plugins.push(...flowConfig.plugins);\n    } else if (typeScript) {\n      const tsConfig = this._getTypeScriptConfiguration({ presets, plugins }, framework);\n      presets.push(...tsConfig.presets);\n      plugins.push(...tsConfig.plugins);\n    }\n\n    // Set both presets and plugins back on the config.\n    config.presets = presets;\n    config.plugins = plugins;\n    // Return a reduced configuration\n    return this.events.reduce('babel-configuration', config, target);\n  }\n  /**\n   * Creates a configuration for a Babel \"env preset\" using the settings from a target.\n   * @param {Target} target The target information.\n   * @return {Object}\n   * @access protected\n   * @ignore\n   */\n  _createEnvPresetForTarget(target) {\n    // Get the target settings we need.\n    const {\n      babel: {\n        nodeVersion,\n        browserVersions,\n        mobileSupport,\n        polyfill,\n        env,\n      },\n    } = target;\n    /**\n     * If the target needs polyfills, use as base the settings for `core-js`, otherwise, just\n     * use an empty object.\n     */\n    const presetBaseSettings = polyfill ? { corejs: 3, useBuiltIns: 'usage' } : {};\n    /**\n     * Merge an object with the required properties, the base generated after evaluating the need\n     * for polyfills, and whatever was specified on the target settings.\n     */\n    const envPreset = Object.assign({ targets: {} }, presetBaseSettings, env);\n    // If the target is for browsers...\n    if (target.is.browser) {\n      /**\n       * Check if the target had settings for browsers, because if there are no settings, the\n       * method will create new ones, if there was an array, the method will only add settings\n       * for browsers that are not present; and if the value is `falsy`, it will delete the key.\n       */\n      const { targets: { browsers: currentBrowsers } } = envPreset;\n      const currentBrowsersExists = Array.isArray(currentBrowsers);\n      if (currentBrowsersExists || typeof currentBrowsers === 'undefined') {\n        // Define the list of basic desktop browsers.\n        const browsers = ['chrome', 'safari', 'edge', 'firefox'];\n        // If the target needs transpilation for mobile, add the supported mobile browsers.\n        if (mobileSupport) {\n          browsers.push(...['ios', 'android']);\n        }\n        /**\n         * Map the settings into dictionaries with the name of the browser the setting is for and\n         * the value of the setting.\n         */\n        let browsersSettings = browsers.map((browser) => ({\n          name: browser,\n          setting: `last ${browserVersions} ${browser} versions`,\n        }));\n\n        // Define the variable for the new value of the setting.\n        const newValue = [];\n        /**\n         * If there was a list of browser settings on the target, push it to the list that will be\n         * used as the new value and remove the browsers that are already present.\n         */\n        if (currentBrowsersExists) {\n          newValue.push(...currentBrowsers);\n          browsersSettings = browsersSettings\n          .filter((settings) => !currentBrowsers.some((line) => line.includes(settings.name)));\n        }\n\n        // Push the settings for the list of browsers generated by the method.\n        newValue.push(...browsersSettings.map(({ setting }) => setting));\n        // Overwrite the value of the setting.\n        envPreset.targets.browsers = newValue;\n      } else {\n        // `browsers` was `falsy`, so it needs to be removed.\n        delete envPreset.targets.browsers;\n      }\n    } else if (typeof envPreset.targets.node === 'undefined') {\n      // Add the Node version if it's not already defined.\n      envPreset.targets.node = nodeVersion;\n    }\n\n    return envPreset;\n  }\n  /**\n   * Checks if a plugin/preset exists on a Babel configuration property list. The reason of the\n   * method is that, sometimes, the plugins or presets can be defined as array (first the name and\n   * then the options), so it also needs to check for those cases.\n   * @param {Array}  configurationList The list of presets or plugins where the function will look\n   *                                   for the item.\n   * @param {string} item              The name of the item the function needs to check for.\n   * @return {boolean}\n   * @access protected\n   * @ignore\n   */\n  _includesConfigurationItem(configurationList, item) {\n    return configurationList.length ?\n      configurationList.find((element) => (\n        Array.isArray(element) && element.length ?\n          element[0] === item :\n          element === item\n      )) :\n      false;\n  }\n  /**\n   * This method will generate a list of presets and plugins needed to support Flow on a\n   * given Babel configuration. To avoid modifying the reference of the current configuration or\n   * generating a new one for overwriting, the method will generate two new lists that can be\n   * pushed directly to the existing configuration.\n   * @example\n   * const flowConfig = this._getFlowConfiguration(currentConfig);\n   * currentConfig.presets.push(...flowConfig.presets);\n   * currentConfig.plugins.push(...flowConfig.plugins);\n   * @param {Object} currentConfiguration         The configuration to validate.\n   * @param {Array}  currentConfiguration.presets The current list of presets.\n   * @param {Array}  currentConfiguration.plugins The current list of plugins.\n   * @return {Object} And object with missing plugins and presets to achieve support for Flow.\n   * @property {Array} presets The list of missing presets needed to support Flow.\n   * @property {Array} plugins The list of missing presets needed to support Flow.\n   * @access protected\n   * @ignore\n   */\n  _getFlowConfiguration(currentConfiguration) {\n    const newConfig = {\n      presets: [],\n      plugins: [],\n    };\n\n    if (!this._includesConfigurationItem(\n      currentConfiguration.presets,\n      this._typesPresets.flow\n    )) {\n      newConfig.presets.push([this._typesPresets.flow]);\n    }\n\n    if (!this._includesConfigurationItem(\n      currentConfiguration.plugins,\n      this._plugins.classProperties.name\n    )) {\n      const { classProperties } = this._plugins;\n      newConfig.plugins.push([classProperties.name, classProperties.options]);\n    }\n\n    return newConfig;\n  }\n  /**\n   * This method will generate a list of presets and plugins needed to support TypeScript on a\n   * given Babel configuration. To avoid modifying the reference of the current configuration or\n   * generating a new one for overwriting, the method will generate two new lists that can be\n   * pushed directly to the existing configuration.\n   * @example\n   * const tsConfig = this._getTypeScriptConfiguration(currentConfig, framework);\n   * currentConfig.presets.push(...tsConfig.presets);\n   * currentConfig.plugins.push(...tsConfig.plugins);\n   * @param {Object} currentConfiguration         The configuration to validate.\n   * @param {Array}  currentConfiguration.presets The current list of presets.\n   * @param {Array}  currentConfiguration.plugins The current list of plugins.\n   * @param {String} framework                    To check for React and enable TSX support.\n   * @return {Object} And object with missing plugins and presets to achieve support for TypeScript.\n   * @property {Array} presets The list of missing presets needed to support TypeScript.\n   * @property {Array} plugins The list of missing presets needed to support TypeScript.\n   * @access protected\n   * @ignore\n   */\n  _getTypeScriptConfiguration(currentConfiguration, framework) {\n    const newConfig = {\n      presets: [],\n      plugins: [],\n    };\n\n    if (!this._includesConfigurationItem(\n      currentConfiguration.presets,\n      this._typesPresets.typeScript\n    )) {\n      const tsOptions = {};\n      if (framework === 'react') {\n        tsOptions.isTSX = true;\n        tsOptions.allExtensions = true;\n      }\n      newConfig.presets.push([this._typesPresets.typeScript, tsOptions]);\n    }\n\n    const toAdd = [];\n    if (!this._includesConfigurationItem(\n      currentConfiguration.plugins,\n      this._plugins.classProperties.name\n    )) {\n      toAdd.push('classProperties');\n    }\n\n    if (!this._includesConfigurationItem(\n      currentConfiguration.plugins,\n      this._plugins.objectRestSpread.name\n    )) {\n      toAdd.push('objectRestSpread');\n    }\n\n    toAdd.forEach((feature) => {\n      const featurePlugin = this._plugins[feature];\n      if (Object.keys(featurePlugin.options).length) {\n        newConfig.plugins.push([featurePlugin.name, featurePlugin.options]);\n      } else {\n        newConfig.plugins.push(featurePlugin.name);\n      }\n    });\n\n    return newConfig;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `BabelConfiguration` as the `babelConfiguration` service.\n * @example\n * // Register it on the container\n * container.register(babelConfiguration);\n * // Getting access to the service instance\n * const babelConfiguration = container.get('babelConfiguration');\n * @type {Provider}\n */\nconst babelConfiguration = provider((app) => {\n  app.set('babelConfiguration', () => new BabelConfiguration(\n    app.get('events')\n  ));\n});\n\nmodule.exports = {\n  BabelConfiguration,\n  babelConfiguration,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/configurations/babelConfiguration.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 661,
    "kind": "class",
    "name": "BabelConfiguration",
    "memberof": "src/services/configurations/babelConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/babelConfiguration.js",
    "importStyle": "{BabelConfiguration}",
    "description": "This service is in charge of creating Babel configurations for targets.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 662,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To reduce the configurations."
      }
    ]
  },
  {
    "__docId__": 663,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 664,
    "kind": "member",
    "name": "_plugins",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_plugins",
    "access": "protected",
    "description": "A dictionary with familiar names for Babel plugins.",
    "lineNumber": 22,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 665,
    "kind": "member",
    "name": "_typesPresets",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_typesPresets",
    "access": "protected",
    "description": "A dictionary with familiar names for Babel presets for type check.",
    "lineNumber": 50,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "getConfigForTarget",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#getConfigForTarget",
    "access": "public",
    "description": "Get a Babel configuration for a target.\nThis method uses the event reducer `babel-configuration`, which sends a Babel configuration\nand a target information, and expects a Babel configuration on return.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "_createEnvPresetForTarget",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_createEnvPresetForTarget",
    "access": "protected",
    "description": "Creates a configuration for a Babel \"env preset\" using the settings from a target.",
    "lineNumber": 129,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "_includesConfigurationItem",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_includesConfigurationItem",
    "access": "protected",
    "description": "Checks if a plugin/preset exists on a Babel configuration property list. The reason of the\nmethod is that, sometimes, the plugins or presets can be defined as array (first the name and\nthen the options), so it also needs to check for those cases.",
    "lineNumber": 213,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "configurationList",
        "description": "The list of presets or plugins where the function will look\n                                  for the item."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The name of the item the function needs to check for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "_getFlowConfiguration",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_getFlowConfiguration",
    "access": "protected",
    "description": "This method will generate a list of presets and plugins needed to support Flow on a\ngiven Babel configuration. To avoid modifying the reference of the current configuration or\ngenerating a new one for overwriting, the method will generate two new lists that can be\npushed directly to the existing configuration.",
    "examples": [
      "const flowConfig = this._getFlowConfiguration(currentConfig);\ncurrentConfig.presets.push(...flowConfig.presets);\ncurrentConfig.plugins.push(...flowConfig.plugins);"
    ],
    "lineNumber": 240,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration",
        "description": "The configuration to validate."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration.presets",
        "description": "The current list of presets."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration.plugins",
        "description": "The current list of plugins."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "presets",
        "description": "The list of missing presets needed to support Flow."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "plugins",
        "description": "The list of missing presets needed to support Flow."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "And object with missing plugins and presets to achieve support for Flow."
    }
  },
  {
    "__docId__": 670,
    "kind": "method",
    "name": "_getTypeScriptConfiguration",
    "memberof": "src/services/configurations/babelConfiguration.js~BabelConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/babelConfiguration.js~BabelConfiguration#_getTypeScriptConfiguration",
    "access": "protected",
    "description": "This method will generate a list of presets and plugins needed to support TypeScript on a\ngiven Babel configuration. To avoid modifying the reference of the current configuration or\ngenerating a new one for overwriting, the method will generate two new lists that can be\npushed directly to the existing configuration.",
    "examples": [
      "const tsConfig = this._getTypeScriptConfiguration(currentConfig, framework);\ncurrentConfig.presets.push(...tsConfig.presets);\ncurrentConfig.plugins.push(...tsConfig.plugins);"
    ],
    "lineNumber": 282,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration",
        "description": "The configuration to validate."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration.presets",
        "description": "The current list of presets."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "currentConfiguration.plugins",
        "description": "The current list of plugins."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "framework",
        "description": "To check for React and enable TSX support."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "presets",
        "description": "The list of missing presets needed to support TypeScript."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "plugins",
        "description": "The list of missing presets needed to support TypeScript."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "And object with missing plugins and presets to achieve support for TypeScript."
    }
  },
  {
    "__docId__": 671,
    "kind": "variable",
    "name": "babelConfiguration",
    "memberof": "src/services/configurations/babelConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/babelConfiguration.js~babelConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/babelConfiguration.js",
    "importStyle": "{babelConfiguration}",
    "description": "The service provider that once registered on the app container will set an instance of\n`BabelConfiguration` as the `babelConfiguration` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(babelConfiguration);\n// Getting access to the service instance\nconst babelConfiguration = container.get('babelConfiguration');"
    ],
    "lineNumber": 337,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 672,
    "kind": "file",
    "name": "src/services/configurations/index.js",
    "content": "const { babelConfiguration } = require('./babelConfiguration');\nconst { projectConfiguration } = require('./projectConfiguration');\nconst { targetConfiguration } = require('./targetConfiguration');\n\nmodule.exports = {\n  babelConfiguration,\n  projectConfiguration,\n  targetConfiguration,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/configurations/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 673,
    "kind": "file",
    "name": "src/services/configurations/projectConfiguration.js",
    "content": "const ObjectUtils = require('wootils/shared/objectUtils');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\nconst ConfigurationFile = require('../../abstracts/configurationFile');\n/**\n * Here's the configuration with all the _'magic defaults'_ the app uses. This service generates\n * the project configuration with all settings and features projext uses.\n * This configuration is ALWAYS overwritten and extended in order to define the targets.\n * @extends {ConfigurationFile}\n */\nclass ProjectConfiguration extends ConfigurationFile {\n  /**\n   * @param {PathUtils}          pathUtils     Because `ConfigurationFile` needs it in order to\n   *                                           build the overwrite path.\n   * @param {Plugins}            plugins       To get the list of loaded plugins and decide the\n   *                                           default build engine.\n   * @param {TargetsFinder#find} targetsFinder If the configuration is not overwritten, the\n   *                                           service will use this to look for existing targets\n   *                                           based on the files andor folders on the source\n   *                                           directory.\n   */\n  constructor(pathUtils, plugins, targetsFinder) {\n    // Set the overwrite file path.\n    super(pathUtils, [\n      'projext.config.js',\n      'config/projext.config.js',\n      'config/project.config.js',\n    ]);\n    /**\n     * A local reference for the `plugins` service.\n     * @type {Plugins}\n     */\n    this.plugins = plugins;\n    /**\n     * A local reference for the `targetsFinder` service.\n     * @type {TargetsFinder#find}\n     */\n    this.targetsFinder = targetsFinder;\n    /**\n     * The list of known build engine plugins that can be used with projext. This service\n     * will validate which one is installed in order to decide the default value of the `engine`\n     * settings for the targets.\n     * @type {Array}\n     * @access protected\n     * @ignore\n     */\n    this._knownBuildEndgines = ['webpack', 'rollup'];\n  }\n  /**\n   * Create the project configuration with all its _'smart defaults'_.\n   * @return {ProjectConfigurationSettings}\n   */\n  createConfig() {\n    const engine = this._getDefaultBuildEngine();\n    return {\n      paths: {\n        source: 'src',\n        build: 'dist',\n        privateModules: 'private',\n      },\n      targetsTemplates: {\n        node: {\n          type: 'node',\n          bundle: false,\n          transpile: false,\n          engine,\n          hasFolder: true,\n          createFolder: false,\n          folder: '',\n          entry: {\n            default: 'index.js',\n            development: null,\n            production: null,\n          },\n          output: {\n            default: {\n              js: '[target-name].js',\n              fonts: 'statics/fonts/[name]/[name].[hash].[ext]',\n              css: 'statics/styles/[target-name].[hash].css',\n              images: 'statics/images/[name].[hash].[ext]',\n            },\n            development: {\n              fonts: 'statics/fonts/[name]/[name].[ext]',\n              css: 'statics/styles/[target-name].css',\n              images: 'statics/images/[name].[ext]',\n            },\n            production: null,\n          },\n          sourceMap: {\n            development: false,\n            production: true,\n          },\n          inspect: {\n            enabled: false,\n            host: '0.0.0.0',\n            port: 9229,\n            command: 'inspect',\n            ndb: false,\n          },\n          css: {\n            modules: false,\n          },\n          includeModules: [],\n          excludeModules: [],\n          includeTargets: [],\n          runOnDevelopment: false,\n          watch: {\n            development: false,\n            production: false,\n          },\n          babel: {\n            features: {\n              decorators: false,\n              classProperties: false,\n              dynamicImports: true,\n              objectRestSpread: false,\n            },\n            nodeVersion: 'current',\n            env: {},\n            overwrites: {},\n          },\n          flow: false,\n          typeScript: false,\n          library: false,\n          libraryOptions: {\n            libraryTarget: 'commonjs2',\n          },\n          cleanBeforeBuild: true,\n          copy: [],\n          dotEnv: {\n            enabled: true,\n            files: [\n              '.env.[target-name].[build-type]',\n              '.env.[target-name]',\n              '.env.[build-type]',\n              '.env',\n            ],\n            extend: true,\n          },\n        },\n        browser: {\n          type: 'browser',\n          engine,\n          hasFolder: true,\n          createFolder: true,\n          folder: '',\n          entry: {\n            default: 'index.js',\n            development: null,\n            production: null,\n          },\n          output: {\n            default: {\n              js: 'statics/js/[target-name].[hash].js',\n              fonts: 'statics/fonts/[name]/[name].[hash].[ext]',\n              css: 'statics/styles/[target-name].[hash].css',\n              images: 'statics/images/[name].[hash].[ext]',\n            },\n            development: {\n              js: 'statics/js/[target-name].js',\n              fonts: 'statics/fonts/[name]/[name].[ext]',\n              css: 'statics/styles/[target-name].css',\n              images: 'statics/images/[name].[ext]',\n            },\n            production: null,\n          },\n          sourceMap: {\n            development: false,\n            production: true,\n          },\n          html: {\n            default: 'index.html',\n            template: null,\n            filename: null,\n          },\n          css: {\n            modules: false,\n            inject: false,\n          },\n          includeModules: [],\n          excludeModules: [],\n          includeTargets: [],\n          uglifyOnProduction: true,\n          runOnDevelopment: false,\n          watch: {\n            development: false,\n            production: false,\n          },\n          babel: {\n            features: {\n              decorators: false,\n              classProperties: false,\n              dynamicImports: true,\n              objectRestSpread: false,\n            },\n            browserVersions: 2,\n            mobileSupport: true,\n            polyfill: true,\n            env: {},\n            overwrites: {},\n          },\n          flow: false,\n          typeScript: false,\n          hot: false,\n          library: false,\n          libraryOptions: {\n            libraryTarget: 'umd',\n            compress: false,\n          },\n          cleanBeforeBuild: true,\n          copy: [],\n          dotEnv: {\n            enabled: true,\n            files: [\n              '.env.[target-name].[build-type]',\n              '.env.[target-name]',\n              '.env.[build-type]',\n              '.env',\n            ],\n            extend: true,\n          },\n          devServer: {\n            port: 2509,\n            open: true,\n            reload: true,\n            host: 'localhost',\n            ssl: {\n              key: null,\n              cert: null,\n              ca: null,\n            },\n            proxied: {\n              enabled: false,\n              host: null,\n              https: null,\n            },\n            historyApiFallback: true,\n          },\n          configuration: {\n            enabled: false,\n            default: null,\n            path: 'config/',\n            hasFolder: true,\n            defineOn: 'process.env.CONFIG',\n            environmentVariable: 'CONFIG',\n            loadFromEnvironment: true,\n            filenameFormat: '[target-name].[configuration-name].config.js',\n          },\n        },\n      },\n      targets: {},\n      copy: {\n        enabled: false,\n        items: [],\n        copyOnBuild: {\n          enabled: true,\n          onlyOnProduction: true,\n          targets: [],\n        },\n      },\n      version: {\n        defineOn: 'process.env.VERSION',\n        environmentVariable: 'VERSION',\n        revision: {\n          enabled: false,\n          copy: true,\n          filename: 'revision',\n          createRevisionOnBuild: {\n            enabled: true,\n            onlyOnProduction: true,\n            targets: [],\n          },\n        },\n      },\n      plugins: {\n        enabled: true,\n        list: [],\n      },\n      others: {\n        findTargets: {\n          enabled: true,\n        },\n        watch: {\n          poll: true,\n        },\n        nodemon: {\n          legacyWatch: false,\n        },\n      },\n    };\n  }\n  /**\n   * This is the real method that creates and extends the configuration. It's being overwritten\n   * for two reasons:\n   * 1. In order to check if the targets finder should try to find the targets information by\n   * reading the source directory or not.\n   * 2. To check for custom plugins and load them.\n   * @param  {Array} args A list of parameters for the service to use when creating the\n   *                      configuration. This gets send from {@link ConfigurationFile#getConfig}\n   * @ignore\n   * @access protected\n   */\n  _loadConfig(...args) {\n    super._loadConfig(...args);\n    if (this._config.others.findTargets.enabled) {\n      const originalTargets = ObjectUtils.copy(this._config.targets);\n      const originalTargetsNames = Object.keys(originalTargets);\n      const foundTargets = this._findTargets();\n      const foundTargetsNames = Object.keys(foundTargets);\n      /**\n       * If there's only one target on the configuration file and the finder only found one, the\n       * name of the found one will be changed to the one on the configuration file.\n       *\n       * When a single target, outside a folder, is found, the finder will give it the same name\n       * as the project name on the `package.json`, but by defining a single target on the\n       * configuration file, the name can be changed.\n       */\n      if (originalTargetsNames.length === 1 && foundTargetsNames.length === 1) {\n        const [originalTargetName] = originalTargetsNames;\n        const [foundTargetName] = foundTargetsNames;\n        if (originalTargetName !== foundTargetName) {\n          foundTargets[originalTargetName] = foundTargets[foundTargetName];\n          foundTargets[originalTargetName].name = originalTargetName;\n          delete foundTargets[foundTargetName];\n        }\n      }\n      this._config.targets = ObjectUtils.merge(foundTargets, originalTargets);\n    }\n    // If custom plugins are enabled...\n    if (this._config.plugins.enabled) {\n      /**\n       * First check if one of the _\"known plugins\"_ exist, then append the list of plugins\n       * defined on the configuration and finally try to load them.\n       */\n      this._validatePlugins(this._config.plugins.list)\n      .forEach((pluginFile) => this.plugins.loadFromFile(pluginFile));\n    }\n  }\n  /**\n   * It tries to find basic targets information by reading the source directory.\n   * @return {Object} If there were targets to be found, this will be a dictionary of\n   *                  {@link TargetsFinderTarget}, with the targets name as keys.\n   * @ignore\n   * @access protected\n   */\n  _findTargets() {\n    const result = {};\n    this.targetsFinder(this._config.paths.source)\n    .forEach((target) => {\n      result[target.name] = target;\n    });\n\n    return result;\n  }\n  /**\n   * Gets the name of the default build engine that the service will use as default for the\n   * targets templates. It finds the name by using a list of known engines and checking if any of\n   * them was loaded as a plugin.\n   * @return {string}\n   * @access protected\n   * @ignore\n   */\n  _getDefaultBuildEngine() {\n    return this._knownBuildEndgines.find((engine) => this.plugins.loaded(engine));\n  }\n  /**\n   * This method validates if any of the _\"known plugin paths\"_ exists and add them to the top\n   * of the list.\n   * @param {Array} definedPlugins The list of plugin paths defined on the configuration.\n   * @return {Array}\n   * @access protected\n   * @ignore\n   */\n  _validatePlugins(definedPlugins) {\n    const knownPlugins = [\n      'projext.plugin.js',\n      'config/projext.plugin.js',\n    ];\n\n    return [\n      ...knownPlugins.filter((pluginPath) => fs.pathExistsSync(this.pathUtils.join(pluginPath))),\n      ...definedPlugins,\n    ];\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `ProjectConfiguration` as the `projectConfiguration` service.\n * @example\n * // Register it on the container\n * container.register(projectConfiguration);\n * // Getting access to the service instance\n * const projectConfiguration = container.get('projectConfiguration');\n * @type {Provider}\n */\nconst projectConfiguration = provider((app) => {\n  app.set('projectConfiguration', () => new ProjectConfiguration(\n    app.get('pathUtils'),\n    app.get('plugins'),\n    app.get('targetsFinder')\n  ));\n});\n\nmodule.exports = {\n  ProjectConfiguration,\n  projectConfiguration,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/configurations/projectConfiguration.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 674,
    "kind": "class",
    "name": "ProjectConfiguration",
    "memberof": "src/services/configurations/projectConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/projectConfiguration.js",
    "importStyle": "{ProjectConfiguration}",
    "description": "Here's the configuration with all the _'magic defaults'_ the app uses. This service generates\nthe project configuration with all settings and features projext uses.\nThis configuration is ALWAYS overwritten and extended in order to define the targets.",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "ConfigurationFile"
    ]
  },
  {
    "__docId__": 675,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "Because `ConfigurationFile` needs it in order to\n                                          build the overwrite path."
      },
      {
        "nullable": null,
        "types": [
          "Plugins"
        ],
        "spread": false,
        "optional": false,
        "name": "plugins",
        "description": "To get the list of loaded plugins and decide the\n                                          default build engine."
      },
      {
        "nullable": null,
        "types": [
          "TargetsFinder#find"
        ],
        "spread": false,
        "optional": false,
        "name": "targetsFinder",
        "description": "If the configuration is not overwritten, the\n                                          service will use this to look for existing targets\n                                          based on the files andor folders on the source\n                                          directory."
      }
    ]
  },
  {
    "__docId__": 676,
    "kind": "member",
    "name": "plugins",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#plugins",
    "access": "public",
    "description": "A local reference for the `plugins` service.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Plugins"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 677,
    "kind": "member",
    "name": "targetsFinder",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#targetsFinder",
    "access": "public",
    "description": "A local reference for the `targetsFinder` service.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "TargetsFinder#find"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 678,
    "kind": "member",
    "name": "_knownBuildEndgines",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#_knownBuildEndgines",
    "access": "protected",
    "description": "The list of known build engine plugins that can be used with projext. This service\nwill validate which one is installed in order to decide the default value of the `engine`\nsettings for the targets.",
    "lineNumber": 47,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 679,
    "kind": "method",
    "name": "createConfig",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#createConfig",
    "access": "public",
    "description": "Create the project configuration with all its _'smart defaults'_.",
    "lineNumber": 53,
    "return": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 680,
    "kind": "method",
    "name": "_loadConfig",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#_loadConfig",
    "access": "protected",
    "description": "This is the real method that creates and extends the configuration. It's being overwritten\nfor two reasons:\n1. In order to check if the targets finder should try to find the targets information by\nreading the source directory or not.\n2. To check for custom plugins and load them.",
    "lineNumber": 303,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "A list of parameters for the service to use when creating the\n                     configuration. This gets send from {@link ConfigurationFile#getConfig}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 681,
    "kind": "method",
    "name": "_findTargets",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#_findTargets",
    "access": "protected",
    "description": "It tries to find basic targets information by reading the source directory.",
    "lineNumber": 346,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "If there were targets to be found, this will be a dictionary of\n                 {@link TargetsFinderTarget}, with the targets name as keys."
    },
    "params": []
  },
  {
    "__docId__": 682,
    "kind": "method",
    "name": "_getDefaultBuildEngine",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#_getDefaultBuildEngine",
    "access": "protected",
    "description": "Gets the name of the default build engine that the service will use as default for the\ntargets templates. It finds the name by using a list of known engines and checking if any of\nthem was loaded as a plugin.",
    "lineNumber": 363,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 683,
    "kind": "method",
    "name": "_validatePlugins",
    "memberof": "src/services/configurations/projectConfiguration.js~ProjectConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/projectConfiguration.js~ProjectConfiguration#_validatePlugins",
    "access": "protected",
    "description": "This method validates if any of the _\"known plugin paths\"_ exists and add them to the top\nof the list.",
    "lineNumber": 374,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "definedPlugins",
        "description": "The list of plugin paths defined on the configuration."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 684,
    "kind": "variable",
    "name": "projectConfiguration",
    "memberof": "src/services/configurations/projectConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/projectConfiguration.js~projectConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/projectConfiguration.js",
    "importStyle": "{projectConfiguration}",
    "description": "The service provider that once registered on the app container will set an instance of\n`ProjectConfiguration` as the `projectConfiguration` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(projectConfiguration);\n// Getting access to the service instance\nconst projectConfiguration = container.get('projectConfiguration');"
    ],
    "lineNumber": 396,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 685,
    "kind": "file",
    "name": "src/services/configurations/targetConfiguration.js",
    "content": "const { provider } = require('jimple');\nconst ConfigurationFile = require('../../abstracts/configurationFile');\n/**\n * This is a _'tricky'_ service as it only exists to be overwritten. It was created as a dynamic\n * way for a target to extend any configuration. It's service provider returns a function instead\n * of an instance, in which the plugin/service defines any path and then the service gets\n * instantiated.\n * @extends {ConfigurationFile}\n */\nclass TargetConfiguration extends ConfigurationFile {\n  /**\n   * Class constructor.\n   * @param {string}            overwritePath     The path to the overwrite file.\n   * @param {ConfigurationFile} baseConfiguration The configuration this will be extending.\n   * @param {PathUtils}         pathUtils         Because `ConfigurationFile` needs it in order to\n   *                                              build the overwrite path.`\n   */\n  constructor(overwritePath, baseConfiguration, pathUtils) {\n    super(pathUtils, overwritePath, true, baseConfiguration);\n  }\n  /**\n   * Return an empty object just to comply with the interface.\n   * @return {Object}\n   */\n  createConfig() {\n    return {};\n  }\n}\n/**\n * The service provider that once registered on the app container will set an function to get\n * instance of `TargetConfiguration` as the `targetConfiguration` service.\n * @example\n * // Register it on the container\n * container.register(targetConfiguration);\n * // Getting access to the service function\n * const targetConfiguration = container.get('targetConfiguration');\n * // Generating an instance for an specific configurations\n * const myNewConfig = targetConfiguration('./overwrite-path.js', configToExtend).getConfig();\n * @type {Provider}\n */\nconst targetConfiguration = provider((app) => {\n  app.set('targetConfiguration', () => (\n    overwritePath,\n    baseConfiguration\n  ) => new TargetConfiguration(\n    overwritePath,\n    baseConfiguration,\n    app.get('pathUtils')\n  ));\n});\n\nmodule.exports = {\n  TargetConfiguration,\n  targetConfiguration,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/configurations/targetConfiguration.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 686,
    "kind": "class",
    "name": "TargetConfiguration",
    "memberof": "src/services/configurations/targetConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/targetConfiguration.js~TargetConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/targetConfiguration.js",
    "importStyle": "{TargetConfiguration}",
    "description": "This is a _'tricky'_ service as it only exists to be overwritten. It was created as a dynamic\nway for a target to extend any configuration. It's service provider returns a function instead\nof an instance, in which the plugin/service defines any path and then the service gets\ninstantiated.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "ConfigurationFile"
    ]
  },
  {
    "__docId__": 687,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/configurations/targetConfiguration.js~TargetConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/targetConfiguration.js~TargetConfiguration#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "overwritePath",
        "description": "The path to the overwrite file."
      },
      {
        "nullable": null,
        "types": [
          "ConfigurationFile"
        ],
        "spread": false,
        "optional": false,
        "name": "baseConfiguration",
        "description": "The configuration this will be extending."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "Because `ConfigurationFile` needs it in order to\n                                             build the overwrite path.`"
      }
    ]
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "createConfig",
    "memberof": "src/services/configurations/targetConfiguration.js~TargetConfiguration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/configurations/targetConfiguration.js~TargetConfiguration#createConfig",
    "access": "public",
    "description": "Return an empty object just to comply with the interface.",
    "lineNumber": 25,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 689,
    "kind": "variable",
    "name": "targetConfiguration",
    "memberof": "src/services/configurations/targetConfiguration.js",
    "static": true,
    "longname": "src/services/configurations/targetConfiguration.js~targetConfiguration",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/configurations/targetConfiguration.js",
    "importStyle": "{targetConfiguration}",
    "description": "The service provider that once registered on the app container will set an function to get\ninstance of `TargetConfiguration` as the `targetConfiguration` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targetConfiguration);\n// Getting access to the service function\nconst targetConfiguration = container.get('targetConfiguration');\n// Generating an instance for an specific configurations\nconst myNewConfig = targetConfiguration('./overwrite-path.js', configToExtend).getConfig();"
    ],
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 690,
    "kind": "file",
    "name": "src/services/targets/index.js",
    "content": "const { targets } = require('./targets');\nconst { targetsFileRules } = require('./targetsFileRules');\nconst { targetsFinder } = require('./targetsFinder');\nconst { targetsHTML } = require('./targetsHTML');\n\nmodule.exports = {\n  targets,\n  targetsFileRules,\n  targetsFinder,\n  targetsHTML,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 691,
    "kind": "file",
    "name": "src/services/targets/targets.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst { AppConfiguration } = require('wootils/node/appConfiguration');\nconst { provider } = require('jimple');\n/**\n * This service is in charge of loading and managing the project targets information.\n */\nclass Targets {\n  /**\n   * @param {DotEnvUtils}                  dotEnvUtils          To read files with environment\n   *                                                            variables for the targets and\n   *                                                            inject them.\n   * @param {Events}                       events               Used to reduce a target information\n   *                                                            after loading it.\n   * @param {EnvironmentUtils}             environmentUtils     To send to the configuration\n   *                                                            service used by the browser targets.\n   * @param {Object}                       packageInfo          The project's `package.json`,\n   *                                                            necessary to get the project's name\n   *                                                            and use it as the name of the\n   *                                                            default target.\n   * @param {PathUtils}                    pathUtils            Used to build the targets paths.\n   * @param {ProjectConfigurationSettings} projectConfiguration To read the targets and their\n   *                                                            templates.\n   * @param {RootRequire}                  rootRequire          To send to the configuration\n   *                                                            service used by the browser targets.\n   * @param {Utils}                        utils                To replace plaholders on the targets\n   *                                                            paths.\n   */\n  constructor(\n    dotEnvUtils,\n    events,\n    environmentUtils,\n    packageInfo,\n    pathUtils,\n    projectConfiguration,\n    rootRequire,\n    utils\n  ) {\n    /**\n     * A local reference for the `dotEnvUtils` service.\n     * @type {DotEnvUtils}\n     */\n    this.dotEnvUtils = dotEnvUtils;\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A local reference for the `environmentUtils` service.\n     * @type {EnvironmentUtils}\n     */\n    this.environmentUtils = environmentUtils;\n    /**\n     * The information of the project's `package.json`.\n     * @type {Object}\n     */\n    this.packageInfo = packageInfo;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * All the project settings.\n     * @type {ProjectConfigurationSettings}\n     */\n    this.projectConfiguration = projectConfiguration;\n    /**\n     * A local reference for the `rootRequire` function service.\n     * @type {RootRequire}\n     */\n    this.rootRequire = rootRequire;\n    /**\n     * A local reference for the `utils` service.\n     * @type {Utils}\n     */\n    this.utils = utils;\n    /**\n     * A dictionary that will be filled with the targets information.\n     * @type {Object}\n     */\n    this.targets = {};\n    /**\n     * A simple regular expression to validate a target type.\n     * @type {RegExp}\n     */\n    this.typesValidationRegex = /^(?:node|browser)$/i;\n    /**\n     * The default type a target will be if it doesn't have a `type` property.\n     * @type {string}\n     */\n    this.defaultType = 'node';\n    this.loadTargets();\n  }\n  /**\n   * Loads and build the target information.\n   * This method emits the reducer event `target-load` with the information of a loaded target and\n   * expects an object with a target information on return.\n   * @throws {Error} If a target has a type but it doesn't match a supported type\n   *                 (`node` or `browser`).\n   * @throws {Error} If a target requires bundling but there's no build engine installed.\n   */\n  loadTargets() {\n    const {\n      targets,\n      paths: { source, build },\n      targetsTemplates,\n    } = this.projectConfiguration;\n    // Loop all the targets on the project configuration...\n    Object.keys(targets).forEach((name) => {\n      const target = targets[name];\n      // Normalize the information from the target definition.\n      const info = this._normalizeTargetDefinition(name, target);\n      // Get the type template.\n      const template = targetsTemplates[info.type];\n      /**\n       * Create the new target information by merging the template, the target information from\n       * the configuration and the information defined by this method.\n       */\n      const newTarget = ObjectUtils.merge(template, target, {\n        name,\n        type: info.type,\n        paths: {\n          source: '',\n          build: '',\n        },\n        folders: {\n          source: '',\n          build: '',\n        },\n        is: info.is,\n      });\n      // Validate if the target requires bundling and the `engine` setting is invalid.\n      this._validateTargetEngine(newTarget);\n      // Check if there are missing entries and fill them with the default value.\n      newTarget.entry = this._normalizeTargetEntry(newTarget.entry);\n      // Check if there are missing entries and merge them with the default value.\n      newTarget.output = this._normalizeTargetOutput(newTarget.output);\n      /**\n       * Keep the original output settings without the placeholders so internal services or\n       * plugins can use them.\n       */\n      newTarget.originalOutput = ObjectUtils.copy(newTarget.output);\n      // Replace placeholders on the output settings\n      newTarget.output = this._replaceTargetOutputPlaceholders(newTarget);\n\n      /**\n       * To avoid merge issues with arrays (they get merge \"by index\"), if the target already\n       * had a defined list of files for the dotEnv feature, overwrite whatever is on the\n       * template.\n       */\n      if (target.dotEnv && target.dotEnv.files && target.dotEnv.files.length) {\n        newTarget.dotEnv.files = target.dotEnv.files;\n      }\n\n      // If the target has an `html` setting...\n      if (newTarget.html) {\n        // Check if there are missing settings that should be replaced with a fallback.\n        newTarget.html = this._normalizeTargetHTML(newTarget.html);\n      }\n      /**\n       * If the target doesn't have the `typeScript` option enabled but one of the entry files\n       * extension is `.ts`, turn on the option; and if the extension is `.tsx`, set the\n       * framework to React.\n       */\n      if (!newTarget.typeScript) {\n        const hasATSFile = Object.keys(newTarget.entry).some((entryEnv) => {\n          let found = false;\n          const entryFile = newTarget.entry[entryEnv];\n          if (entryFile) {\n            found = entryFile.match(/\\.tsx?$/i);\n            if (\n              found &&\n              entryFile.match(/\\.tsx$/i) &&\n              typeof newTarget.framework === 'undefined'\n            ) {\n              newTarget.framework = 'react';\n            }\n          }\n\n          return found;\n        });\n\n        if (hasATSFile) {\n          newTarget.typeScript = true;\n        }\n      }\n\n      // Check if the target should be transpiled (You can't use types without transpilation).\n      if (!newTarget.transpile && (newTarget.flow || newTarget.typeScript)) {\n        newTarget.transpile = true;\n      }\n\n      // Generate the target paths and folders.\n      newTarget.folders.source = newTarget.hasFolder ?\n        path.join(source, info.sourceFolderName) :\n        source;\n      newTarget.paths.source = this.pathUtils.join(newTarget.folders.source);\n\n      newTarget.folders.build = path.join(build, info.buildFolderName);\n      newTarget.paths.build = this.pathUtils.join(newTarget.folders.build);\n      // Reduce the target information and save it on the service dictionary.\n      this.targets[name] = this.events.reduce('target-load', newTarget);\n    });\n  }\n  /**\n   * Get all the registered targets information on a dictionary that uses their names as keys.\n   * @return {Object}\n   */\n  getTargets() {\n    return this.targets;\n  }\n  /**\n   * Validate whether a target exists or not.\n   * @param {string} name The target name.\n   * @return {boolean}\n   */\n  targetExists(name) {\n    return !!this.getTargets()[name];\n  }\n  /**\n   * Get a target information by its name.\n   * @param {string} name The target name.\n   * @return {Target}\n   * @throws {Error} If there's no target with the given name.\n   */\n  getTarget(name) {\n    const target = this.getTargets()[name];\n    if (!target) {\n      throw new Error(`The required target doesn't exist: ${name}`);\n    }\n\n    return target;\n  }\n  /**\n   * Returns the target with the name of project (specified on the `package.json`) and if there's\n   * no target with that name, then the first one, using a list of the targets name on alphabetical\n   * order.\n   * @param {string} [type=''] A specific target type, `node` or `browser`.\n   * @return {Target}\n   * @throws {Error} If the project has no targets\n   * @throws {Error} If the project has no targets of the specified type.\n   * @throws {Error} If a specified target type is invalid.\n   */\n  getDefaultTarget(type = '') {\n    const allTargets = this.getTargets();\n    let targets = {};\n    if (type && !['node', 'browser'].includes(type)) {\n      throw new Error(`Invalid target type: ${type}`);\n    } else if (type) {\n      Object.keys(allTargets).forEach((targetName) => {\n        const target = allTargets[targetName];\n        if (target.type === type) {\n          targets[targetName] = target;\n        }\n      });\n    } else {\n      targets = allTargets;\n    }\n\n    const names = Object.keys(targets).sort();\n    let target;\n    if (names.length) {\n      const { name: projectName } = this.packageInfo;\n      target = targets[projectName] || targets[names[0]];\n    } else if (type) {\n      throw new Error(`The project doesn't have any targets of the required type: ${type}`);\n    } else {\n      throw new Error('The project doesn\\'t have any targets');\n    }\n\n    return target;\n  }\n  /**\n   * Find a target by a given filepath.\n   * @param {string} file The path of the file that should match with a target path.\n   * @return {Target}\n   * @throws {Error} If no target is found.\n   */\n  findTargetForFile(file) {\n    const targets = this.getTargets();\n    const targetName = Object.keys(targets)\n    .find((name) => file.includes(targets[name].paths.source));\n\n    if (!targetName) {\n      throw new Error(`A target couldn't be find for the following file: ${file}`);\n    }\n\n    return targets[targetName];\n  }\n  /**\n   * Gets an _'App Configuration'_ for a browser target. This is a utility projext provides for\n   * browser targets as they can't load configuration files dynamically, so on the building process,\n   * projext uses this service to load the configuration and then injects it on the target bundle.\n   * @param {Target} target The target information.\n   * @return {Object}\n   * @property {Object} configuration The target _'App Configuration'_.\n   * @property {Array}  files         The list of files loaded in order to create the\n   *                                  configuration.\n   * @throws {Error} If the given target is not a browser target.\n   */\n  getBrowserTargetConfiguration(target) {\n    if (target.is.node) {\n      throw new Error('Only browser targets can generate configuration on the building process');\n    }\n    // Get the configuration settings from the target information.\n    const {\n      name,\n      configuration: {\n        enabled,\n        default: defaultConfiguration,\n        path: configurationsPath,\n        hasFolder,\n        environmentVariable,\n        loadFromEnvironment,\n        filenameFormat,\n      },\n    } = target;\n    const result = {\n      configuration: {},\n      files: [],\n    };\n    // If the configuration feature is enabled...\n    if (enabled) {\n      // Define the path where the configuration files are located.\n      let configsPath = configurationsPath;\n      if (hasFolder) {\n        configsPath += `${name}/`;\n      }\n      // Prepare the filename format the `AppConfiguration` class uses.\n      const filenameNewFormat = filenameFormat\n      .replace(/\\[target-name\\]/ig, name)\n      .replace(/\\[configuration-name\\]/ig, '[name]');\n\n      /**\n       * The idea of `files` and this small wrapper around `rootRequire` is for the method to be\n       * able to identify all the external files that were involved on the configuration creation.\n       * Then the method can return the list, so the build engine can also watch for those files\n       * and reload the target not only when the source changes, but when the config changes too.\n       */\n      const files = [];\n      const rootRequireAndSave = (filepath) => {\n        files.push(filepath);\n        // Delete the file cache entry so it can be rebuilt in case env vars were updated.\n        delete require.cache[this.pathUtils.join(filepath)];\n        return this.rootRequire(filepath);\n      };\n\n      let defaultConfig = {};\n      // If the feature options include a default configuration...\n      if (defaultConfiguration) {\n        // ...use it.\n        defaultConfig = defaultConfiguration;\n      } else {\n        // ...otherwise, load it from a configuration file.\n        const defaultConfigPath = `${configsPath}${name}.config.js`;\n        defaultConfig = rootRequireAndSave(defaultConfigPath);\n      }\n\n      /**\n       * Create a new instance of `AppConfiguration` in order to handle the environment and the\n       * merging of the configurations.\n       */\n      const appConfiguration = new AppConfiguration(\n        this.environmentUtils,\n        rootRequireAndSave,\n        name,\n        defaultConfig,\n        {\n          environmentVariable,\n          path: configsPath,\n          filenameFormat: filenameNewFormat,\n        }\n      );\n      // If the feature supports loading a configuration using an environment variable...\n      if (loadFromEnvironment) {\n        // ...Tell the instance of `AppConfiguration` to look for it.\n        appConfiguration.loadFromEnvironment();\n      }\n      // Finally, set to return the configuration generated by the service.\n      result.configuration = appConfiguration.getConfig();\n      result.files = files;\n    }\n\n    return result;\n  }\n  /**\n   * Loads the environment file(s) for a target and, if specified, inject their variables.\n   * This method uses the `target-environment-variables` reducer event, which receives the\n   * dictionary with the variables for the target, the target information and the build type; it\n   * expects an updated dictionary of variables in return.\n   * @param {Target}  target                    The target information.\n   * @param {string}  [buildType='development'] The type of bundle projext is generating or the\n   *                                            environment a Node target is being executed for.\n   * @param {boolean} [inject=true]             Whether or not to inject the variables after\n   *                                            loading them.\n   * @return {Object} A dictionary with the target variables that were injected in the environment.\n   */\n  loadTargetDotEnvFile(target, buildType = 'development', inject = true) {\n    let result;\n    if (target.dotEnv.enabled && target.dotEnv.files.length) {\n      const files = target.dotEnv.files.map((file) => (\n        file\n        .replace(/\\[target-name\\]/ig, target.name)\n        .replace(/\\[build-type\\]/ig, buildType)\n      ));\n      const parsed = this.dotEnvUtils.load(files, target.dotEnv.extend);\n      if (parsed.loaded) {\n        result = this.events.reduce(\n          'target-environment-variables',\n          parsed.variables,\n          target,\n          buildType\n        );\n\n        if (inject) {\n          this.dotEnvUtils.inject(result);\n        }\n      }\n    }\n\n    return result || {};\n  }\n  /**\n   * Gets a list with the information for the files the target needs to copy during the\n   * bundling process.\n   * This method uses the `target-copy-files` reducer event, which receives the list of files to\n   * copy, the target information and the build type; it expects an updated list on return.\n   * The reducer event can be used to inject a {@link TargetExtraFileTransform} function.\n   * @param {Target} target                    The target information.\n   * @param {string} [buildType='development'] The type of bundle projext is generating.\n   * @return {Array} A list of {@link TargetExtraFile}s.\n   * @throws {Error} If the target type is `node` but bundling is disabled. There's no need to copy\n   *                 files on a target that doesn't require bundling.\n   * @throws {Error} If one of the files to copy doesn't exist.\n   */\n  getFilesToCopy(target, buildType = 'development') {\n    // Validate the target settings\n    if (target.is.node && !target.bundle) {\n      throw new Error('Only targets that require bundling can copy files');\n    }\n    // Get the target paths.\n    const {\n      paths: {\n        build,\n        source,\n      },\n    } = target;\n    // Format the list.\n    let newList = target.copy.map((item) => {\n      // Define an item structure.\n      const newItem = {\n        from: '',\n        to: '',\n      };\n      /**\n       * If the item is a string, use its name and copy it to the target distribution directory\n       * root; but if the target is an object, just prefix its paths with the target directories.\n       */\n      if (typeof item === 'string') {\n        const filename = path.basename(item);\n        newItem.from = path.join(source, item);\n        newItem.to = path.join(build, filename);\n      } else {\n        newItem.from = path.join(source, item.from);\n        newItem.to = path.join(build, item.to);\n      }\n\n      return newItem;\n    });\n\n    // Reduce the list.\n    newList = this.events.reduce('target-copy-files', newList, target, buildType);\n\n    const invalid = newList.find((item) => !fs.pathExistsSync(item.from));\n    if (invalid) {\n      throw new Error(`The file to copy doesn't exist: ${invalid.from}`);\n    }\n\n    return newList;\n  }\n  /**\n   * Validates a type specified on a target definition.\n   * @param {String} name       The name of the target. To generate the error message if needed.\n   * @param {Object} definition The definition of the target on the project configuration. This\n   *                            is like an incomplete {@link Target}.\n   * @throws {Error} If a target has a type but it doesn't match\n   *                 {@link Targets#typesValidationRegex}.\n   * @access protected\n   * @ignore\n   */\n  _validateTargetDefinitionType(name, definition) {\n    if (definition.type && !this.typesValidationRegex.test(definition.type)) {\n      throw new Error(`Target ${name} has an invalid type: ${definition.type}`);\n    }\n  }\n  /**\n   * Normalizes the information of a target definition in order for the service to create an\n   * actual {@link Target} from it.\n   * @param {String} name       The name of the target. To generate the error message if needed.\n   * @param {Object} definition The definition of the target on the project configuration. This\n   *                            is like an incomplete {@link Target}.\n   * @return {Object} Basic information generated from the definition.\n   * @property {String}          sourceFolderName The name of the folder where the target source\n   *                                              is located.\n   * @property {String}          buildFolderName  The name of the folder (inside the distribution\n   *                                              directory) where the target will be built.\n   * @property {String}          type             The target type (`node` or `browser`).\n   * @property {TargetTypeCheck} is               To check whether the target type is `node` or\n   *                                              `browser`.\n   * @access protected\n   * @ignore\n   */\n  _normalizeTargetDefinition(name, definition) {\n    this._validateTargetDefinitionType(name, definition);\n    // Define the target folders.\n    const sourceFolderName = definition.folder || name;\n    const buildFolderName = definition.createFolder ? sourceFolderName : '';\n    // Define the target type.\n    const type = definition.type || this.defaultType;\n    const isNode = type === 'node';\n    return {\n      sourceFolderName,\n      buildFolderName,\n      type,\n      is: {\n        node: isNode,\n        browser: !isNode,\n      },\n    };\n  }\n  /**\n   * Validates if a target requires bundling but there's no build engine installed. The targets'\n   * `engine` setting comes from the {@link ProjectConfiguration} templates, which are updated\n   * by projext when it detects a build engine installed; so if the setting is empty, it means\n   * that projext didn't find anything.\n   * @param {Target} target The target information.\n   * @throws {Error} If the target requires bundling but there's no build engine installed.\n   * @access protected\n   * @ignore\n   */\n  _validateTargetEngine(target) {\n    if (!target.engine && (target.is.browser || target.bundle)) {\n      throw new Error(\n        `The target '${target.name}' requires bundling, but there's ` +\n        'no build engine plugin installed'\n      );\n    }\n  }\n  /**\n   * Checks if there are missing entries that need to be replaced with the default fallback, and in\n   * case there are, a new set of entries will be generated and returned.\n   * @param {ProjectConfigurationTargetTemplateEntry} currentEntry\n   * The entries defined on the target after merging it with its type template.\n   * @return {ProjectConfigurationTargetTemplateEntry}\n   * @ignore\n   * @protected\n   */\n  _normalizeTargetEntry(currentEntry) {\n    return this._normalizeSettingsWithDefault(currentEntry);\n  }\n  /**\n   * Checks if there are missing output settings that need to be merged with the ones on the\n   * default fallback, and in case there are, a new set of output settings will be generated and\n   * returned.\n   * @param {ProjectConfigurationTargetTemplateOutput} currentOutput\n   * The output settings defined on the target after merging it with its type template.\n   * @return {ProjectConfigurationTargetTemplateOutput}\n   * @ignore\n   * @protected\n   */\n  _normalizeTargetOutput(currentOutput) {\n    const newOutput = Object.assign({}, currentOutput);\n    const { default: defaultOutput } = newOutput;\n    delete newOutput.default;\n    if (defaultOutput) {\n      Object.keys(newOutput).forEach((name) => {\n        const value = newOutput[name];\n        if (value === null) {\n          newOutput[name] = Object.assign({}, defaultOutput);\n        } else {\n          newOutput[name] = ObjectUtils.merge(defaultOutput, value);\n          Object.keys(newOutput[name]).forEach((propName) => {\n            if (!newOutput[name][propName] && defaultOutput[propName]) {\n              newOutput[name][propName] = defaultOutput[propName];\n            }\n          });\n        }\n      });\n    }\n\n    return newOutput;\n  }\n  /**\n   * Replace the common placeholders from a target output paths.\n   * @param {Target} target The target information.\n   * @return {\n   *  ProjectConfigurationNodeTargetTemplateOutput|ProjectConfigurationBoTargetTemplateOutput\n   * }\n   * @ignore\n   * @protected\n   */\n  _replaceTargetOutputPlaceholders(target) {\n    const placeholders = {\n      'target-name': target.name,\n      hash: Date.now(),\n    };\n\n    const newOutput = Object.assign({}, target.output);\n    Object.keys(newOutput).forEach((name) => {\n      const value = newOutput[name];\n      Object.keys(value).forEach((propName) => {\n        const propValue = newOutput[name][propName];\n        newOutput[name][propName] = typeof propValue === 'string' ?\n          this.utils.replacePlaceholders(\n            propValue,\n            placeholders\n          ) :\n          propValue;\n      });\n    });\n\n    return newOutput;\n  }\n  /**\n   * Checks if there are missing HTML settings that need to be replaced with the default fallback,\n   * and in case there are, a new set of settings will be generated and returned.\n   * @param {ProjectConfigurationBrowserTargetTemplateHTMLSettings} currentHTML\n   * The HTML settings defined on the target after merging it with its type template.\n   * @return {ProjectConfigurationBrowserTargetTemplateHTMLSettings}\n   * @ignore\n   * @protected\n   */\n  _normalizeTargetHTML(currentHTML) {\n    return this._normalizeSettingsWithDefault(currentHTML);\n  }\n  /**\n   * Given a dictionary of settings that contains a `default` key, this method will check each of\n   * the other keys and if its find any `null` value, it will replace that key value with the one\n   * on the `default` key.\n   * @param {Object} currentSettings The dictionary to \"complete\".\n   * @property {*} default The default value that will be assigned to any other key with `null`\n   *                       value.\n   * @return {Object}\n   * @ignore\n   * @protected\n   */\n  _normalizeSettingsWithDefault(currentSettings) {\n    const newSettings = Object.assign({}, currentSettings);\n    const { default: defaultValue } = newSettings;\n    delete newSettings.default;\n    if (defaultValue !== null) {\n      Object.keys(newSettings).forEach((name) => {\n        if (newSettings[name] === null) {\n          newSettings[name] = defaultValue;\n        }\n      });\n    }\n\n    return newSettings;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `Targets` as the `targets` service.\n * @example\n * // Register it on the container\n * container.register(targets);\n * // Getting access to the service instance\n * const targets = container.get('targets');\n * @type {Provider}\n */\nconst targets = provider((app) => {\n  app.set('targets', () => new Targets(\n    app.get('dotEnvUtils'),\n    app.get('events'),\n    app.get('environmentUtils'),\n    app.get('packageInfo'),\n    app.get('pathUtils'),\n    app.get('projectConfiguration').getConfig(),\n    app.get('rootRequire'),\n    app.get('utils')\n  ));\n});\n\nmodule.exports = {\n  Targets,\n  targets,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targets.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 692,
    "kind": "class",
    "name": "Targets",
    "memberof": "src/services/targets/targets.js",
    "static": true,
    "longname": "src/services/targets/targets.js~Targets",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targets.js",
    "importStyle": "{Targets}",
    "description": "This service is in charge of loading and managing the project targets information.",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 693,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "DotEnvUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "dotEnvUtils",
        "description": "To read files with environment\n                                                           variables for the targets and\n                                                           inject them."
      },
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "Used to reduce a target information\n                                                           after loading it."
      },
      {
        "nullable": null,
        "types": [
          "EnvironmentUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "environmentUtils",
        "description": "To send to the configuration\n                                                           service used by the browser targets."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "packageInfo",
        "description": "The project's `package.json`,\n                                                           necessary to get the project's name\n                                                           and use it as the name of the\n                                                           default target."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "Used to build the targets paths."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "projectConfiguration",
        "description": "To read the targets and their\n                                                           templates."
      },
      {
        "nullable": null,
        "types": [
          "RootRequire"
        ],
        "spread": false,
        "optional": false,
        "name": "rootRequire",
        "description": "To send to the configuration\n                                                           service used by the browser targets."
      },
      {
        "nullable": null,
        "types": [
          "Utils"
        ],
        "spread": false,
        "optional": false,
        "name": "utils",
        "description": "To replace plaholders on the targets\n                                                           paths."
      }
    ]
  },
  {
    "__docId__": 694,
    "kind": "member",
    "name": "dotEnvUtils",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#dotEnvUtils",
    "access": "public",
    "description": "A local reference for the `dotEnvUtils` service.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "DotEnvUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 695,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 696,
    "kind": "member",
    "name": "environmentUtils",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#environmentUtils",
    "access": "public",
    "description": "A local reference for the `environmentUtils` service.",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "EnvironmentUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 697,
    "kind": "member",
    "name": "packageInfo",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#packageInfo",
    "access": "public",
    "description": "The information of the project's `package.json`.",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 698,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 699,
    "kind": "member",
    "name": "projectConfiguration",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#projectConfiguration",
    "access": "public",
    "description": "All the project settings.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "ProjectConfigurationSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 700,
    "kind": "member",
    "name": "rootRequire",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#rootRequire",
    "access": "public",
    "description": "A local reference for the `rootRequire` function service.",
    "lineNumber": 74,
    "type": {
      "nullable": null,
      "types": [
        "RootRequire"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 701,
    "kind": "member",
    "name": "utils",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#utils",
    "access": "public",
    "description": "A local reference for the `utils` service.",
    "lineNumber": 79,
    "type": {
      "nullable": null,
      "types": [
        "Utils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 702,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#targets",
    "access": "public",
    "description": "A dictionary that will be filled with the targets information.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 703,
    "kind": "member",
    "name": "typesValidationRegex",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#typesValidationRegex",
    "access": "public",
    "description": "A simple regular expression to validate a target type.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 704,
    "kind": "member",
    "name": "defaultType",
    "memberof": "src/services/targets/targets.js~Targets",
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#defaultType",
    "access": "public",
    "description": "The default type a target will be if it doesn't have a `type` property.",
    "lineNumber": 94,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "loadTargets",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#loadTargets",
    "access": "public",
    "description": "Loads and build the target information.\nThis method emits the reducer event `target-load` with the information of a loaded target and\nexpects an object with a target information on return.",
    "lineNumber": 105,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If a target has a type but it doesn't match a supported type\n                (`node` or `browser`)."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If a target requires bundling but there's no build engine installed."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 706,
    "kind": "method",
    "name": "getTargets",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#getTargets",
    "access": "public",
    "description": "Get all the registered targets information on a dictionary that uses their names as keys.",
    "lineNumber": 212,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "targetExists",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#targetExists",
    "access": "public",
    "description": "Validate whether a target exists or not.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The target name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 708,
    "kind": "method",
    "name": "getTarget",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#getTarget",
    "access": "public",
    "description": "Get a target information by its name.",
    "lineNumber": 229,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The target name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Target"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If there's no target with the given name."
      }
    ]
  },
  {
    "__docId__": 709,
    "kind": "method",
    "name": "getDefaultTarget",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#getDefaultTarget",
    "access": "public",
    "description": "Returns the target with the name of project (specified on the `package.json`) and if there's\nno target with that name, then the first one, using a list of the targets name on alphabetical\norder.",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "type",
        "description": "A specific target type, `node` or `browser`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Target"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the project has no targets"
      },
      {
        "types": [
          "Error"
        ],
        "description": "If the project has no targets of the specified type."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If a specified target type is invalid."
      }
    ]
  },
  {
    "__docId__": 710,
    "kind": "method",
    "name": "findTargetForFile",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#findTargetForFile",
    "access": "public",
    "description": "Find a target by a given filepath.",
    "lineNumber": 282,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path of the file that should match with a target path."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Target"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no target is found."
      }
    ]
  },
  {
    "__docId__": 711,
    "kind": "method",
    "name": "getBrowserTargetConfiguration",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#getBrowserTargetConfiguration",
    "access": "public",
    "description": "Gets an _'App Configuration'_ for a browser target. This is a utility projext provides for\nbrowser targets as they can't load configuration files dynamically, so on the building process,\nprojext uses this service to load the configuration and then injects it on the target bundle.",
    "lineNumber": 304,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "The target _'App Configuration'_."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "The list of files loaded in order to create the\n                                 configuration."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the given target is not a browser target."
      }
    ]
  },
  {
    "__docId__": 712,
    "kind": "method",
    "name": "loadTargetDotEnvFile",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#loadTargetDotEnvFile",
    "access": "public",
    "description": "Loads the environment file(s) for a target and, if specified, inject their variables.\nThis method uses the `target-environment-variables` reducer event, which receives the\ndictionary with the variables for the target, the target information and the build type; it\nexpects an updated dictionary of variables in return.",
    "lineNumber": 401,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The type of bundle projext is generating or the\n                                           environment a Node target is being executed for."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "inject",
        "description": "Whether or not to inject the variables after\n                                           loading them."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A dictionary with the target variables that were injected in the environment."
    }
  },
  {
    "__docId__": 713,
    "kind": "method",
    "name": "getFilesToCopy",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#getFilesToCopy",
    "access": "public",
    "description": "Gets a list with the information for the files the target needs to copy during the\nbundling process.\nThis method uses the `target-copy-files` reducer event, which receives the list of files to\ncopy, the target information and the build type; it expects an updated list on return.\nThe reducer event can be used to inject a {@link TargetExtraFileTransform} function.",
    "lineNumber": 439,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'development'",
        "defaultRaw": "'development'",
        "name": "buildType",
        "description": "The type of bundle projext is generating."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of {@link TargetExtraFile}s."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target type is `node` but bundling is disabled. There's no need to copy\n                files on a target that doesn't require bundling."
      },
      {
        "types": [
          "Error"
        ],
        "description": "If one of the files to copy doesn't exist."
      }
    ]
  },
  {
    "__docId__": 714,
    "kind": "method",
    "name": "_validateTargetDefinitionType",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_validateTargetDefinitionType",
    "access": "protected",
    "description": "Validates a type specified on a target definition.",
    "lineNumber": 494,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target. To generate the error message if needed."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "definition",
        "description": "The definition of the target on the project configuration. This\n                           is like an incomplete {@link Target}."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If a target has a type but it doesn't match\n                {@link Targets#typesValidationRegex}."
      }
    ],
    "return": null
  },
  {
    "__docId__": 715,
    "kind": "method",
    "name": "_normalizeTargetDefinition",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_normalizeTargetDefinition",
    "access": "protected",
    "description": "Normalizes the information of a target definition in order for the service to create an\nactual {@link Target} from it.",
    "lineNumber": 516,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target. To generate the error message if needed."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "definition",
        "description": "The definition of the target on the project configuration. This\n                           is like an incomplete {@link Target}."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceFolderName",
        "description": "The name of the folder where the target source\n                                             is located."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "buildFolderName",
        "description": "The name of the folder (inside the distribution\n                                             directory) where the target will be built."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The target type (`node` or `browser`)."
      },
      {
        "nullable": null,
        "types": [
          "TargetTypeCheck"
        ],
        "spread": false,
        "optional": false,
        "name": "is",
        "description": "To check whether the target type is `node` or\n                                             `browser`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Basic information generated from the definition."
    }
  },
  {
    "__docId__": 716,
    "kind": "method",
    "name": "_validateTargetEngine",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_validateTargetEngine",
    "access": "protected",
    "description": "Validates if a target requires bundling but there's no build engine installed. The targets'\n`engine` setting comes from the {@link ProjectConfiguration} templates, which are updated\nby projext when it detects a build engine installed; so if the setting is empty, it means\nthat projext didn't find anything.",
    "lineNumber": 544,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the target requires bundling but there's no build engine installed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 717,
    "kind": "method",
    "name": "_normalizeTargetEntry",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_normalizeTargetEntry",
    "access": "protected",
    "description": "Checks if there are missing entries that need to be replaced with the default fallback, and in\ncase there are, a new set of entries will be generated and returned.",
    "lineNumber": 561,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateEntry"
        ],
        "spread": false,
        "optional": false,
        "name": "currentEntry",
        "description": "The entries defined on the target after merging it with its type template."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ProjectConfigurationTargetTemplateEntry"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 718,
    "kind": "method",
    "name": "_normalizeTargetOutput",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_normalizeTargetOutput",
    "access": "protected",
    "description": "Checks if there are missing output settings that need to be merged with the ones on the\ndefault fallback, and in case there are, a new set of output settings will be generated and\nreturned.",
    "lineNumber": 574,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": false,
        "name": "currentOutput",
        "description": "The output settings defined on the target after merging it with its type template."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ProjectConfigurationTargetTemplateOutput"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 719,
    "kind": "method",
    "name": "_replaceTargetOutputPlaceholders",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_replaceTargetOutputPlaceholders",
    "access": "protected",
    "description": "Replace the common placeholders from a target output paths.",
    "lineNumber": 605,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "\n ProjectConfigurationNodeTargetTemplateOutput",
        "ProjectConfigurationBoTargetTemplateOutput\n"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "_normalizeTargetHTML",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_normalizeTargetHTML",
    "access": "protected",
    "description": "Checks if there are missing HTML settings that need to be replaced with the default fallback,\nand in case there are, a new set of settings will be generated and returned.",
    "lineNumber": 636,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateHTMLSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "currentHTML",
        "description": "The HTML settings defined on the target after merging it with its type template."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ProjectConfigurationBrowserTargetTemplateHTMLSettings"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 721,
    "kind": "method",
    "name": "_normalizeSettingsWithDefault",
    "memberof": "src/services/targets/targets.js~Targets",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targets.js~Targets#_normalizeSettingsWithDefault",
    "access": "protected",
    "description": "Given a dictionary of settings that contains a `default` key, this method will check each of\nthe other keys and if its find any `null` value, it will replace that key value with the one\non the `default` key.",
    "lineNumber": 650,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "currentSettings",
        "description": "The dictionary to \"complete\"."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "default",
        "description": "The default value that will be assigned to any other key with `null`\n                      value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 722,
    "kind": "variable",
    "name": "targets",
    "memberof": "src/services/targets/targets.js",
    "static": true,
    "longname": "src/services/targets/targets.js~targets",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targets.js",
    "importStyle": "{targets}",
    "description": "The service provider that once registered on the app container will set an instance of\n`Targets` as the `targets` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targets);\n// Getting access to the service instance\nconst targets = container.get('targets');"
    ],
    "lineNumber": 675,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 723,
    "kind": "file",
    "name": "src/services/targets/targetsFileRules/index.js",
    "content": "const { targetsFileRules } = require('./targetsFileRules');\n\nmodule.exports = {\n  targetsFileRules,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targetsFileRules/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 724,
    "kind": "file",
    "name": "src/services/targets/targetsFileRules/targetFileRule.js",
    "content": "const ObjectUtils = require('wootils/shared/objectUtils');\n/**\n * Helper service used by {@link TargetsFileRules} in order to create dynamic file rules for\n * multiple purposes.\n */\nclass TargetFileRule {\n  /**\n   * @param {Events}                events                   To reduce the rule settings updated.\n   * @param {Targets}               targets                  To get the information of other targets\n   *                                                         from the `includeTargets` setting.\n   * @param {string}                ruleType                 A reference identifier that tells for\n   *                                                         which kind file type the rule is\n   *                                                         being used for.\n   * @param {TargetFileRuleHandler} getSettingsForTargetRule To define the rule settings whenever\n   *                                                         a new target is added.\n   * @throws {Error} If `getSettingsForTargetRule` is not a function.\n   */\n  constructor(events, targets, ruleType, getSettingsForTargetRule) {\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n    // Validate the handler function.\n    if (typeof getSettingsForTargetRule !== 'function') {\n      throw new Error('You need to specify a handler function for when a new target is added');\n    }\n    /**\n     * The reference identifier for the kind of rule this is for.\n     * @type {string}\n     * @access protected\n     * @ignore\n     */\n    this._ruleType = ruleType;\n    /**\n     * The function that generates the new settings when a new target is added.\n     * @type {TargetFileRuleHandler}\n     * @access protected\n     * @ignore\n     */\n    this._getSettingsForTargetRule = getSettingsForTargetRule;\n    /**\n     * The rule settings.\n     * @type {TargetFileRuleSettings}\n     * @access protected\n     * @ignore\n     */\n    this._rule = {\n      extension: /\\.\\w+$/i,\n      glob: '**/*.*',\n      paths: {\n        include: [],\n        exclude: [],\n      },\n      files: {\n        include: [],\n        exclude: [],\n        glob: {\n          include: [],\n          exclude: [],\n        },\n      },\n    };\n    /**\n     * Whether or not a target has been added to the rule.\n     * @type {boolean}\n     * @access protected\n     * @ignore\n     */\n    this._hasTarget = false;\n  }\n  /**\n   * Get the rule settings.\n   * @return {TargetFileRuleSettings}\n   */\n  getRule() {\n    return this._rule;\n  }\n  /**\n   * Add a target to the rule. This means the instance will process it and eventually add its\n   * paths to the settings.\n   * This method uses the reducer event `target-file-rule`, and if a target was already added,\n   * `target-file-rule-update` too. Both events receive the next state of the settings as well\n   * as the current, and expect the final state on return.\n   * @param {Target} target The target information.\n   */\n  addTarget(target) {\n    const changes = ObjectUtils.copy(\n      this._getSettingsForTargetRule(target, this._hasTarget, this._rule)\n    );\n\n    const finalRule = this._mergeRule(this._rule, changes);\n\n    const events = ['target-file-rule'];\n    if (this._hasTarget) {\n      events.push('target-file-rule-update');\n    }\n\n    this._hasTarget = true;\n    this._rule = this.events.reduce(events, finalRule, this._rule);\n    target.includeTargets.forEach((targetName) => {\n      const targetInfo = this.targets.getTarget(targetName);\n      this.addTarget(targetInfo);\n    });\n  }\n  /**\n   * Merge two sets of rule settings. This is also used recursively to merge nested settings.\n   * @param {TargetFileRuleSettings|Object} base    The original rule or a set of properties of\n   *                                                the original rule.\n   * @param {TargetFileRuleSettings|Object} changes The rule that will be merged into the origina,\n   *                                                or a set of properties from it.\n   * @return {TargetFileRuleSettings|Object} The merged rule, or a set of merge properties.\n   * @access protected\n   * @ignore\n   */\n  _mergeRule(base, changes) {\n    const newRule = ObjectUtils.copy(base);\n    Object.keys(changes).forEach((property) => {\n      const value = changes[property];\n      const propertyType = typeof value;\n      if (Array.isArray(value)) {\n        newRule[property].push(...value);\n      } else if (value instanceof RegExp) {\n        newRule[property] = value;\n      } else if (propertyType === 'object') {\n        newRule[property] = this._mergeRule(newRule[property], value);\n      } else {\n        newRule[property] = value;\n      }\n    });\n\n    return newRule;\n  }\n}\n\nmodule.exports = TargetFileRule;\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targetsFileRules/targetFileRule.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 725,
    "kind": "class",
    "name": "TargetFileRule",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js",
    "static": true,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsFileRules/targetFileRule.js",
    "importStyle": "TargetFileRule",
    "description": "Helper service used by {@link TargetsFileRules} in order to create dynamic file rules for\nmultiple purposes.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 726,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To reduce the rule settings updated."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get the information of other targets\n                                                        from the `includeTargets` setting."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ruleType",
        "description": "A reference identifier that tells for\n                                                        which kind file type the rule is\n                                                        being used for."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRuleHandler"
        ],
        "spread": false,
        "optional": false,
        "name": "getSettingsForTargetRule",
        "description": "To define the rule settings whenever\n                                                        a new target is added."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If `getSettingsForTargetRule` is not a function."
      }
    ]
  },
  {
    "__docId__": 727,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 728,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 729,
    "kind": "member",
    "name": "_ruleType",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#_ruleType",
    "access": "protected",
    "description": "The reference identifier for the kind of rule this is for.",
    "lineNumber": 39,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 730,
    "kind": "member",
    "name": "_getSettingsForTargetRule",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#_getSettingsForTargetRule",
    "access": "protected",
    "description": "The function that generates the new settings when a new target is added.",
    "lineNumber": 46,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "TargetFileRuleHandler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 731,
    "kind": "member",
    "name": "_rule",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#_rule",
    "access": "protected",
    "description": "The rule settings.",
    "lineNumber": 53,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "TargetFileRuleSettings"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 732,
    "kind": "member",
    "name": "_hasTarget",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#_hasTarget",
    "access": "protected",
    "description": "Whether or not a target has been added to the rule.",
    "lineNumber": 75,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 733,
    "kind": "method",
    "name": "getRule",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#getRule",
    "access": "public",
    "description": "Get the rule settings.",
    "lineNumber": 81,
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRuleSettings"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 734,
    "kind": "method",
    "name": "addTarget",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#addTarget",
    "access": "public",
    "description": "Add a target to the rule. This means the instance will process it and eventually add its\npaths to the settings.\nThis method uses the reducer event `target-file-rule`, and if a target was already added,\n`target-file-rule-update` too. Both events receive the next state of the settings as well\nas the current, and expect the final state on return.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": null
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "_mergeRule",
    "memberof": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetFileRule.js~TargetFileRule#_mergeRule",
    "access": "protected",
    "description": "Merge two sets of rule settings. This is also used recursively to merge nested settings.",
    "lineNumber": 121,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "TargetFileRuleSettings",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "The original rule or a set of properties of\n                                               the original rule."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRuleSettings",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "changes",
        "description": "The rule that will be merged into the origina,\n                                               or a set of properties from it."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRuleSettings",
        "Object"
      ],
      "spread": false,
      "description": "The merged rule, or a set of merge properties."
    }
  },
  {
    "__docId__": 738,
    "kind": "file",
    "name": "src/services/targets/targetsFileRules/targetsFileRules.js",
    "content": "const { provider } = require('jimple');\nconst TargetFileRule = require('./targetFileRule');\n/**\n * This service is intended as a helper for plugins or build engines that need to find targets\n * files by creating a set of _\"rules\"_ for the basic type of files projext manages: JS, SCSS,\n * CSS, fonts, images and favicons.\n */\nclass TargetsFileRules {\n  /**\n   * @param {Events}    events    To send to {@link TargetFileRule} and to inform when rules are\n   *                              created.\n   * @param {PathUtils} pathUtils To build the path to the configuration directory, in order to\n   *                              add it on the JS rule.\n   * @param {Targets}   targets   To get a target information when a set of rules is generated.\n   */\n  constructor(events, pathUtils, targets) {\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * A local reference for the `targets` service.\n     * @type {Targets}\n     */\n    this.targets = targets;\n  }\n  /**\n   * Get a set of file rules for an specific target.\n   * @param {string|Target} target The target information or its name.\n   * @return {TargetFilesRules}\n   */\n  getRulesForTarget(target) {\n    // If the received `target` is a `string`, get its info.\n    const targetInfo = typeof target === 'string' ?\n      this.targets.getTarget(target) :\n      target;\n\n    // Define the rules.\n    const rules = {\n      js: this._getJSRule(targetInfo),\n      scss: this._getSCSSRule(targetInfo),\n      css: this._getCSSRule(targetInfo),\n      fonts: {\n        common: this._getCommonFontsRule(targetInfo),\n        svg: this._getSVGFontsRule(targetInfo),\n      },\n      images: this._getImagesRule(targetInfo),\n      favicon: this._getFaviconRule(targetInfo),\n    };\n\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-file-rules', rules, targetInfo);\n    // Return teh rules.\n    return rules;\n  }\n  /**\n   * Creates the rule object for a target JS files.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getJSRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'js', (ruleTarget, hasTarget) => {\n      const pathsInclude = [];\n      const filesInclude = [];\n      const filesGlobInclude = [];\n      /**\n       * If this is the first time a target is being added to the rule, add the configuration\n       * directory path to the lists of allowed paths.\n       */\n      if (!hasTarget) {\n        // Get the configuration directory path.\n        const config = this.pathUtils.join('config');\n        // Push it to the list of paths.\n        pathsInclude.push(new RegExp(config, 'i'));\n        // Push it to the lists of files.\n        filesInclude.push(new RegExp(`${config}/.*?\\\\.[jt]sx?$`, 'i'));\n        filesGlobInclude.push(`${config}/**/*.{js,jsx,ts,tsx}`);\n      }\n      // Define the allowed paths.\n      pathsInclude.push(...[\n        // The target path.\n        new RegExp(ruleTarget.paths.source, 'i'),\n        // The paths for modules that have been explicity included on the target settings.\n        ...ruleTarget.includeModules.map((modName) => (\n          new RegExp(`node_modules/${modName}`)\n        )),\n      ]);\n      // Define the allowed file paths.\n      filesInclude.push(...[\n        // Target files.\n        new RegExp(`${ruleTarget.paths.source}/.*?\\\\.[jt]sx?$`, 'i'),\n        // Files of modules that have been explicity included on the target settings.\n        ...ruleTarget.includeModules.map((modName) => (\n          new RegExp(`node_modules/${modName}/.*?\\\\.[jt]sx?$`, 'i')\n        )),\n      ]);\n      // Define the allowed file paths, on glob format.\n      filesGlobInclude.push(...[\n        // Target files.\n        `${ruleTarget.paths.source}/**/*.{js,jsx,ts,tsx}`,\n        // Files of modules that have been explicity included on the target settings.\n        ...ruleTarget.includeModules.map((modName) => (\n          `node_modules/${modName}/**/*.{js,jsx,ts,tsx}`\n        )),\n      ]);\n      // Return the rule settings.\n      return {\n        extension: /\\.[jt]sx?$/i,\n        glob: '**/*.{js,jsx,ts,tsx}',\n        paths: {\n          include: pathsInclude,\n          exclude: [],\n        },\n        files: {\n          include: filesInclude,\n          exclude: [],\n          glob: {\n            include: filesGlobInclude,\n            exclude: [],\n          },\n        },\n      };\n    });\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-js-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target SCSS files.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getSCSSRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'scss', (ruleTarget) => ({\n      extension: /\\.scss$/i,\n      glob: '**/*.scss',\n      paths: {\n        // Define the allowed paths.\n        include: [\n          // The target path.\n          new RegExp(ruleTarget.paths.source, 'i'),\n          // The paths for modules that have been explicity included on the target settings.\n          ...ruleTarget.includeModules.map((modName) => (\n            new RegExp(`node_modules/${modName}`)\n          )),\n        ],\n        exclude: [],\n      },\n      files: {\n        // Define the allowed file paths.\n        include: [\n          // Target files.\n          new RegExp(`${ruleTarget.paths.source}/.*?\\\\.scss$`, 'i'),\n          // Files of modules that have been explicity included on the target settings.\n          ...ruleTarget.includeModules.map((modName) => (\n            new RegExp(`node_modules/${modName}/.*?\\\\.scss$`, 'i')\n          )),\n        ],\n        exclude: [],\n        glob: {\n          // Define the allowed file paths, on glob format.\n          include: [\n            // Target files.\n            `${ruleTarget.paths.source}/**/*.scss`,\n            // Files of modules that have been explicity included on the target settings.\n            ...ruleTarget.includeModules.map((modName) => (\n              `node_modules/${modName}/**/*.scss`\n            )),\n          ],\n          exclude: [],\n        },\n      },\n    }));\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-scss-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target CSS files.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getCSSRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'css', (ruleTarget) => ({\n      extension: /\\.css$/i,\n      glob: '**/*.css',\n      paths: {\n        // Define the allowed paths.\n        include: [\n          // The target path.\n          new RegExp(ruleTarget.paths.source, 'i'),\n          // Any path inside the `node_modules` directory.\n          /node_modules\\//i,\n        ],\n        exclude: [],\n      },\n      files: {\n        // Define the allowed file paths.\n        include: [\n          // Target files.\n          new RegExp(`${ruleTarget.paths.source}/.*?\\\\.css$`, 'i'),\n          // Any file inside the `node_modules` directory.\n          /node_modules\\/.*?\\.css$/i,\n        ],\n        exclude: [],\n        glob: {\n          // Define the allowed file paths, on glob format.\n          include: [\n            // Target files.\n            `${ruleTarget.paths.source}/**/*.css`,\n            // Any file inside the `node_modules` directory.\n            'node_modules/**/*.css',\n          ],\n          exclude: [],\n        },\n      },\n    }));\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-css-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target common font files. By _\"common\"_, it means that it\n   * doesn't include `.svg` files; the reason is that have some very specific expressions so they\n   * can be differentiated from images.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getCommonFontsRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'fonts.common', (ruleTarget) => ({\n      extension: /\\.(?:woff2?|ttf|eot)$/i,\n      glob: '**/*.{woff,woff2,ttf,eot}',\n      paths: {\n        // Define the allowed paths.\n        include: [\n          // The target path.\n          new RegExp(ruleTarget.paths.source, 'i'),\n          // Any path inside the `node_modules` directory.\n          /node_modules\\//i,\n        ],\n        exclude: [],\n      },\n      files: {\n        // Define the allowed file paths.\n        include: [\n          // Target files.\n          new RegExp(`${ruleTarget.paths.source}/.*?\\\\.(?:woff2?|ttf|eot)`, 'i'),\n          // Any file inside the `node_modules` directory.\n          /node_modules\\/.*?\\.(?:woff2?|ttf|eot)$/i,\n        ],\n        exclude: [],\n        glob: {\n          // Define the allowed file paths, on glob format.\n          include: [\n            // Target files.\n            `${ruleTarget.paths.source}/**/*.{woff,woff2,ttf,eot}`,\n            // Any file inside the `node_modules` directory.\n            'node_modules/**/*.{woff,woff2,ttf,eot}',\n          ],\n          exclude: [],\n        },\n      },\n    }));\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-common-font-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target SVG font files. This is separated from the _\"common\"_\n   * fonts because projext only recognizes `.svg` files as fonts when they are inside a `fonts`\n   * directory.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getSVGFontsRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'fonts.svg', (ruleTarget) => ({\n      extension: /\\.svg$/i,\n      glob: '**/*.svg',\n      paths: {\n        // Define the allowed paths.\n        include: [\n          // Any path inside the target directory that contains a `fonts` component.\n          new RegExp(`${ruleTarget.paths.source}/(?:.*?/)?fonts(?:/.*?)?$`, 'i'),\n          // Any path on the `node_modules` that contains a `fonts` component.\n          /node_modules\\/(?:.*?\\/)?fonts(?:\\/.*?)?$/i,\n        ],\n        exclude: [],\n      },\n      files: {\n        // Define the allowed file paths.\n        include: [\n          // Any `.svg` inside a `fonts` directory, on the target directory or the `node_modules`.\n          new RegExp(`${ruleTarget.paths.source}/(?:.*?/)?fonts/.*?\\\\.svg$`, 'i'),\n          /node_modules\\/(?:.*?\\/)?fonts\\/.*?\\.svg$/i,\n        ],\n        exclude: [],\n        glob: {\n          // Define the allowed file paths, on glob format.\n          include: [\n            /**\n             * Any `.svg` inside a `fonts` directory, on the target directory or the\n             * `node_modules`.\n             */\n            `${ruleTarget.paths.source}/**/fonts/**/*.svg`,\n            'node_modules/**/fonts/**/*.svg',\n          ],\n          exclude: [],\n        },\n      },\n    }));\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-svg-font-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target image files.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getImagesRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'images', (ruleTarget) => {\n      /**\n       * Define the excluded paths.\n       * The issue here is that the rule should pick `.svg` files as images, but not if they\n       * are inside a `fonts` directory, that's why the path expressions also include extensions.\n       * The same goes for favicons, it should pick `png` and `ico` files, but not if they are\n       * called `favicon`.\n       */\n      const exclude = [\n        // Any path for an `.svg` file inside a `fonts` directory.\n        new RegExp(`${ruleTarget.paths.source}/(?:.*?/)?fonts/.*?\\\\.svg$`, 'i'),\n        // Any path for a `favicon` file with extension `png` or `ico`.\n        new RegExp(`${ruleTarget.paths.source}/.*?favicon\\\\.(png|ico)$`, 'i'),\n        // Any path for an `.svg` file with a `fonts` component inside the `node_modules`.\n        /node_modules\\/(?:.*?\\/)?fonts\\/.*?\\.svg$/i,\n      ];\n\n      return {\n        extension: /\\.(jpe?g|png|gif|svg)$/i,\n        glob: '**/*.{jpg,jpeg,png,gif,svg}',\n        paths: {\n          // Define the allowed paths.\n          include: [\n            // The target path.\n            new RegExp(ruleTarget.paths.source, 'i'),\n            // Any path inside the `node_modules` directory.\n            /node_modules\\//i,\n          ],\n          // Exclude anything related to fonts.\n          exclude,\n        },\n        files: {\n          // Define the allowed file paths.\n          include: [\n            // Target files.\n            new RegExp(`${ruleTarget.paths.source}/.*?\\\\.(?:jpe?g|png|gif|svg)`, 'i'),\n            // Any file inside the `node_modules` directory.\n            /node_modules\\/.*?\\.(?:jpe?g|png|gif|svg)$/i,\n          ],\n          // Exclude anything related to fonts.\n          exclude,\n          glob: {\n            // Define the allowed file paths, on glob format.\n            include: [\n              // Target files.\n              `${ruleTarget.paths.source}/**/*.{jpg,jpeg,png,gif,svg}`,\n              // Any file inside the `node_modules` directory.\n              'node_modules/**/*.{jpg,jpeg,png,gif,svg}',\n            ],\n            // Exclude anything related to fonts.\n            exclude: [\n              // Any path for an `.svg` file inside a `fonts` directory.\n              `${ruleTarget.paths.source}/**/fonts/**/*.svg`,\n              // Any path for a `favicon` file with extension `png` or `ico`.\n              `${ruleTarget.paths.source}/**/favicon.{png,ico}`,\n              // Any path for an `.svg` file with a `fonts` component inside the `node_modules`.\n              'node_modules/**/fonts/**/*.svg',\n            ],\n          },\n        },\n      };\n    });\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-image-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n  /**\n   * Creates the rule object for a target favicon files.\n   * @param {Target} target The target information.\n   * @return {TargetFileRule}\n   * @access protected\n   * @ignore\n   */\n  _getFaviconRule(target) {\n    const rule = new TargetFileRule(this.events, this.targets, 'favicon', (ruleTarget) => ({\n      extension: /\\.(png|ico)$/i,\n      glob: '**/*.{png,ico}',\n      paths: {\n        // Define the allowed paths.\n        include: [\n          // The target path.\n          new RegExp(ruleTarget.paths.source, 'i'),\n        ],\n        exclude: [],\n      },\n      files: {\n        // Define the allowed file paths.\n        include: [\n          // Any file called `favicon` with the extension `png` or `ico`\n          new RegExp(`${ruleTarget.paths.source}/.*?favicon\\\\.(png|ico)$`, 'i'),\n        ],\n        exclude: [],\n        glob: {\n          // Define the allowed file paths, on glob format.\n          include: [\n            // Any file called `favicon` with the extension `png` or `ico`\n            `${ruleTarget.paths.source}/**/favicon.{png,ico}`,\n          ],\n          exclude: [],\n        },\n      },\n    }));\n    // Add the target to the rule.\n    rule.addTarget(target);\n    // Emit the event informing the rule has been created.\n    this.events.emit('target-favicon-files-rule', rule, target);\n    // Return the rule.\n    return rule;\n  }\n}\n/**\n * The service provider that once registered on the app container will set an instance of\n * `TargetsFileRules` as the `targetsFileRules` service.\n * @example\n * // Register it on the container\n * container.register(targetsFileRules);\n * // Getting access to the service instance\n * const targetsFileRules = container.get('targetsFileRules');\n * @type {Provider}\n */\nconst targetsFileRules = provider((app) => {\n  app.set('targetsFileRules', () => new TargetsFileRules(\n    app.get('events'),\n    app.get('pathUtils'),\n    app.get('targets')\n  ));\n});\n\nmodule.exports = {\n  TargetsFileRules,\n  targetsFileRules,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targetsFileRules/targetsFileRules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 739,
    "kind": "class",
    "name": "TargetsFileRules",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js",
    "static": true,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsFileRules/targetsFileRules.js",
    "importStyle": "{TargetsFileRules}",
    "description": "This service is intended as a helper for plugins or build engines that need to find targets\nfiles by creating a set of _\"rules\"_ for the basic type of files projext manages: JS, SCSS,\nCSS, fonts, images and favicons.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 740,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To send to {@link TargetFileRule} and to inform when rules are\n                             created."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build the path to the configuration directory, in order to\n                             add it on the JS rule."
      },
      {
        "nullable": null,
        "types": [
          "Targets"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "To get a target information when a set of rules is generated."
      }
    ]
  },
  {
    "__docId__": 741,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 742,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 743,
    "kind": "member",
    "name": "targets",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#targets",
    "access": "public",
    "description": "A local reference for the `targets` service.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Targets"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 744,
    "kind": "method",
    "name": "getRulesForTarget",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#getRulesForTarget",
    "access": "public",
    "description": "Get a set of file rules for an specific target.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information or its name."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFilesRules"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 745,
    "kind": "method",
    "name": "_getJSRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getJSRule",
    "access": "protected",
    "description": "Creates the rule object for a target JS files.",
    "lineNumber": 69,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 746,
    "kind": "method",
    "name": "_getSCSSRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getSCSSRule",
    "access": "protected",
    "description": "Creates the rule object for a target SCSS files.",
    "lineNumber": 146,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 747,
    "kind": "method",
    "name": "_getCSSRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getCSSRule",
    "access": "protected",
    "description": "Creates the rule object for a target CSS files.",
    "lineNumber": 201,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 748,
    "kind": "method",
    "name": "_getCommonFontsRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getCommonFontsRule",
    "access": "protected",
    "description": "Creates the rule object for a target common font files. By _\"common\"_, it means that it\ndoesn't include `.svg` files; the reason is that have some very specific expressions so they\ncan be differentiated from images.",
    "lineNumber": 252,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 749,
    "kind": "method",
    "name": "_getSVGFontsRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getSVGFontsRule",
    "access": "protected",
    "description": "Creates the rule object for a target SVG font files. This is separated from the _\"common\"_\nfonts because projext only recognizes `.svg` files as fonts when they are inside a `fonts`\ndirectory.",
    "lineNumber": 303,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 750,
    "kind": "method",
    "name": "_getImagesRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getImagesRule",
    "access": "protected",
    "description": "Creates the rule object for a target image files.",
    "lineNumber": 353,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 751,
    "kind": "method",
    "name": "_getFaviconRule",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~TargetsFileRules#_getFaviconRule",
    "access": "protected",
    "description": "Creates the rule object for a target favicon files.",
    "lineNumber": 430,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetFileRule"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 752,
    "kind": "variable",
    "name": "targetsFileRules",
    "memberof": "src/services/targets/targetsFileRules/targetsFileRules.js",
    "static": true,
    "longname": "src/services/targets/targetsFileRules/targetsFileRules.js~targetsFileRules",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsFileRules/targetsFileRules.js",
    "importStyle": "{targetsFileRules}",
    "description": "The service provider that once registered on the app container will set an instance of\n`TargetsFileRules` as the `targetsFileRules` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targetsFileRules);\n// Getting access to the service instance\nconst targetsFileRules = container.get('targetsFileRules');"
    ],
    "lineNumber": 477,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 753,
    "kind": "file",
    "name": "src/services/targets/targetsFinder.js",
    "content": "const fs = require('fs-extra');\nconst path = require('path');\nconst ObjectUtils = require('wootils/shared/objectUtils');\nconst { provider } = require('jimple');\n/**\n * This is used to find targets information on an specific directory. It not only reads the\n * directory tree but also tries to identify the targets types by analyzing the contents of\n * indentified targets entry files.\n */\nclass TargetsFinder {\n  /**\n   * Class constructor.\n   * @param {Object}    packageInfo If there's only one target and is not on a sub folder, the way\n   *                                the service names it is by using the project name that's on the\n   *                                `package.json`.\n   * @param {PathUtils} pathUtils   To build the path to the directory that will be read.\n   * @ignore\n   */\n  constructor(packageInfo, pathUtils) {\n    /**\n     * The contents of the project `package.json`. If there's only one target and is not on a sub\n     * folder, the way the service names it is by using the project name.\n     * @type {Object}\n     */\n    this.packageInfo = packageInfo;\n    /**\n     * A local reference for the `pathUtils` service.\n     * @type {PathUtils}\n     */\n    this.pathUtils = pathUtils;\n    /**\n     * A list of items that should be ignored when reading a directory.\n     * @type {Array}\n     * @ignore\n     * @access protected\n     */\n    this._ignoredItems = ['.', '..', 'thumbs.db', '.ds_store'];\n    /**\n     * A dictionary of known file types and regular expressions that match their extensions.\n     * @type {Object}\n     * @ignore\n     * @access protected\n     */\n    this._extensions = {\n      js: /\\.[jt]sx?$/i,\n      typeScript: /\\.tsx?$/i,\n      typeScriptReact: /\\.tsx$/i,\n      asset: /\\.(png|jpe?g|gif|s?css|html|svg|woff2?|ttf|eot)$/i,\n    };\n    /**\n     * A dictionary of _\"import methods\"_ a file can use. They're separated in two categories:\n     * 'native' and 'next', so the service can identify if a Node target requires bundling or not.\n     * @type {Object}\n     * @ignore\n     * @access protected\n     */\n    this._imports = {\n      native: [\n        /\\s*require\\s*\\(\\s*['|\"](.*?)['|\"]\\s*\\)/ig,\n      ],\n      next: [\n        /\\s*from\\s*['|\"](.*?)['|\"]/ig,\n        /\\s*import\\s*\\(\\s*['|\"](.*?)['|\"]\\s*\\)/ig,\n      ],\n    };\n    /**\n     * A dictionary of _\"export methods\"_ a file can use. They're separated in two categories:\n     * 'native' and 'next', so the service can identify if a Node target requires bundling or not.\n     * If a target entry file implements any kind of _\"export method\"_, it will be marked as a\n     * library target.\n     * @type {Object}\n     * @ignore\n     * @access protected\n     */\n    this._exports = {\n      native: [/(?:^|\\s)(module\\.exports\\s*=)/ig],\n      next: [/(?:^|\\s)(export(?: default)?\\s*(?:.*?))/ig],\n    };\n    /**\n     * A dictionary of known browser frameworks and regular expressions that match their module\n     * name.\n     * @type {Object}\n     * @ignore\n     * @access protected\n     */\n    this._browserFrameworks = {\n      angular: /@angular(?:\\/(?:\\w+))?$/i,\n      angularjs: /angular/i,\n      react: /react(?:(?!(?:-dom\\/server)))/i,\n      aurelia: /aurelia/i,\n    };\n    /**\n     * A list of known browser frameworks that need to export something on the entry point in order\n     * to work. This is list is used to prevent the service from thinking an app is a library.\n     * @type {Array}\n     * @ignore\n     * @access protected\n     */\n    this._browserFrameworksWithExports = ['aurelia'];\n    /**\n     * A dictionary of known frameworks that can be used on Node, and regular expressions that\n     * match their module name.\n     * @type {Object}\n     */\n    this._nodeFrameworks = {\n      react: /react-dom\\/server/i,\n    };\n    /**\n     * A list of regular expressions that would only match code present on a browser target.\n     * @type {Array}\n     * @ignore\n     * @access protected\n     */\n    this._browserExpressions = [\n      /(?:^|\\s|=)doc(?:ument?)\\s*\\.\\s*(?:getElementBy(?:Id|ClassName)|querySelector(?:All)?)\\s*\\(/ig,\n      /(?:^|\\s|=)(?:window|global)\\s*\\.(?:document)?/i,\n      /['|\"]whatwg-fetch['|\"]/i,\n    ];\n    /**\n     * @ignore\n     */\n    this.find = this.find.bind(this);\n  }\n  /**\n   * Given a directory path relative to the project root, this method will try to identify\n   * targets and their properties.\n   * @param {string} directory A directory path relative to the project root.\n   * @return {Array} Each item will be a {@link TargetsFinderTarget}.\n   */\n  find(directory) {\n    // Build the full path.\n    const dirpath = this.pathUtils.join(directory);\n    // Define the list that will be returned.\n    const targets = [];\n    // If the directory exists...\n    if (fs.pathExistsSync(dirpath)) {\n      // ...get all the items inside it.\n      const items = this._getItems(dirpath);\n      /**\n       * Check if there's a JS file inside, which means that the directory is a target itself and\n       * that it doesn't contain _\"sub targets\"_.\n       */\n      const jsFile = items.find((item) => item.name.match(this._extensions.js));\n      // If there's a JS file...\n      if (jsFile) {\n        // ...try to parse a target on that directory.\n        const target = this._parseTarget(this.packageInfo.name, dirpath, false);\n        // If there was a target in there, add it to the list.\n        if (target) {\n          targets.push(target);\n        }\n      } else {\n        // ...otherwise, loop all the items on the directory.\n        items.forEach((item) => {\n          // If the item is a directory...\n          if (item.stats.isDirectory()) {\n            // ...try to parse a target on that directory.\n            const target = this._parseTarget(item.name, item.path);\n            // If there was a target in there, add it to the list.\n            if (target) {\n              targets.push(target);\n            }\n          }\n        });\n      }\n    }\n    // Return the list of found targets.\n    return targets;\n  }\n  /**\n   * Get all the items on a given path.\n   * @param {string} directoryPath The path to the directory to read.\n   * @return {Array} A list of {@link TargetsFinderItem}.\n   * @ignore\n   * @access protected\n   */\n  _getItems(directoryPath) {\n    // Read the directory.\n    return fs.readdirSync(directoryPath)\n    // Filter the ignored items.\n    .filter((item) => !this._ignoredItems.includes(item.toLowerCase()))\n    // For each found item, build its full path, get its stats and return it on an object.\n    .map((item) => {\n      const filepath = path.join(directoryPath, item);\n      const stats = fs.lstatSync(filepath);\n      return {\n        name: item,\n        path: filepath,\n        stats,\n      };\n    });\n  }\n  /**\n   * This method tries to get a target information from a given directory.\n   * @param {string}  name             The name of the target.\n   * @param {string}  directory        The absolute path to the directory to parse.\n   * @param {boolean} [hasFolder=true] The value of the target `hasFolder` and `createFolder`\n   *                                   properties.\n   * @return {?TargetsFinderTarget} If the target can't be identified because there's no JS files\n   *                                or a valid entry file can't be found, the method will return\n   *                                `null`.\n   * @ignore\n   * @access protected\n   */\n  _parseTarget(name, directory, hasFolder = true) {\n    // Define the base structure of the target data this method can handle.\n    let target = {\n      name,\n      hasFolder,\n      createFolder: hasFolder,\n      entry: {\n        default: 'index.js',\n        development: null,\n        production: null,\n      },\n    };\n    /**\n     * Define a dictionary that will contain all the found JS files on the directory. The keys\n     * will be the name of the files without extension and the values will be the real name of the\n     * file.\n     * This way it makes it easier to test using the key as _\"falsy value\"_ without having to call\n     * `includes`.\n     */\n    const jsFiles = {};\n    // Get all the items on the directory.\n    this._getItems(directory)\n    // Filter the JS files.\n    .filter((item) => item.name.match(this._extensions.js))\n    // Add them to the dictionary.\n    .forEach((item) => {\n      const itemName = item.name.replace(this._extensions.js, '').toLowerCase();\n      jsFiles[itemName] = item.name;\n    });\n\n    // Get all extension-less names on a list (because we need the `length`).\n    const jsFilesNames = Object.keys(jsFiles);\n    // Only process the target if there are JS files on the directory.\n    if (jsFilesNames.length) {\n      // If there's only one JS file...\n      if (jsFilesNames.length === 1) {\n        // ...set it as the default entry file.\n        const [defaultJSFile] = jsFilesNames;\n        target.entry.default = jsFiles[defaultJSFile];\n      } else {\n        // If there's a development entry file, set it.\n        if (jsFiles['index.development']) {\n          target.entry.development = jsFiles['index.development'];\n        }\n        // If there's a production entry file, set it.\n        if (jsFiles['index.production']) {\n          target.entry.production = jsFiles['index.production'];\n        }\n        // If there's a index, set it as the default.\n        if (jsFiles.index) {\n          target.entry.default = jsFiles.index;\n        }\n      }\n      // Define the entry to be analyzed in order to identify the target type.\n      const entry = target.entry.production || target.entry.default;\n      // Build the absolute path to the entry file.\n      const entryPath = path.join(directory, entry);\n      // If the file exists...\n      if (fs.pathExistsSync(entryPath)) {\n        // Merge the target structure created by this method with the results of the analysis.\n        target = ObjectUtils.merge(target, this._parseTargetEntry(entryPath));\n      }\n    }\n    /**\n     * If there's a type, which means that there was at least one JS file and a valid entry file,\n     * return the target, otherwise return `null`.\n     */\n    return target.type ? target : null;\n  }\n  /**\n   * Parse a target entry file and try to identify the target type, if it's a library and if it\n   * requires bundling.\n   * @param {string} entryPath The absolute path to the target entry file.\n   * @return {Object}\n   * @property {string}   type      The target type: `node` or `browser`.\n   * @property {boolean}  library   Whether the target is a library or not.\n   * @property {?string}  framework If the target type is `browser` and a framework was identified,\n   *                                this property will have the name of the framework.\n   * @property {?boolean} transpile If the target type is `node`, this flag will indicate if the\n   *                                method identified syntax not yet supported by Node.\n   * @ignore\n   * @access protected\n   */\n  _parseTargetEntry(entryPath) {\n    // Get the contents of the file.\n    const contents = fs.readFileSync(entryPath, 'utf-8');\n    // Try to find information from the `@projext` comment.\n    const comments = this._findSettingsComment(contents);\n    // Get the information of all the import statements.\n    const importInfo = this._getFileImports(contents);\n    // Get the information of all the export statements\n    const exportInfo = this._getFileExports(contents);\n    // Try to find a browser framework\n    const framework = this._findBrowserFramework(comments, importInfo);\n    // Detect whether the target is a library or not.\n    const library = this._isLibrary(comments, exportInfo, framework);\n    // Try to find a framework that can also be used on Node.\n    const nodeFramework = this._findNodeFramework(importInfo);\n    /**\n     * Try to determine if the target type is `browser` by either checking if a browser framework\n     * was found or by trying to find a known browser code.\n     */\n    const isBrowser = !nodeFramework && this._isABrowserTarget(comments, contents, framework);\n    // Define the basic properties of the return object.\n    let info = {\n      type: isBrowser ? 'browser' : 'node',\n      library,\n    };\n    // If a browser framework was found...\n    if (framework) {\n      // ...set it as the framework property.\n      info.framework = framework;\n    } else if (!isBrowser) {\n      // .. so the target is for Node; check if it needs bundling or transpilation.\n      if (this._needsBundling(importInfo)) {\n        info.bundle = true;\n      } else if (this._needsTranspilation(importInfo, exportInfo)) {\n        /**\n         * If the target is using `import` or `export` but is not importing assets, then turn\n         * the `transpile` flag to true.\n         */\n        info.transpile = true;\n      }\n    }\n    /**\n     * If the target is a library, normalize the output so it won't add sub directories nor hashes.\n     * A library path is usually set on the `package.json` as the `main` setting, so the path\n     * shouldn't be dynamic.\n     */\n    if (info.library) {\n      info.output = {\n        default: {\n          js: '[target-name].js',\n        },\n        development: {\n          js: '[target-name].js',\n        },\n      };\n    }\n    // If the target uses TypeScript or Flow, add the necessary settings for it.\n    if (entryPath.match(this._extensions.typeScript)) {\n      info = Object.assign({}, info, this._getTypescriptSettings(\n        !isBrowser,\n        info.bundle,\n        entryPath,\n        framework\n      ));\n    } else if (comments.flow) {\n      info = Object.assign({}, info, this._getFlowSettings(!isBrowser, info.bundle));\n    }\n    // Return the result of the analysis.\n    return info;\n  }\n  /**\n   * Tries to find a browser framework from an entry file comments or by its import statements.\n   * @param {Object}                          comments          The dictionary of comments\n   *                                                            extracted from the file.\n   * @param {TargetsFinderExtractInformation} importInformation The information of the file import\n   *                                                            statements.\n   * @return {?String}\n   * @access protected\n   * @ignore\n   */\n  _findBrowserFramework(comments, importInformation) {\n    // Loop all the known browser frameworks.\n    const result = comments.framework || Object.keys(this._browserFrameworks)\n    // Try to find an import statement that matches the browser framework regular expression.\n    .find((name) => {\n      const regex = this._browserFrameworks[name];\n      return !!importInformation.items.find((file) => file.match(regex));\n    });\n\n    return result || null;\n  }\n  /**\n   * Tries to find a Node framework from an entry file import statements.\n   * @param {TargetsFinderExtractInformation} importInformation The information of the file import\n   *                                                            statements.\n   * @return {?String}\n   * @access protected\n   * @ignore\n   */\n  _findNodeFramework(importInformation) {\n    const result = Object.keys(this._nodeFrameworks)\n    .find((name) => {\n      const regex = this._nodeFrameworks[name];\n      return !!importInformation.items.find((file) => file.match(regex));\n    });\n\n    return result || null;\n  }\n  /**\n   * Checks if a target should be a library or not based on its entry file comments, export\n   * statements information and/or the framework it uses.\n   * @param {Object}                          comments          The dictionary of comments\n   *                                                            extracted from the file.\n   * @param {TargetsFinderExtractInformation} exportInformation The information of the file export\n   *                                                            statements.\n   * @param {?String}                         framework         The name of a framework the target\n   *                                                            uses.\n   * @return {Boolean}\n   * @access protected\n   * @ignore\n   */\n  _isLibrary(comments, exportInformation, framework) {\n    // If the comment says it's a library, then it's a library.\n    return comments.library || (\n      /**\n       * If there's no comment, check if the framework doesn't require exports (like Aurelia),\n       * and that there are actual export statements.\n       */\n      (framework === null || !this._browserFrameworksWithExports.includes(framework)) &&\n      exportInformation.items.length > 0\n    );\n  }\n  /**\n   * Checks if a target type is `browser` based on its entry file comments, contents and/or\n   * the framework it uses.\n   *\n   * @param {Object}  comments  The dictionary of comments extracted from the file.\n   * @param {String}  contents  The contents of the file.\n   * @param {?String} framework The name of a framework the target uses.\n   * @return {Boolean}\n   * @access protected\n   * @ignore\n   */\n  _isABrowserTarget(comments, contents, framework) {\n    // If the comment says it's for browser, then it's for browser.\n    return comments.type === 'browser' || (\n      /**\n       * If there's no comment, check if the target doesn't use a known browser framework or if\n       * its content have code that can be recognized as browser-only code.\n       */\n      framework !== null ||\n      this._browserExpressions.find((expression) => contents.match(expression))\n    );\n  }\n  /**\n   * Checks if a Node target needs bundling by trying to find an import statement for an asset\n   * (like an image file).\n   * @param {TargetsFinderExtractInformation} importInformation The information of the file import\n   *                                                            statements.\n   * @return {Boolean}\n   * @access protected\n   * @ignore\n   */\n  _needsBundling(importInformation) {\n    return importInformation.items.find((file) => file.match(this._extensions.asset));\n  }\n  /**\n   * Checks if a Node target needs transpilation by trying to find import or export statements\n   * that use ESModules.\n   * @param {TargetsFinderExtractInformation} importInformation The information of the file import\n   *                                                            statements.\n   * @param {TargetsFinderExtractInformation} exportInformation The information of the file export\n   *                                                            statements.\n   * @return {Boolean}\n   * @access protected\n   * @ignore\n   */\n  _needsTranspilation(importInformation, exportInformation) {\n    return importInformation.from.includes('next') || exportInformation.from.includes('next');\n  }\n  /**\n   * Gets the necessary settings for a target to use TypeScript.\n   * @param {Boolean} isANodeTarget Whether or not the target is for Node.\n   * @param {Boolean} needsBundling Whether or not the target needs bundling.\n   * @param {String}  entryPath     The path of the target entry file.\n   * @param {?String} framework     The name of a framework the target uses.\n   * @return {Object}\n   * @property {Boolean} [typeScript=true]\n   * The flag that indicates the target uses TypeScript.\n   * @property {ProjectConfigurationTargetTemplateSourceMapSettings} [sourceMap]\n   * The settings for source maps all set to `true` as they are needed for the types.\n   * @property {?String} [framework]\n   * If the method detects a `.tsx` extension, it will add this property with `react` as value.\n   * @property {?Boolean} [transpile=true]\n   * If the target is for Node and doesn't need bundling, then it needs at least transpilation in\n   * order to use TypeScript.\n   * @access protected\n   * @ignore\n   */\n  _getTypescriptSettings(isANodeTarget, needsBundling, entryPath, framework) {\n    const settings = {\n      typeScript: true,\n      sourceMap: {\n        development: true,\n        production: true,\n      },\n    };\n\n    if (isANodeTarget && !needsBundling) {\n      settings.transpile = true;\n    }\n\n    if (framework === null && entryPath.match(this._extensions.typeScriptReact)) {\n      settings.framework = 'react';\n    }\n\n    return settings;\n  }\n  /**\n   * Gets the necessary settings for a target to use Flow.\n   * @param {Boolean} isANodeTarget Whether or not the target is for Node.\n   * @param {Boolean} needsBundling Whether or not the target needs bundling.\n   * @return {Object}\n   * @property {Boolean} [flow=true]\n   * The flag that indicates the target uses TypeScript.\n   * @property {?Boolean} [transpile=true]\n   * If the target is for Node and doesn't need bundling, then it needs at least transpilation in\n   * order to use TypeScript.\n   * @access protected\n   * @ignore\n   */\n  _getFlowSettings(isANodeTarget, needsBundling) {\n    const settings = {\n      flow: true,\n    };\n\n    if (isANodeTarget && !needsBundling) {\n      settings.transpile = true;\n    }\n\n    return settings;\n  }\n  /**\n   * This method tries to find and parse settings on a \"@projext comment\" inside a target entry\n   * file.\n   * @param {String} contents The contents of the target entry file.\n   * @return {Object}\n   * @access protected\n   * @ignore\n   */\n  _findSettingsComment(contents) {\n    let result;\n    const match = /\\/\\*\\*\\n\\s*\\*\\s*@projext\\n([\\s\\S]*?)\\n\\s*\\*\\//.exec(contents);\n    if (match) {\n      const [, lines] = match;\n      result = lines\n      .split('\\n')\n      .map((line) => {\n        let newLine;\n        const lineMatch = /\\s*\\*\\s*(\\w+)\\s*:\\s*(.*?)$/.exec(line);\n        if (lineMatch) {\n          const [, name, value] = lineMatch;\n          newLine = { name, value };\n        } else {\n          newLine = null;\n        }\n\n        return newLine;\n      })\n      .filter((line) => line !== null)\n      .reduce(\n        (acc, line) => {\n          let useValue;\n          if (['true', 'false'].includes(line.value)) {\n            useValue = line.value === 'true';\n          } else {\n            useValue = line.value;\n          }\n\n          return Object.assign({}, acc, {\n            [line.name]: useValue,\n          });\n        },\n        {}\n      );\n    } else {\n      result = {};\n    }\n\n    return result;\n  }\n  /**\n   * Get the information of all the export statements from a given code.\n   * @param  {string} contents The code from where to extract the statements.\n   * @return {TargetsFinderExtractInformation}\n   * @ignore\n   * @access protected\n   */\n  _getFileExports(contents) {\n    return this._extractFromCode(contents, this._exports);\n  }\n  /**\n   * Get the information of all the import statements from a given code.\n   * @param  {string} contents The code from where to extract the statements.\n   * @return {TargetsFinderExtractInformation}\n   * @ignore\n   * @access protected\n   */\n  _getFileImports(contents) {\n    return this._extractFromCode(contents, this._imports);\n  }\n  /**\n   * Given a dictionary of regular expressions lists and a source code, this method will try to\n   * identify and match the expressions in order to return all the matched results and the keys\n   * of the lists that returned results.\n   * @example\n   * const dictionary = {\n   *   listOne: [/(goodbye)/ig, /(Batman)/ig],\n   *   listTwo: [/(hello)/ig, /(Nightwing)/ig],\n   * };\n   * const code = 'hello Batman';\n   * console.log(this._extractFromCode(code, dictionary));\n   * // This would output { from: ['listOne', 'listTwo'], items: ['hello', 'Batman'] }\n   *\n   * @param {string} contents              The source code to parse.\n   * @param {Object} expressionsDictionary A dictionary of regular expressions lists.\n   * @return {TargetsFinderExtractInformation}\n   * @throws {Error} if a regular expression doesn't have a capturing group.\n   * @ignore\n   * @access protected\n   */\n  _extractFromCode(contents, expressionsDictionary) {\n    // Setup the return object and its properties.\n    const result = {\n      from: [],\n      items: [],\n    };\n    // Loop all the dictionaries.\n    Object.keys(expressionsDictionary).forEach((dictionaryName) => {\n      // Get the list of expressions.\n      const expressions = expressionsDictionary[dictionaryName];\n      // Set a list to hold all the found results of the current directionary.\n      const items = [];\n      // Loop all the expressions.\n      expressions.forEach((regex) => {\n        // Execute the expression.\n        let match = regex.exec(contents);\n        while (match) {\n          // Get the first capturing group.\n          const [, extract] = match;\n          // Normalize the extracted text.\n          const normalized = extract.toLowerCase().trim();\n          // Add it to the list.\n          items.push(normalized);\n          // Continue the execution loop.\n          match = regex.exec(contents);\n        }\n      });\n      // If the current dictionary found results...\n      if (items.length) {\n        // Add the dictionary name to the return object.\n        result.from.push(dictionaryName);\n        // Add the found items to the return object.\n        result.items.push(...items);\n      }\n    });\n\n    return result;\n  }\n}\n/**\n * The service provider that once registered on the app container will create an instance of\n * `TargetsFinder` and set its `find` method as the `targetsFinder` service.\n * @example\n * // Register it on the container\n * container.register(targetsFinder);\n * // Getting access to the service function\n * const targetsFinder = container.get('targetsFinder');\n * @type {Provider}\n */\nconst targetsFinder = provider((app) => {\n  app.set('targetsFinder', () => new TargetsFinder(\n    app.get('packageInfo'),\n    app.get('pathUtils')\n  ).find);\n});\n\nmodule.exports = {\n  TargetsFinder,\n  targetsFinder,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targetsFinder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 754,
    "kind": "class",
    "name": "TargetsFinder",
    "memberof": "src/services/targets/targetsFinder.js",
    "static": true,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsFinder.js",
    "importStyle": "{TargetsFinder}",
    "description": "This is used to find targets information on an specific directory. It not only reads the\ndirectory tree but also tries to identify the targets types by analyzing the contents of\nindentified targets entry files.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 755,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 19,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "packageInfo",
        "description": "If there's only one target and is not on a sub folder, the way\n                               the service names it is by using the project name that's on the\n                               `package.json`."
      },
      {
        "nullable": null,
        "types": [
          "PathUtils"
        ],
        "spread": false,
        "optional": false,
        "name": "pathUtils",
        "description": "To build the path to the directory that will be read."
      }
    ]
  },
  {
    "__docId__": 756,
    "kind": "member",
    "name": "packageInfo",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#packageInfo",
    "access": "public",
    "description": "The contents of the project `package.json`. If there's only one target and is not on a sub\nfolder, the way the service names it is by using the project name.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 757,
    "kind": "member",
    "name": "pathUtils",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#pathUtils",
    "access": "public",
    "description": "A local reference for the `pathUtils` service.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "PathUtils"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 758,
    "kind": "member",
    "name": "_ignoredItems",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_ignoredItems",
    "access": "protected",
    "description": "A list of items that should be ignored when reading a directory.",
    "lineNumber": 37,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 759,
    "kind": "member",
    "name": "_extensions",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_extensions",
    "access": "protected",
    "description": "A dictionary of known file types and regular expressions that match their extensions.",
    "lineNumber": 44,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 760,
    "kind": "member",
    "name": "_imports",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_imports",
    "access": "protected",
    "description": "A dictionary of _\"import methods\"_ a file can use. They're separated in two categories:\n'native' and 'next', so the service can identify if a Node target requires bundling or not.",
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 761,
    "kind": "member",
    "name": "_exports",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_exports",
    "access": "protected",
    "description": "A dictionary of _\"export methods\"_ a file can use. They're separated in two categories:\n'native' and 'next', so the service can identify if a Node target requires bundling or not.\nIf a target entry file implements any kind of _\"export method\"_, it will be marked as a\nlibrary target.",
    "lineNumber": 75,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 762,
    "kind": "member",
    "name": "_browserFrameworks",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_browserFrameworks",
    "access": "protected",
    "description": "A dictionary of known browser frameworks and regular expressions that match their module\nname.",
    "lineNumber": 86,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 763,
    "kind": "member",
    "name": "_browserFrameworksWithExports",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_browserFrameworksWithExports",
    "access": "protected",
    "description": "A list of known browser frameworks that need to export something on the entry point in order\nto work. This is list is used to prevent the service from thinking an app is a library.",
    "lineNumber": 99,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 764,
    "kind": "member",
    "name": "_nodeFrameworks",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_nodeFrameworks",
    "access": "private",
    "description": "A dictionary of known frameworks that can be used on Node, and regular expressions that\nmatch their module name.",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 765,
    "kind": "member",
    "name": "_browserExpressions",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_browserExpressions",
    "access": "protected",
    "description": "A list of regular expressions that would only match code present on a browser target.",
    "lineNumber": 114,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 767,
    "kind": "method",
    "name": "find",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#find",
    "access": "public",
    "description": "Given a directory path relative to the project root, this method will try to identify\ntargets and their properties.",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "directory",
        "description": "A directory path relative to the project root."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Each item will be a {@link TargetsFinderTarget}."
    }
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "_getItems",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_getItems",
    "access": "protected",
    "description": "Get all the items on a given path.",
    "lineNumber": 177,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "directoryPath",
        "description": "The path to the directory to read."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of {@link TargetsFinderItem}."
    }
  },
  {
    "__docId__": 769,
    "kind": "method",
    "name": "_parseTarget",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_parseTarget",
    "access": "protected",
    "description": "This method tries to get a target information from a given directory.",
    "lineNumber": 205,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the target."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "directory",
        "description": "The absolute path to the directory to parse."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "hasFolder",
        "description": "The value of the target `hasFolder` and `createFolder`\n                                  properties."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "TargetsFinderTarget"
      ],
      "spread": false,
      "description": "If the target can't be identified because there's no JS files\n                               or a valid entry file can't be found, the method will return\n                               `null`."
    }
  },
  {
    "__docId__": 770,
    "kind": "method",
    "name": "_parseTargetEntry",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_parseTargetEntry",
    "access": "protected",
    "description": "Parse a target entry file and try to identify the target type, if it's a library and if it\nrequires bundling.",
    "lineNumber": 288,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entryPath",
        "description": "The absolute path to the target entry file."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The target type: `node` or `browser`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "library",
        "description": "Whether the target is a library or not."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "framework",
        "description": "If the target type is `browser` and a framework was identified,\n                               this property will have the name of the framework."
      },
      {
        "nullable": true,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "transpile",
        "description": "If the target type is `node`, this flag will indicate if the\n                               method identified syntax not yet supported by Node."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 771,
    "kind": "method",
    "name": "_findBrowserFramework",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_findBrowserFramework",
    "access": "protected",
    "description": "Tries to find a browser framework from an entry file comments or by its import statements.",
    "lineNumber": 368,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "comments",
        "description": "The dictionary of comments\n                                                           extracted from the file."
      },
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "importInformation",
        "description": "The information of the file import\n                                                           statements."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "_findNodeFramework",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_findNodeFramework",
    "access": "protected",
    "description": "Tries to find a Node framework from an entry file import statements.",
    "lineNumber": 387,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "importInformation",
        "description": "The information of the file import\n                                                           statements."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "_isLibrary",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_isLibrary",
    "access": "protected",
    "description": "Checks if a target should be a library or not based on its entry file comments, export\nstatements information and/or the framework it uses.",
    "lineNumber": 409,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "comments",
        "description": "The dictionary of comments\n                                                           extracted from the file."
      },
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "exportInformation",
        "description": "The information of the file export\n                                                           statements."
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "framework",
        "description": "The name of a framework the target\n                                                           uses."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 774,
    "kind": "method",
    "name": "_isABrowserTarget",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_isABrowserTarget",
    "access": "protected",
    "description": "Checks if a target type is `browser` based on its entry file comments, contents and/or\nthe framework it uses.",
    "lineNumber": 431,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "comments",
        "description": "The dictionary of comments extracted from the file."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The contents of the file."
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "framework",
        "description": "The name of a framework the target uses."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 775,
    "kind": "method",
    "name": "_needsBundling",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_needsBundling",
    "access": "protected",
    "description": "Checks if a Node target needs bundling by trying to find an import statement for an asset\n(like an image file).",
    "lineNumber": 451,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "importInformation",
        "description": "The information of the file import\n                                                           statements."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 776,
    "kind": "method",
    "name": "_needsTranspilation",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_needsTranspilation",
    "access": "protected",
    "description": "Checks if a Node target needs transpilation by trying to find import or export statements\nthat use ESModules.",
    "lineNumber": 465,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "importInformation",
        "description": "The information of the file import\n                                                           statements."
      },
      {
        "nullable": null,
        "types": [
          "TargetsFinderExtractInformation"
        ],
        "spread": false,
        "optional": false,
        "name": "exportInformation",
        "description": "The information of the file export\n                                                           statements."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "_getTypescriptSettings",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_getTypescriptSettings",
    "access": "protected",
    "description": "Gets the necessary settings for a target to use TypeScript.",
    "lineNumber": 487,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isANodeTarget",
        "description": "Whether or not the target is for Node."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "needsBundling",
        "description": "Whether or not the target needs bundling."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "entryPath",
        "description": "The path of the target entry file."
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "framework",
        "description": "The name of a framework the target uses."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "typeScript",
        "description": "The flag that indicates the target uses TypeScript."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateSourceMapSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "sourceMap",
        "description": "The settings for source maps all set to `true` as they are needed for the types."
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "framework",
        "description": "If the method detects a `.tsx` extension, it will add this property with `react` as value."
      },
      {
        "nullable": true,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "transpile",
        "description": "If the target is for Node and doesn't need bundling, then it needs at least transpilation in\norder to use TypeScript."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 778,
    "kind": "method",
    "name": "_getFlowSettings",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_getFlowSettings",
    "access": "protected",
    "description": "Gets the necessary settings for a target to use Flow.",
    "lineNumber": 519,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isANodeTarget",
        "description": "Whether or not the target is for Node."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "needsBundling",
        "description": "Whether or not the target needs bundling."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "flow",
        "description": "The flag that indicates the target uses TypeScript."
      },
      {
        "nullable": true,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "transpile",
        "description": "If the target is for Node and doesn't need bundling, then it needs at least transpilation in\norder to use TypeScript."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 779,
    "kind": "method",
    "name": "_findSettingsComment",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_findSettingsComment",
    "access": "protected",
    "description": "This method tries to find and parse settings on a \"@projext comment\" inside a target entry\nfile.",
    "lineNumber": 538,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The contents of the target entry file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 780,
    "kind": "method",
    "name": "_getFileExports",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_getFileExports",
    "access": "protected",
    "description": "Get the information of all the export statements from a given code.",
    "lineNumber": 586,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The code from where to extract the statements."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetsFinderExtractInformation"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 781,
    "kind": "method",
    "name": "_getFileImports",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_getFileImports",
    "access": "protected",
    "description": "Get the information of all the import statements from a given code.",
    "lineNumber": 596,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The code from where to extract the statements."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetsFinderExtractInformation"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 782,
    "kind": "method",
    "name": "_extractFromCode",
    "memberof": "src/services/targets/targetsFinder.js~TargetsFinder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsFinder.js~TargetsFinder#_extractFromCode",
    "access": "protected",
    "description": "Given a dictionary of regular expressions lists and a source code, this method will try to\nidentify and match the expressions in order to return all the matched results and the keys\nof the lists that returned results.",
    "examples": [
      "const dictionary = {\n  listOne: [/(goodbye)/ig, /(Batman)/ig],\n  listTwo: [/(hello)/ig, /(Nightwing)/ig],\n};\nconst code = 'hello Batman';\nconsole.log(this._extractFromCode(code, dictionary));\n// This would output { from: ['listOne', 'listTwo'], items: ['hello', 'Batman'] }"
    ],
    "lineNumber": 619,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The source code to parse."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "expressionsDictionary",
        "description": "A dictionary of regular expressions lists."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TargetsFinderExtractInformation"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if a regular expression doesn't have a capturing group."
      }
    ]
  },
  {
    "__docId__": 783,
    "kind": "variable",
    "name": "targetsFinder",
    "memberof": "src/services/targets/targetsFinder.js",
    "static": true,
    "longname": "src/services/targets/targetsFinder.js~targetsFinder",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsFinder.js",
    "importStyle": "{targetsFinder}",
    "description": "The service provider that once registered on the app container will create an instance of\n`TargetsFinder` and set its `find` method as the `targetsFinder` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targetsFinder);\n// Getting access to the service function\nconst targetsFinder = container.get('targetsFinder');"
    ],
    "lineNumber": 668,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 784,
    "kind": "file",
    "name": "src/services/targets/targetsHTML.js",
    "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst { provider } = require('jimple');\n/**\n * This service allows the validation of a {@link BrowserTarget} `html.template` file and it also\n * takes care of generating a _\"default template\"_ if the one on the target settings doesn't exist.\n */\nclass TargetsHTML {\n  /**\n   * Class constructor.\n   * @param {Events}    events    To reduce the settings and the template of the generated HTML\n   *                              files.\n   * @param {TempFiles} tempFiles To save a generated HTML file on the temp directory.\n   */\n  constructor(events, tempFiles) {\n    /**\n     * A local reference for the `events` service.\n     * @type {Events}\n     */\n    this.events = events;\n    /**\n     * A local reference for the `tempFiles` service.\n     * @type {TempFiles}\n     */\n    this.tempFiles = tempFiles;\n    /**\n     * Bind the method so it can be registered as the service itself.\n     * @ignore\n     */\n    this.getFilepath = this.getFilepath.bind(this);\n  }\n  /**\n   * Validate if a target HTML template exists or not.\n   * @param {Target} target The target information.\n   * @return {Object}\n   * @property {string}  path   The absolute path to the HTML template.\n   * @property {boolean} exists Whether or notthe HTML template exists.\n   */\n  validate(target) {\n    const htmlPath = path.join(target.paths.source, target.html.template);\n    return {\n      path: htmlPath,\n      exists: fs.pathExistsSync(htmlPath),\n    };\n  }\n  /**\n   * Given a target, this method will validate if the target has an HTML template file and return\n   * its absolute path; if the file doesn't exists, it will generate a new one, save it on the\n   * temp directory and return its path.\n   * @param {Target}  target                   The target information.\n   * @param {boolean} [force=false]            Optional. If this is `true`, the file will be\n   *                                           created anyways.\n   * @param {string}  [buildType='production'] Optional. If the HTML is for an specific type of\n   *                                           build. This may be useful for plugins.\n   * @return {string}\n   */\n  getFilepath(target, force = false, buildType = 'production') {\n    const validation = this.validate(target);\n    return validation.exists && !force ? validation.path : this._generateHTML(target, buildType);\n  }\n  /**\n   * This method generates a default HTML file template for a target, saves it on the temp\n   * directory and returns its path.\n   * This method emits two reducer events:\n   * - `target-default-html-settings`: It receives a {@link TargetDefaultHTMLSettings}, the target\n   *  information and it expects another {@link TargetDefaultHTMLSettings} in return.\n   * - `target-default-html`: It receives the HTML code for the file, the target information and\n   *  it expects a new HTML code in return.\n   * @param {Target} target    The target information.\n   * @param {string} buildType The type of build for which the HTML is for.\n   * @return {string}\n   * @throws {Error} If the file couldn't be saved on the temp directory.\n   * @ignore\n   * @access protected\n   */\n  _generateHTML(target, buildType) {\n    // Reduce the settings for the template.\n    const info = this.events.reduce(\n      'target-default-html-settings',\n      {\n        title: target.name,\n        bodyAttributes: '',\n        bodyContents: '<div id=\"app\"></div>',\n      },\n      target,\n      buildType\n    );\n    // Normalize the body attributes to avoid unnecessary spaces on the tag.\n    const bodyAttrs = info.bodyAttributes ? ` ${info.bodyAttributes}` : '';\n    // Generate the HTML code.\n    const htmlTpl = [\n      '<!doctype html>',\n      '<html lang=\"en\">',\n      '<head>',\n      ' <meta charset=\"utf-8\" />',\n      ' <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />',\n      ' <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />',\n      ` <title>${info.title}</title>`,\n      '</head>',\n      `<body${bodyAttrs}>`,\n      ` ${info.bodyContents}`,\n      '</body>',\n      '</html>',\n    ].join('\\n');\n    // Reduce the HTML code.\n    const html = this.events.reduce('target-default-html', htmlTpl, target);\n    // Normalize the target name to avoid issues with packages with scope.\n    const filename = target.name.replace(/\\//g, '-');\n    // Write the file on the temp directory.\n    return this.tempFiles.writeSync(`${filename}.index.html`, html);\n  }\n}\n/**\n * The service provider that once registered on the app container will create an instance of\n * `TargetsHTML` and set it as the `targetsHTML` service.\n * @example\n * // Register it on the container\n * container.register(targetsHTML);\n * // Getting access to the service function\n * const targetsHTML = container.get('targetsHTML');\n * @type {Provider}\n */\nconst targetsHTML = provider((app) => {\n  app.set('targetsHTML', () => new TargetsHTML(\n    app.get('events'),\n    app.get('tempFiles')\n  ));\n});\n\nmodule.exports = {\n  TargetsHTML,\n  targetsHTML,\n};\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/services/targets/targetsHTML.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 785,
    "kind": "class",
    "name": "TargetsHTML",
    "memberof": "src/services/targets/targetsHTML.js",
    "static": true,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsHTML.js",
    "importStyle": "{TargetsHTML}",
    "description": "This service allows the validation of a {@link BrowserTarget} `html.template` file and it also\ntakes care of generating a _\"default template\"_ if the one on the target settings doesn't exist.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 786,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#constructor",
    "access": "public",
    "description": "Class constructor.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Events"
        ],
        "spread": false,
        "optional": false,
        "name": "events",
        "description": "To reduce the settings and the template of the generated HTML\n                             files."
      },
      {
        "nullable": null,
        "types": [
          "TempFiles"
        ],
        "spread": false,
        "optional": false,
        "name": "tempFiles",
        "description": "To save a generated HTML file on the temp directory."
      }
    ]
  },
  {
    "__docId__": 787,
    "kind": "member",
    "name": "events",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#events",
    "access": "public",
    "description": "A local reference for the `events` service.",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "Events"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 788,
    "kind": "member",
    "name": "tempFiles",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#tempFiles",
    "access": "public",
    "description": "A local reference for the `tempFiles` service.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "TempFiles"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 790,
    "kind": "method",
    "name": "validate",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#validate",
    "access": "public",
    "description": "Validate if a target HTML template exists or not.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The absolute path to the HTML template."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "exists",
        "description": "Whether or notthe HTML template exists."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 791,
    "kind": "method",
    "name": "getFilepath",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#getFilepath",
    "access": "public",
    "description": "Given a target, this method will validate if the target has an HTML template file and return\nits absolute path; if the file doesn't exists, it will generate a new one, save it on the\ntemp directory and return its path.",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Optional. If this is `true`, the file will be\n                                          created anyways."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'production'",
        "defaultRaw": "'production'",
        "name": "buildType",
        "description": "Optional. If the HTML is for an specific type of\n                                          build. This may be useful for plugins."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 792,
    "kind": "method",
    "name": "_generateHTML",
    "memberof": "src/services/targets/targetsHTML.js~TargetsHTML",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/services/targets/targetsHTML.js~TargetsHTML#_generateHTML",
    "access": "protected",
    "description": "This method generates a default HTML file template for a target, saves it on the temp\ndirectory and returns its path.\nThis method emits two reducer events:\n- `target-default-html-settings`: It receives a {@link TargetDefaultHTMLSettings}, the target\n information and it expects another {@link TargetDefaultHTMLSettings} in return.\n- `target-default-html`: It receives the HTML code for the file, the target information and\n it expects a new HTML code in return.",
    "lineNumber": 76,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "buildType",
        "description": "The type of build for which the HTML is for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the file couldn't be saved on the temp directory."
      }
    ]
  },
  {
    "__docId__": 793,
    "kind": "variable",
    "name": "targetsHTML",
    "memberof": "src/services/targets/targetsHTML.js",
    "static": true,
    "longname": "src/services/targets/targetsHTML.js~targetsHTML",
    "access": "public",
    "export": true,
    "importPath": "projext/src/services/targets/targetsHTML.js",
    "importStyle": "{targetsHTML}",
    "description": "The service provider that once registered on the app container will create an instance of\n`TargetsHTML` and set it as the `targetsHTML` service.",
    "examples": [
      "// Register it on the container\ncontainer.register(targetsHTML);\n// Getting access to the service function\nconst targetsHTML = container.get('targetsHTML');"
    ],
    "lineNumber": 123,
    "type": {
      "nullable": null,
      "types": [
        "Provider"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 794,
    "kind": "file",
    "name": "src/typedef.js",
    "content": "/**\n * ================================================================================================\n * Externals\n * ================================================================================================\n */\n\n/**\n * @external {Jimple}\n * https://yarnpkg.com/en/package/jimple\n */\n\n/**\n * @external {Nodemon}\n * https://github.com/remy/nodemon/blob/master/doc/requireable.md\n */\n\n/**\n * @external {Command}\n * https://tj.github.io/commander.js/#Command\n */\n\n/**\n * @external {Watchpack}\n * https://yarnpkg.com/en/package/watchpack\n */\n\n/**\n * @external {WatchpackOptions}\n * https://github.com/webpack/watchpack#api\n */\n\n/**\n * @external {AppConfiguration}\n * https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html\n */\n\n/**\n * @external {PathUtils}\n * https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html\n */\n\n/**\n * @external {Logger}\n * https://homer0.github.io/wootils/class/wootils/node/logger.js~Logger.html\n */\n\n/**\n * @external {EnvironmentUtils}\n * https://homer0.github.io/wootils/class/wootils/node/environmentUtils.js~EnvironmentUtils.html\n */\n\n/**\n * @external {EventsHub}\n * https://homer0.github.io/wootils/class/wootils/shared/eventsHub.js~EventsHub.html\n */\n\n/**\n * @external {ErrorHandler}\n * https://homer0.github.io/wootils/class/wootils/node/errorHandler.js~ErrorHandler.html\n */\n\n/**\n * @external {RootRequire}\n * https://homer0.github.io/wootils/function/index.html#static-function-rootRequire\n */\n\n/**\n * @external {Buffer}\n * https://nodejs.org/api/buffer.html\n */\n\n/**\n * @external {ndb}\n * https://github.com/GoogleChromeLabs/ndb\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets > sub properties > Shared\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} TargetTypeCheck\n * @property {boolean} node\n * Whether the target type is `node` or not.\n * @property {boolean} browser\n * Whether the target type is `browser` or not.\n */\n\n/**\n * @typedef {Object} TargetPaths\n * @property {string} source\n * The absolute path to the target source directory.\n * @property {string} build\n * The absolute path to the folder, inside the distribution directory, where the target will be\n * bundled/copied.\n */\n\n/**\n * @typedef {Object} TargetFolders\n * @property {string} source\n * The relative path to the target source directory.\n * @property {string} build\n * The relative path to the folder, inside the distribution directory, where the target will be\n * bundled/copied.\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets templates > Sub properties > Shared\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateEntry\n * @property {string} [default='index.js']\n * The target entry file for all types of build that don't have a specified entry.\n * @property {string} [development=null]\n * The target entry file on a development build. If `null`, it will fallback to the one specified\n * on `default`.\n * @property {string} [production=null]\n * The target entry file on a production build. If `null`, it will fallback to the one specified\n * on `default`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateOutputPaths\n * @property {string} [js]\n * The path to generated Javascript files on the distribution directory.\n *\n * The available placeholders are:\n * - `[target-name]`: The name of the target.\n * - `[hash]`: A random hash generated for cache busting.\n *\n * The default value is:\n * - For `node` targets, on all build types: `[target-name].js`.\n * - For `browser` targets:\n *   - `development`: `'statics/js/[target-name].js'`.\n *   - `production`: `'statics/js/[target-name].[hash].js'`.\n * @property {string} [css]\n * The path to generated stylesheets on the distribution directory.\n *\n * The available placeholders are:\n * - `[target-name]`: The name of the target.\n * - `[hash]`: A random hash generated for cache busting.\n *\n * The default value is, for both `node` and `browser` targets:\n * - `development`: `'statics/styles/[target-name].css'`.\n * - `production`: `'statics/styles/[target-name].[hash].css'`.\n * @property {string} [fonts]\n * The path to font files once they are copied to the distribution directory.\n *\n * The available placeholders are:\n * - `[target-name]`: The name of the target.\n * - `[name]`: The file original name.\n * - `[ext]`: The file original extension.\n * - `[hash]`: A random hash generated for cache busting.\n *\n * The default value is, for both `node` and `browser` targets:\n * - `development`: `'statics/fonts/[name]/[name][ext]'`.\n * - `production`: `'statics/fonts/[name]/[name].[hash].[ext]'`.\n * @property {string} [fonts]\n * The path to image files once they are copied to the distribution directory.\n *\n * The available placeholders are:\n * - `[target-name]`: The name of the target.\n * - `[name]`: The file original name.\n * - `[ext]`: The file original extension.\n * - `[hash]`: A random hash generated for cache busting.\n *\n * The default value is, for both `node` and `browser` targets:\n * - `development`: `'statics/images/[name][ext]'`.\n * - `production`: `'statics/images/[name].[hash].[ext]'`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateOutput\n * @property {ProjectConfigurationTargetTemplateOutputPaths} [default]\n * The target output settings for all types of build that don't have specified settings.\n * @property {ProjectConfigurationTargetTemplateOutputPaths} [development]\n * The target output settings on a development build. If `null`, it will fallback to the ones\n * specified on `default`.\n * @property {ProjectConfigurationTargetTemplateOutputPaths} [production]\n * The target output settings on a production build. If `null`, it will fallback to the ones\n * specified on `default`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateCopyItem\n * @property {string}  from The path to the file, relative to the target source directory.\n * @property {?string} to   The path where the file will be copied, relative to the target\n *                          distribution directory. If not specified, the file will be copied to\n *                          the root of the target distribution directory.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetWatchOptions\n * @property {boolean} [development=false] Whether or not to watch the target files when it gets\n *                                         build for development. If the target type is Node and it\n *                                         doesn't require bundling nor transpiling, it won't do\n *                                         anything.\n * @property {boolean} [production=false]  Whether or not to watch the target files when it gets\n *                                         build for production.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateBabelFeatures\n * @property {boolean} [classProperties=false]\n * This enables `@babel/plugin-proposal-class-properties` so the targets can use classes with\n * properties.\n * @property {boolean} [decorators=false]\n * This enables `@babel/plugin-proposal-decorators` so the targets can use decorators (based on\n * the current TC39 proposal).\n * @property {boolean} [dynamicImports=true]\n * This enables `@babel/plugin-syntax-dynamic-import` so the targets can do dynamic imports and\n * code splitting.\n * @property {boolean} [objectRestSpread=true]\n * This enables `@babel/plugin-proposal-object-rest-spread` so the targets can use rest and spread\n * with objects.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplateSourceMapSettings\n * @property {boolean} [development=false]\n * Whether or not to generate a source map on a development build.\n * @property {boolean} [production=true]\n * Whether or not to generate a source map on a production build.\n */\n\n/**\n * @typdef {Object} ProjectConfigurationTargetTemplateDotEnvSettings\n * @property {boolean} [enabled=true]\n * Whether or not the feature is enabled.\n * @property {Array} [files]\n * The list of files projext will try to find in order to load the variables. Based on the value\n * of `extend`, the way projext will process them may change.\n *\n * The available placeholders are:\n * - `[target-name]`: The name of the target.\n * - `[build-type]`: The type of bundle/build projext is creating (`development` or `production`).\n *\n * The default value is, for both `node` and `browser` targets:\n *\n * ```\n * [\n *   '.env.[target-name].[build-type]',\n *   '.env.[target-name]',\n *   '.env.[build-type]',\n *   '.env',\n * ]\n * ```\n * @property {boolean} [extend=true]\n * Whether or not projext should merge all the variables from all the files it can find.\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets templates > Sub properties > Node\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodeTargetTemplateBabelSettings\n * @property {ProjectConfigurationTargetTemplateBabelFeatures} [features]\n * This object can be used to enable/disable the Babel plugins projext includes.\n * If you need other plugins, they can be included on the `overwrites` option.\n * @property {string} [nodeVersion='current']\n * When building the Babel configuration, projext uses the `@babel/preset-env` to just include the\n * necessary stuff. This setting tells the preset the version of Node it should _\"complete\"_.\n * @property {Object} [env={}]\n * Custom settings that projext will use as base when generating the ones for the\n * `@babel/preset-env`.\n * @property {Object} [overwrites={}]\n * If you know how to use Babel and need stuff that is not covered by projext, you can use this\n * setting to overwrite/add any value you may need.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodeTargetTemplateLibraryOptions\n * @property {string} [libraryTarget='commonjs2']\n * How the library will be exposed: `commonjs2` or `umd`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodeTargetTemplateCSSSettings\n * @property {boolean} [modules=false]\n * Whether or not your application uses CSS Modules. If this is enabled, all your styles will be\n * prefixed with a unique identifier.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodeTargetInspectSettings\n * @property {boolean} [enabled=false]     Whether or not to enable the Node inspector when running\n *                                         the app for development.\n * @property {string}  [host='0.0.0.0']    The host where the Node inspector will run.\n * @property {number}  [port=9229]         The port the Node inspector will use.\n * @property {string}  [command='inspect'] The Node inspector flag command (`inspect` or\n *                                         `inspect-brk`).\n * @property {boolean} [ndb=false]         Whether or not to use Google's {@link ndb} instead of\n *                                         the native inspector. The way it will be used will be\n *                                         by calling the executable without path, so it's up to\n *                                         the project to install it (global or local).\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets templates > Sub properties > Browser\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateHTMLSettings\n * @property {string} [default='index.html']\n * This setting can be used to set the same value of default `template` and `filename` at once. But\n * it will only overwrite settings with a `null` value, if one is specified, the value of this\n * setting will be ignored.\n * @property {string} [template=null]\n * The file inside your target source that will be used to generate the `html`. If `null`, it will\n * fallback to the value of the `default` setting.\n * @property {string} [filename=null]\n * The file that will be generated when your target is bundled. It will automatically include\n * the `<script />` tag to the generated bundle. If `null`, it will fallback to the value of the\n * `default` setting.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateCSSSettings\n * @property {boolean} [modules=false]\n * Whether or not your application uses CSS Modules. If this is enabled, all your styles will be\n * prefixed with a unique identifier.\n * @property {boolean} [inject=false]\n * If this setting is set to `true`, instead of generating a CSS file with your styles, they'll be\n * dynamically injected on HTML when the bundle gets executed.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateBabelSettings\n * @property {ProjectConfigurationTargetTemplateBabelFeatures} [features]\n * This object can be used to enable/disable the Babel plugins projext includes.\n * If you need other plugins, they can be included on the `overwrites` option.\n * @property {number} [browserVersions=2]\n * When building the Babel configuration, projext uses the `@babel/preset-env` to just include the\n * necessary stuff. This setting tells how many old versions of the major browsers the target needs\n * transpilation for.\n * Major browsers: Firefox, Chrome, Safari and Edge.\n * @property {boolean} [mobileSupport=true]\n * If `true`, the configuration will add to the list of major browsers `iOS` and `Android`.\n * @property {boolean} [polyfill=true]\n * Whether or not the configuration for the `@babel/preset-env` should include the settings for\n * for `useBuiltIns` and `corejs`.\n * @property {Object} [overwrites={}]\n * If you know how to use Babel and need stuff that is not covered by projext, you can use this\n * setting to overwrite/add any value you may need.\n * @property {Object} [env={}]\n * Custom settings that projext will use as base when generating the ones for the\n * `@babel/preset-env`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings\n * @property {string} [key=null]\n * The path to the SSL key (`.key`).\n * @property {string} [cert=null]\n * The path to the SSL certificate (`.crt`).\n * @property {string} [ca=null]\n * The path to the SSL public file (`.pem`).\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings\n * @property {boolean} [enabled=false]\n * Whether or not the dev server is being proxied.\n * @property {?string} [host=null]\n * The host used to proxy the dev server. If `null`, it will use the host defined on the dev server\n * main settings.\n * @property {?boolean} [https=null]\n * Whether or not the proxied host uses `https`. If `null` and you have provided SSL certificates\n * for the server, it will become `true`, otherwise it will be `false`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateDevServerSettings\n * @property {number} [port=2509]\n * The server port.\n * @property {boolean} [reload=true]\n * Whether or not to reload the browser when the code changes.\n * @property {boolean} [open=true]\n * Whether or not to open the browser when server is ready.\n * @property {string} [host='localhost']\n * The dev server hostname.\n * @property {ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings} [ssl]\n * The paths to the files to enable SSL on the dev server.\n * @property {ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings} [proxied]\n * When the dev server is being proxied (using `nginx` for example), there are certain\n * functionalities, like hot module replacement and live reload that need to be aware of this.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateConfigurationSettings\n * @property {boolean} [enabled=false]\n * Whether or not the feature is enabled.\n * @property {null|Object} [default=null]\n * The default configuration. If none is specified, when the target is builded, it will try to\n * use `[target-name].config.js`, located on the configuration folder.\n * @property {string} [path='config/']\n * The path where the configuration files are located.\n * @property {boolean} [hasFolder=true]\n * Whether or not there's a folder with the target name on the configuration path.\n * @property {string} [defineOn='process.env.CONFIG']\n * The name of the variable where the configuration is going to be replaced on your code when\n * bundled.\n * @property {string} [environmentVariable='CONFIG']\n * The name of the environment variable projext will check when building the target in order to\n * load a dynamic configuration.\n * @property {boolean} [loadFromEnvironment=true]\n * Whether or not projext should check for the environment variable value.\n * @property {string} [filenameFormat='[target-name].[configuration-name].config.js']\n * The name format of the configuration files.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplateLibraryOptions\n * @property {string} [libraryTarget='umd']\n * How the library will be exposed: `commonjs2`, `umd` or `window`.\n * @property {boolean} [compress=false]\n * Whether or not to use gzip compression on the generated library file.\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets and target templates > Node\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodeTargetTemplate\n * @property {boolean} [bundle=false]\n * Whether or not the target needs to be bundled.\n * If the value is `false`, when running on a development environment, and if the target doesn't\n * need transpilation, the code won't be moved to the distribution directory.\n * @property {boolean} [transpile=false]\n * This option is kind of tied to the previous one: You may not want to bundle your Node target,\n * but you can transpile it with [Babel](https://babeljs.io) if you want to use a feature not yet\n * supported by the runtime.\n * @property {string} [engine='webpack']\n * In case `bundle` is `true`, this will tell projext which build engine you are going to bundle\n * the target code with.\n * @property {boolean} [hasFolder=true]\n * Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\n * the contents of the source directory are your target code (useful when working with a single\n * target).\n * @property {boolean} [createFolder=true]\n * Whether or not to create a folder for your targets code on the distribution directory when the\n * target is bundled/copied.\n * @property {string} [folder='']\n * If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\n * folder name than the target's name.\n * @property {ProjectConfigurationTargetTemplateEntry} [entry]\n * The target entry files for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} [output]\n * The target output settings for each specific build type.\n * @property {ProjectConfigurationTargetTemplateSourceMapSettings} [sourceMap]\n * The target source map settings for each specific environment build.\n * @property {ProjectConfigurationNodeTargetInspectSettings} [inspect]\n * The target settings for the Node inspector.\n * @property {ProjectConfigurationNodeTargetTemplateCSSSettings} [css]\n * These options help you customize the way the bundling process handles your CSS code.\n * @property {Array} [includeModules=[]]\n * This setting can be used to specify a list of node modules you want to process on your bundle.\n * @property {Array} [excludeModules=[]]\n * This setting can be used to specify a list of modules that should never be bundled. By default,\n * projext will exclude all the dependencies from the `package.json`, but if you import modules\n * using a sub path (like `colors/safe` instead of `colors`), you need to specify it on this list\n * so the build engine won't try to put it inside the bundle it.\n * @property {Array} [includeTargets=[]]\n * This setting can be used to specify a list of other targets you want to process on your bundle.\n * This means that JS and SCSS files from these targets will be transpiled/processed.\n * @property {boolean} [runOnDevelopment=false]\n * This tells projext that when the target is builded (bundled/copied) on a development\n * environment, it should execute it.\n * @property {ProjectConfigurationTargetWatchOptions} [watch]\n * The settings for the projext watch mode, which watches the target files for changes and updates\n * the build without executing it.\n * @property {ProjectConfigurationNodeTargetTemplateBabelSettings} [babel]\n * The target transpilation options.\n * @property {boolean} [flow=false]\n * Whether or not your target uses [flow](https://flow.org/). This will update the Babel\n * @property {boolean} [typeScript=false]\n * Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\n * configuration in order to add support and, in case it was disabled, enable transpilation.\n * @property {boolean} [library=false]\n * If the project is bundled, this will tell the build engine that it needs to be builded as a\n * library to be `require`d.\n * @property {ProjectConfigurationNodeTargetTemplateLibraryOptions} [libraryOptions]\n * In case `library` is `true`, these options are going to be used by the build engine to configure\n * your library\n * @property {boolean} [cleanBeforeBuild=true]\n * Whether or not to remove all code from previous builds from the distribution directory when\n * making a new build.\n * @property {Array} [copy=[]]\n * A list of files to copy during the bundling process. It can be a list of file paths relative to\n * the target source directory, in which case they'll be copied to the target distribution\n * directory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}.\n * @property {ProjectConfigurationTargetTemplateDotEnvSettings} [dotEnv]\n * These options are used by both projext and the build engine in order to load \"environment\n * files\".\n */\n\n/**\n * @typedef {Object} NodeTarget\n * @property {boolean} bundle\n * Whether or not the target needs to be bundled.\n * If the value is `false`, when running on a development environment, and if the target doesn't\n * need transpilation, the code won't be moved to the distribution directory.\n * @property {boolean} transpile\n * This option is kind of tied to the previous one: You may not want to bundle your Node target,\n * but you can transpile it with [Babel](https://babeljs.io) if you want to use a feature not yet\n * supported by the runtime.\n * @property {string} engine\n * In case `bundle` is `true`, this will tell projext which build engine you are going to bundle\n * the target code with.\n * @property {boolean} hasFolder\n * Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\n * the contents of the source directory are your target code (useful when working with a single\n * target).\n * @property {boolean} createFolder\n * Whether or not to create a folder for your targets code on the distribution directory when the\n * target is bundled/copied.\n * @property {string} folder\n * If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\n * folder name than the target's name.\n * @property {ProjectConfigurationTargetTemplateEntry} entry\n * The target entry files for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} output\n * The target output settings for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} originalOutput\n * The target output settings for each specific build type, without the placeholders replaced.\n * @property {ProjectConfigurationTargetTemplateSourceMapSettings} sourceMap\n * The target source map settings for each specific environment build.\n * @property {ProjectConfigurationNodeTargetInspectSettings} inspect\n * The target settings for the Node inspector.\n * @property {ProjectConfigurationNodeTargetTemplateCSSSettings} css\n * These options help you customize the way the bundling process handles your CSS code.\n * @property {Array} includeModules\n * This setting can be used to specify a list of node modules you want to process on your bundle.\n * This means that JS files from modules on this list will be transpiled.\n * @property {Array} excludeModules\n * This setting can be used to specify a list of modules that should never be bundled. By default,\n * projext will exclude all the dependencies from the `package.json`, but if you import modules\n * using a sub path (like `colors/safe` instead of `colors`), you need to specify it on this list\n * so the build engine won't try to put it inside the bundle it.\n * @property {Array} includeTargets\n * This setting can be used to specify a list of other targets you want to process on your bundle.\n * This means that JS and SCSS files from these targets will be transpiled/processed.\n * @property {boolean} runOnDevelopment\n * This tells projext that when the target is builded (bundled/copied) on a development\n * environment, it should execute it.\n * @property {ProjectConfigurationTargetWatchOptions} watch\n * The settings for the projext watch mode, which watches the target files for changes and updates\n * the build without executing it.\n * @property {ProjectConfigurationNodeTargetTemplateBabelSettings} babel\n * The target transpilation options.\n * @property {boolean} flow\n * Whether or not your target uses [flow](https://flow.org/). This will update the Babel\n * configuration in order to add support and, in case it was disabled, enable transpilation.\n * @property {boolean} typeScript\n * Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\n * configuration in order to add support and, in case it was disabled, enable transpilation.\n * @property {boolean} library\n * If the project is bundled, this will tell the build engine that it needs to be builded as a\n * library to be `require`d.\n * @property {ProjectConfigurationNodeTargetTemplateLibraryOptions} libraryOptions\n * In case `library` is `true`, these options are going to be used by the build engine to configure\n * your library\n * @property {boolean} cleanBeforeBuild\n * Whether or not to remove all code from previous builds from the distribution directory when\n * making a new build.\n * @property {Array} copy\n * A list of files to copy during the bundling process. It can be a list of file paths relative to\n * the target source directory, in which case they'll be copied to the target distribution\n * directory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}.\n * @property {TargetTypeCheck} is\n * To check whether the target type is `node` or `browser`\n * @property {TargetPaths} paths\n * The target absolute paths to both the source directory folder and the distribution directory\n * folder.\n * @property {TargetFolders} folders\n * The target relative paths to both the source directory folder and the distribution directory\n * folder.\n * @property {ProjectConfigurationTargetTemplateDotEnvSettings} dotEnv\n * These options are used by both projext and the build engine in order to load \"environment\n * files\".\n */\n\n/**\n * ================================================================================================\n * Project configuration > Targets and target templates > Browser\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationBrowserTargetTemplate\n * @property {string} [engine='webpack']\n * This will tell projext which build engine you are going to bundle the target code with.\n * @property {boolean} [hasFolder=true]\n * Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\n * the contents of the source directory are your target code (useful when working with a single\n * target).\n * @property {boolean} [createFolder=true]\n * Whether or not to create a folder for your targets code on the distribution directory when the\n * target is bundled/copied.\n * @property {string} [folder='']\n * If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\n * folder name than the target's name.\n * @property {ProjectConfigurationTargetTemplateEntry} [entry]\n * The target entry files for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} [output]\n * The target output settings for each specific build type.\n * @property {ProjectConfigurationTargetTemplateSourceMapSettings} [sourceMap]\n * The target source map settings for each specific environment build.\n * @property {ProjectConfigurationBrowserTargetTemplateHTMLSettings} [html]\n * In the case the target is an app, these are the options for the `html` file that will include\n * the bundle `<script />`; and if your target is a library, this can be used to test your library.\n * @property {ProjectConfigurationBrowserTargetTemplateCSSSettings} [css]\n * These options help you customize the way the bundling process handles your CSS code.\n * @property {Array} [includeModules=[]]\n * This setting can be used to specify a list of node modules you want to process on your bundle.\n * This means that JS files from modules on this list will be transpiled.\n * @property {Array} [includeTargets=[]]\n * This setting can be used to specify a list of other targets you want to process on your bundle.\n * This means that JS and SCSS files from these targets will be transpiled/processed.\n * @property {boolean} [uglifyOnProduction=true]\n * When a bundle is created, this setting will tell the build engine whether to uglify the code\n * for production or not.\n * @property {boolean} [runOnDevelopment=false]\n * This will tell the build engine that when you build the target for a development environment,\n * it should bring up an `http` server to _\"run\"_ your target.\n * @property {ProjectConfigurationTargetWatchOptions} [watch]\n * The settings for the projext watch mode, which watches the target files for changes and updates\n * the build without executing it.\n * @property {ProjectConfigurationBrowserTargetTemplateBabelSettings} [babel]\n * These options are used by the build engine to configure [Babel](https://babeljs.io):\n * @property {boolean} [flow=false]\n * Whether or not your target uses [flow](https://flow.org/). This will update the Babel\n * configuration in order to add support for it.\n * @property {boolean} [typeScript=false]\n * Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\n * configuration in order to add support for it.\n * @property {boolean} [library=false]\n * This will tell the build engine that it needs to be builded as a library to be `require`d.\n * @property {ProjectConfigurationBrowserTargetTemplateLibraryOptions} [libraryOptions]\n * In case `library` is `true`, these options are going to be used by the build engine to configure\n * your library.\n * @property {boolean} [cleanBeforeBuild=true]\n * Whether or not to remove all code from previous builds from the distribution directory when\n * making a new build.\n * @property {Array} [copy=[]]\n * A list of files to copy during the bundling process. It can be a list of file paths relative to\n * the target source directory, in which case they'll be copied to the target distribution\n * directory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}.\n * @property {ProjectConfigurationTargetTemplateDotEnvSettings} [dotEnv]\n * These options are used by both projext and the build engine in order to load \"environment\n * files\".\n * @property {ProjectConfigurationBrowserTargetTemplateDevServerSettings} [devServer]\n * These are the options for the `http` server projext will use when running the target on a\n * development environment.\n * @property {ProjectConfigurationBrowserTargetTemplateConfigurationSettings} [configuration]\n * These are the settings for the feature that allows a browser target to have a dynamic\n * configuration file.\n */\n\n/**\n * @typedef {Object} BrowserTarget\n * @property {string} engine\n * This will tell projext which build engine you are going to bundle the target code with.\n * @property {boolean} hasFolder\n * Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\n * the contents of the source directory are your target code (useful when working with a single\n * target).\n * @property {boolean} createFolder\n * Whether or not to create a folder for your targets code on the distribution directory when the\n * target is bundled/copied.\n * @property {string} folder\n * If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\n * folder name than the target's name.\n * @property {ProjectConfigurationTargetTemplateEntry} entry\n * The target entry files for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} output\n * The target output settings for each specific build type.\n * @property {ProjectConfigurationTargetTemplateOutput} originalOutput\n * The target output settings for each specific build type, without the placeholders replaced.\n * @property {ProjectConfigurationTargetTemplateSourceMapSettings} sourceMap\n * The target source map settings for each specific environment build.\n * @property {ProjectConfigurationBrowserTargetTemplateHTMLSettings} html\n * In the case the target is an app, these are the options for the `html` file that will include\n * the bundle `<script />`; and if your target is a library, this can be used to test your library.\n * @property {ProjectConfigurationBrowserTargetTemplateCSSSettings} css\n * These options help you customize the way the bundling process handles your CSS code.\n * @property {Array} includeModules\n * This setting can be used to specify a list of node modules you want to process on your bundle.\n * This means that JS files from modules on this list will be transpiled.\n * @property {Array} includeTargets\n * This setting can be used to specify a list of other targets you want to process on your bundle.\n * This means that JS and SCSS files from these targets will be transpiled/processed.\n * @property {boolean} uglifyOnProduction\n * When a bundle is created, this setting will tell the build engine whether to uglify the code\n * for production or not.\n * @property {boolean} runOnDevelopment\n * This will tell the build engine that when you build the target for a development environment,\n * it should bring up an `http` server to _\"run\"_ your target.\n * @property {ProjectConfigurationTargetWatchOptions} watch\n * The settings for the projext watch mode, which watches the target files for changes and updates\n * the build without executing it.\n * @property {ProjectConfigurationBrowserTargetTemplateBabelSettings} babel\n * These options are used by the build engine to configure [Babel](https://babeljs.io):\n * @property {boolean} flow\n * Whether or not your target uses [flow](https://flow.org/). This will update the Babel\n * configuration in order to add support for it.\n * @property {boolean} typeScript\n * Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\n * configuration in order to add support for it.\n * @property {boolean} library\n * This will tell the build engine that it needs to be builded as a library to be `require`d.\n * @property {ProjectConfigurationBrowserTargetTemplateLibraryOptions} libraryOptions\n * In case `library` is `true`, these options are going to be used by the build engine to configure\n * your library.\n * @property {boolean} cleanBeforeBuild\n * Whether or not to remove all code from previous builds from the distribution directory when\n * making a new build.\n * @property {Array} copy\n * A list of files to copy during the bundling process. It can be a list of file paths relative to\n * the target source directory, in which case they'll be copied to the target distribution\n * directory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}.\n * @property {ProjectConfigurationTargetTemplateDotEnvSettings} dotEnv\n * These options are used by both projext and the build engine in order to load \"environment\n * files\".\n * @property {ProjectConfigurationBrowserTargetTemplateDevServerSettings} devServer\n * These are the options for the `http` server projext will use when running the target on a\n * development environment.\n * @property {ProjectConfigurationBrowserTargetTemplateConfigurationSettings} configuration\n * These are the settings for the feature that allows a browser target to have a dynamic\n * configuration file.\n * @property {TargetTypeCheck} is\n * To check whether the target type is `node` or `browser`\n * @property {TargetPaths} paths\n * The target absolute paths to both the source directory folder and the distribution directory\n * folder.\n * @property {TargetFolders} folders\n * The target relative paths to both the source directory folder and the distribution directory\n * folder.\n */\n\n/**\n * ================================================================================================\n * Project configuration & Sub properties\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} ProjectConfigurationPathSettings\n * @property {string} [source='src']\n * The directory, relative to your project path, where your targets code is located. On the\n * documentation is often referred as the _\"source directory\"_.\n * @property {string} [build='dist']\n * The directory, relative to your project path, where your targets bundled code will be located.\n * On the documentation is often referred as the _\"distribution directory\"_.\n * @property {string} [privateModules='private']\n * This is for the feature that copies when bundling. In case you are using the feature to copy an\n * npm module that, let's say, is not published, projext will save that module (without its\n * dependencies) on that folder.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetTemplates\n * @property {ProjectConfigurationNodeTargetTemplate} [node]\n * The template settings for all targets with the type `node`.\n * @property {ProjectConfigurationBrowserTargetTemplate} [browser]\n * The template settings for all targets with the type `browser`.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationFeatureTriggerSettings\n * @property {boolean} [enabled=true]\n * Whether or not the feature should be triggered when a target is being build.\n * @property {boolean} [onlyOnProduction=true]\n * This tells projext if the feature should be triggered only when building for production, or if\n * it should do it for development too.\n * @property {Array} [targets=[]]\n * This can be used to specify the targets that will trigger the feature when builded. If no target\n * is specified, the feature will be triggered by all the targets.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationCopyFeatureSettings\n * @property {boolean} [enabled=false]\n * Whether or not the feature is enabled.\n * @property {Array} [items=[]]\n * A list of files and/or directories that will be copied. All with paths relative to the project\n * directory.\n * @property {ProjectConfigurationFeatureTriggerSettings} [copyOnBuild]\n * Since the feature is also available through the projext CLI, you can configure how the feature\n * behaves when building.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationVersionRevisionSettings\n * @property {boolean} [enabled=false]\n * Whether or not the revision file feature is enabled.\n * @property {boolean} [copy=true]\n * Whether or not to copy the revision file when the project files are being copied to the\n * distribution directory.\n * @property {string} [filename='revision']\n * The name of the revision file.\n * @property {ProjectConfigurationFeatureTriggerSettings} [createRevisionOnBuild]\n * Since the feature is also available through the projext CLI, you can configure how the feature\n * behaves when building.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationVersionSettings\n * @property {string} [defineOn='process.env.VERSION']\n * The name of the variable where the version is going to be replaced on your code when bundled.\n * @property {string} [environmentVariable='VERSION']\n * The name of the environment variable projext should check to get the project version.\n * @property {ProjectConfigurationVersionRevisionSettings} [revision]\n * This is like a sub-feature. A revision file is a file that contains the version of your project.\n * This is useful when deploying the project to an environment where you have no access to the\n * environment variable.\n *\n * The way the revision file works is by first checking if the environment variable is available\n * and, if not, it will check if the project is on a `GIT` repository and try to get the hash of\n * the last commit.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationTargetFinderSettings\n * @property {boolean} [enabled=true]\n * Whether or not to automatically search for targets on the project folders.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationWatchSettings\n * @property {boolean} [poll=true]\n * Whether or not to use polling to get the changes on the file system, and if so, it can also be\n * used to specify the ms interval.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationNodemonSettings\n * @property {boolean} [legacyWatch=true]\n * Whether or not to enable `nodemon` legacy watch mode.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationOtherSettings\n * @property {ProjectConfigurationTargetFinderSettings}\n * These are the settings for projext _\"targets finder\"_, the feature that reads the project in\n * order to identify targets and their settings.\n * @property {ProjectConfigurationWatchSettings}\n * This is used by projext to configure `watchpack`, which is used to watch Node files that need to\n * be transpiled.\n * @property {ProjectConfigurationNodemonSettings}\n * This is used by projext to configure `nodemon`, which is used to execute and watch Node targets.\n */\n\n/**\n * @typedef {Object} ProjectConfigurationSettings\n * @property {ProjectConfigurationPathSettings} [paths]\n * This setting is all about where your code is located and where it will be bundled\n * @property {ProjectConfigurationTargetTemplates} [targetsTemplates]\n * There was no way to have _\"smart defaults\"_ for targets and at the same time allow projext\n * an unlimited amount of targets, and that's why the this setting exists.\n * The targets will extend the template which name is the same as their `type` property.\n * @property {Object} targets\n * This will be a dictionary with the {@link Target} definitions.\n * @property {ProjectConfigurationCopyFeatureSettings} [copy]\n * These settings are for the feature that enables projext to copy files when building targets.\n * @property {ProjectConfigurationVersionSettings} [version]\n * These settings are for the feature that manages your project version.\n * @property {ProjectConfigurationOtherSettings} [others]\n * Miscellaneous options.\n */\n\n/**\n * ================================================================================================\n * Targets and other target related types\n * ================================================================================================\n */\n\n/**\n * @typedef {BrowserTarget|NodeTarget} Target\n */\n\n/**\n * @typedef {function} TargetConfigurationCreator\n * @param {string} overwritePath\n * The path to the file that can create the configuration.\n * @param {ConfigurationFile} baseConfiguration\n * The configuration service that will be extended.\n * @return {ConfigurationFile}\n */\n\n/**\n * @typedef {Object} TargetDefaultHTMLSettings\n * @property {string} title The value of the `<title />` tag.\n * @property {string} bodyAttributes Extra attributes for the `<body />` tag.\n * @property {string} bodyContents The content of the `<body />` tag.\n */\n\n/**\n * @typedef {Object} TargetFileRulePathSettings\n * @property {Array} include The list of expressions that match the allowed paths for a rule.\n * @property {Array} exclude The list of expressions that match the paths that should be excluded\n *                           from a rule.\n */\n\n/**\n * @typedef {Object} TargetFileRuleGlobFilesSettings\n * @property {Array} include The list of glob patterns that match the allowed files for a rule.\n * @property {Array} exclude The list of glob patterns that match the files that should be excluded\n *                           from a rule.\n */\n\n/**\n * @typedef {Object} TargetFileRuleFilesSettings\n * @property {Array}                           include The list of expressions that match the\n *                                                     allowed files for a rule.\n * @property {Array}                           exclude The list of expressions that match the\n *                                                     files that should be excluded from a rule.\n * @property {TargetFileRuleGlobFilesSettings} glob    The settings for files but on glob pattern\n *                                                     version. For plugins and libraries that\n *                                                     don't support, or maybe prefer glob over,\n *                                                     expressions.\n */\n\n/**\n * @typedef {Object} TargetFileRuleSettings\n * @property {RegExp}                      extension A expression that validates the extension(s)\n *                                                   the rule is for.\n * @property {string}                      glob      A glob pattern that validates the extension(s)\n *                                                   the rule is for.\n * @property {TargetFileRulePathSettings}  paths     A set of allowed and excluded expressions to\n *                                                   validate the paths where the files can be\n *                                                   found.\n * @property {TargetFileRuleFilesSettings} files     A set of allowed and excluded expressions and\n *                                                   glob patterns for files that would match with\n *                                                   the rule.\n */\n\n/**\n * @typedef {function} TargetFileRuleHandler\n * @param {Target}                 target      The target information.\n * @param {boolean}                hasTarget   Whether or not the rule already has a target, or if\n *                                             this is the first one being added.\n * @param {TargetFileRuleSettings} currentRule The current settings of the rule.\n */\n\n/**\n * @typedef {Object} TargetFontsFileRules\n * @property {TargetFileRule} common The rule for all font files that aren't SVG.\n * @property {TargetFileRule} svg    The rule for SVG fonts.\n */\n\n/**\n * @typedef {Object} TargetFilesRules\n * @property {TargetFileRule}       js      The rule for JS files.\n * @property {TargetFileRule}       scss    The rule for SCSS files.\n * @property {TargetFileRule}       css     The rule for CSS files.\n * @property {TargetFontsFileRules} fonts   The rules for font files.\n * @property {TargetFileRule}       images  The rule for image files.\n * @property {TargetFileRule}       favicon The rule for favicon files.\n */\n\n/**\n * @typedef {function} TargetExtraFileTransform\n * @param {Buffer} contents The original contents of the file.\n * @return {Promise<string,Error>} The updated contents.\n */\n\n/**\n * @typedef {Object} TargetExtraFile\n * @property {string}                    from      The file origin path.\n * @property {string}                    to        The file destination path.\n * @property {?TargetExtraFileTransform} transform A custom function to modify the contents of\n *                                                 the file to copy.\n */\n\n/**\n * @typedef {Object} NodeInspectorSettings\n * @property {boolean} enabled Whether or not to enable the Node inspector.\n * @property {string}  host    The host where the Node inspector will run.\n * @property {number}  port    The port where the Node inspector will run.\n * @property {string}  command The Node inspector flag command (`inspect` or `inspect-brk`).\n * @property {boolean} ndb     Whether or not to use Google's {@link ndb} instead of the native\n *                             inspector. The way it will be used will be by calling the\n *                             executable without path, so it's up to the project to install it\n *                             (global or local).\n */\n\n/**\n * @typedef {Object} TargetsFinderExtractInformation\n * @description This is generated by {@link TargetsFinder#_extractFromCode}, which recevies a\n *              block of code and a dictionary of regular expressions' lists:\n *              `{ listOne: [exp1, exp2], listTwo: [exp3, exp4]}`. So if there are any matches on\n *              the block of code, the returned boject will have `items`, the ones extracted by the\n *              expressions; and `from`, an array of names of the lists that have expressions that\n *              matched.\n * @property {Array} from  The names of the regular expressions' lists that found matches on the\n *                         code.\n * @property {Array} items The list of extractions.\n * @access protected\n * @ignore\n */\n\n/**\n * ================================================================================================\n * \"Interfaces\"\n * ================================================================================================\n */\n\n/**\n * @typedef {function} BuildEngineGetCommand\n * @param {Target} target\n * The target information.\n * @param {string} buildType\n * The intended build type: `development` or `production`.\n * @param {boolean} [forceRun=false]\n * Force the target to run even if the `runOnDevelopment` setting is `false`.\n * @param {boolean} [forceWatch=false]\n * Force the build engine to watch the target files even if the `watch` setting for the required\n * build type is set to `false`.\n * @param {boolean} [forceInspect=false]\n * Force the build engine to use the Node inspector even if the target setting is disabled. This\n * only applies for Node targets.\n * @return {string}\n * The command the shell script will use to build the target.\n */\n\n/**\n * @typedef {Object} BuildEngine\n * @property {BuildEngineGetCommand} getBuildCommand\n * The method used by projext in order to get the shell comands to build and/or run a target.\n */\n\n/**\n * ================================================================================================\n * Building\n * ================================================================================================\n */\n\n/**\n * @typedef {Object} CLIBuildCommandOptions\n * @property {string}  type    The intended build type: `development` or `production`.\n * @property {boolean} run     Whether or not the target needs to be executed.\n * @property {boolean} watch   Whether or not the target files will be watched.\n * @property {boolean} inspect Whether or not to enable the Node inspector.\n */\n\n/**\n * @typedef {Object} CLIBuildCommandNormalizedOptions\n * @property {boolean} development Whether or not the intended build type is `development`.\n * @property {boolean} run         Whether or not the target needs to be executed.\n * @property {boolean} watch       Whether or not the target files will be watched.\n * @property {boolean} inspect     Whether or not to enable the Node inspector.\n */\n\n/**\n * @typedef {Object} CLIBuildCommandParams\n * @property {Target}  target  The target information.\n * @property {string}  type    The intended build type: `development` or `production`.\n * @property {boolean} run     Whether or not the target needs to be executed.\n * @property {boolean} build   Whether or not a build will be created. This is always `true` for\n *                             browser targets but it may be false for Node targets if bundling and\n *                             transpiling is disabled.\n * @property {boolean} watch   Whether or not the target files will be watched.\n * @property {boolean} inspect Whether or not to enable the Node inspector.\n */\n\n/**\n * ================================================================================================\n * Others\n * ================================================================================================\n */\n\n/**\n * @typedef {function} ProviderRegisterMethod\n * @param {Projext} app\n * A reference to the projext dependency injection container.\n */\n\n/**\n * @typedef {Object} Provider\n * @property {ProviderRegisterMethod} register\n * The method that gets called by projext when registering the provider.\n */\n",
    "static": true,
    "longname": "/Users/homer0/CODE/node/projext/projext/src/typedef.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 795,
    "kind": "external",
    "name": "Jimple",
    "externalLink": "https://yarnpkg.com/en/package/jimple",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Jimple",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 796,
    "kind": "external",
    "name": "Nodemon",
    "externalLink": "https://github.com/remy/nodemon/blob/master/doc/requireable.md",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Nodemon",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 797,
    "kind": "external",
    "name": "Command",
    "externalLink": "https://tj.github.io/commander.js/#Command",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Command",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 798,
    "kind": "external",
    "name": "Watchpack",
    "externalLink": "https://yarnpkg.com/en/package/watchpack",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Watchpack",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 799,
    "kind": "external",
    "name": "WatchpackOptions",
    "externalLink": "https://github.com/webpack/watchpack#api",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~WatchpackOptions",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 800,
    "kind": "external",
    "name": "AppConfiguration",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~AppConfiguration",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 801,
    "kind": "external",
    "name": "PathUtils",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/node/pathUtils.js~PathUtils.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~PathUtils",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 802,
    "kind": "external",
    "name": "Logger",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/node/logger.js~Logger.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Logger",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 803,
    "kind": "external",
    "name": "EnvironmentUtils",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/node/environmentUtils.js~EnvironmentUtils.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~EnvironmentUtils",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 804,
    "kind": "external",
    "name": "EventsHub",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/shared/eventsHub.js~EventsHub.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~EventsHub",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 805,
    "kind": "external",
    "name": "ErrorHandler",
    "externalLink": "https://homer0.github.io/wootils/class/wootils/node/errorHandler.js~ErrorHandler.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ErrorHandler",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 806,
    "kind": "external",
    "name": "RootRequire",
    "externalLink": "https://homer0.github.io/wootils/function/index.html#static-function-rootRequire",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~RootRequire",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 807,
    "kind": "external",
    "name": "Buffer",
    "externalLink": "https://nodejs.org/api/buffer.html",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Buffer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 808,
    "kind": "external",
    "name": "ndb",
    "externalLink": "https://github.com/GoogleChromeLabs/ndb",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ndb",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 809,
    "kind": "typedef",
    "name": "TargetTypeCheck",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetTypeCheck",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "Whether the target type is `node` or not."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "browser",
        "description": "Whether the target type is `browser` or not."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetTypeCheck"
    }
  },
  {
    "__docId__": 810,
    "kind": "typedef",
    "name": "TargetPaths",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetPaths",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The absolute path to the target source directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "build",
        "description": "The absolute path to the folder, inside the distribution directory, where the target will be\nbundled/copied."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetPaths"
    }
  },
  {
    "__docId__": 811,
    "kind": "typedef",
    "name": "TargetFolders",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFolders",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The relative path to the target source directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "build",
        "description": "The relative path to the folder, inside the distribution directory, where the target will be\nbundled/copied."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFolders"
    }
  },
  {
    "__docId__": 812,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateEntry",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateEntry",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'index.js'",
        "defaultRaw": "'index.js'",
        "name": "default",
        "description": "The target entry file for all types of build that don't have a specified entry."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "development",
        "description": "The target entry file on a development build. If `null`, it will fallback to the one specified\non `default`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "production",
        "description": "The target entry file on a production build. If `null`, it will fallback to the one specified\non `default`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateEntry"
    }
  },
  {
    "__docId__": 813,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateOutputPaths",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateOutputPaths",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "js",
        "description": "The path to generated Javascript files on the distribution directory.\n\nThe available placeholders are:\n- `[target-name]`: The name of the target.\n- `[hash]`: A random hash generated for cache busting.\n\nThe default value is:\n- For `node` targets, on all build types: `[target-name].js`.\n- For `browser` targets:\n  - `development`: `'statics/js/[target-name].js'`.\n  - `production`: `'statics/js/[target-name].[hash].js'`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "css",
        "description": "The path to generated stylesheets on the distribution directory.\n\nThe available placeholders are:\n- `[target-name]`: The name of the target.\n- `[hash]`: A random hash generated for cache busting.\n\nThe default value is, for both `node` and `browser` targets:\n- `development`: `'statics/styles/[target-name].css'`.\n- `production`: `'statics/styles/[target-name].[hash].css'`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "fonts",
        "description": "The path to font files once they are copied to the distribution directory.\n\nThe available placeholders are:\n- `[target-name]`: The name of the target.\n- `[name]`: The file original name.\n- `[ext]`: The file original extension.\n- `[hash]`: A random hash generated for cache busting.\n\nThe default value is, for both `node` and `browser` targets:\n- `development`: `'statics/fonts/[name]/[name][ext]'`.\n- `production`: `'statics/fonts/[name]/[name].[hash].[ext]'`."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "fonts",
        "description": "The path to image files once they are copied to the distribution directory.\n\nThe available placeholders are:\n- `[target-name]`: The name of the target.\n- `[name]`: The file original name.\n- `[ext]`: The file original extension.\n- `[hash]`: A random hash generated for cache busting.\n\nThe default value is, for both `node` and `browser` targets:\n- `development`: `'statics/images/[name][ext]'`.\n- `production`: `'statics/images/[name].[hash].[ext]'`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateOutputPaths"
    }
  },
  {
    "__docId__": 814,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateOutput",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateOutput",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutputPaths"
        ],
        "spread": false,
        "optional": true,
        "name": "default",
        "description": "The target output settings for all types of build that don't have specified settings."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutputPaths"
        ],
        "spread": false,
        "optional": true,
        "name": "development",
        "description": "The target output settings on a development build. If `null`, it will fallback to the ones\nspecified on `default`."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutputPaths"
        ],
        "spread": false,
        "optional": true,
        "name": "production",
        "description": "The target output settings on a production build. If `null`, it will fallback to the ones\nspecified on `default`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateOutput"
    }
  },
  {
    "__docId__": 815,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateCopyItem",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateCopyItem",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The path to the file, relative to the target source directory."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The path where the file will be copied, relative to the target\n                         distribution directory. If not specified, the file will be copied to\n                         the root of the target distribution directory."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateCopyItem"
    }
  },
  {
    "__docId__": 816,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetWatchOptions",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetWatchOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "development",
        "description": "Whether or not to watch the target files when it gets\n                                        build for development. If the target type is Node and it\n                                        doesn't require bundling nor transpiling, it won't do\n                                        anything."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "production",
        "description": "Whether or not to watch the target files when it gets\n                                        build for production."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetWatchOptions"
    }
  },
  {
    "__docId__": 817,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateBabelFeatures",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateBabelFeatures",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "classProperties",
        "description": "This enables `@babel/plugin-proposal-class-properties` so the targets can use classes with\nproperties."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "decorators",
        "description": "This enables `@babel/plugin-proposal-decorators` so the targets can use decorators (based on\nthe current TC39 proposal)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "dynamicImports",
        "description": "This enables `@babel/plugin-syntax-dynamic-import` so the targets can do dynamic imports and\ncode splitting."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "objectRestSpread",
        "description": "This enables `@babel/plugin-proposal-object-rest-spread` so the targets can use rest and spread\nwith objects."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateBabelFeatures"
    }
  },
  {
    "__docId__": 818,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplateSourceMapSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplateSourceMapSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "development",
        "description": "Whether or not to generate a source map on a development build."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "production",
        "description": "Whether or not to generate a source map on a production build."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplateSourceMapSettings"
    }
  },
  {
    "__docId__": 819,
    "kind": "typedef",
    "name": "ProjectConfigurationNodeTargetTemplateBabelSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodeTargetTemplateBabelSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateBabelFeatures"
        ],
        "spread": false,
        "optional": true,
        "name": "features",
        "description": "This object can be used to enable/disable the Babel plugins projext includes.\nIf you need other plugins, they can be included on the `overwrites` option."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'current'",
        "defaultRaw": "'current'",
        "name": "nodeVersion",
        "description": "When building the Babel configuration, projext uses the `@babel/preset-env` to just include the\nnecessary stuff. This setting tells the preset the version of Node it should _\"complete\"_."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "env",
        "description": "Custom settings that projext will use as base when generating the ones for the\n`@babel/preset-env`."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "overwrites",
        "description": "If you know how to use Babel and need stuff that is not covered by projext, you can use this\nsetting to overwrite/add any value you may need."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodeTargetTemplateBabelSettings"
    }
  },
  {
    "__docId__": 820,
    "kind": "typedef",
    "name": "ProjectConfigurationNodeTargetTemplateLibraryOptions",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodeTargetTemplateLibraryOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'commonjs2'",
        "defaultRaw": "'commonjs2'",
        "name": "libraryTarget",
        "description": "How the library will be exposed: `commonjs2` or `umd`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodeTargetTemplateLibraryOptions"
    }
  },
  {
    "__docId__": 821,
    "kind": "typedef",
    "name": "ProjectConfigurationNodeTargetTemplateCSSSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodeTargetTemplateCSSSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "modules",
        "description": "Whether or not your application uses CSS Modules. If this is enabled, all your styles will be\nprefixed with a unique identifier."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodeTargetTemplateCSSSettings"
    }
  },
  {
    "__docId__": 822,
    "kind": "typedef",
    "name": "ProjectConfigurationNodeTargetInspectSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodeTargetInspectSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "enabled",
        "description": "Whether or not to enable the Node inspector when running\n                                        the app for development."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'0.0.0.0'",
        "defaultRaw": "'0.0.0.0'",
        "name": "host",
        "description": "The host where the Node inspector will run."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "9229",
        "defaultRaw": 9229,
        "name": "port",
        "description": "The port the Node inspector will use."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'inspect'",
        "defaultRaw": "'inspect'",
        "name": "command",
        "description": "The Node inspector flag command (`inspect` or\n                                        `inspect-brk`)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "ndb",
        "description": "Whether or not to use Google's {@link ndb} instead of\n                                        the native inspector. The way it will be used will be\n                                        by calling the executable without path, so it's up to\n                                        the project to install it (global or local)."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodeTargetInspectSettings"
    }
  },
  {
    "__docId__": 823,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateHTMLSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateHTMLSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'index.html'",
        "defaultRaw": "'index.html'",
        "name": "default",
        "description": "This setting can be used to set the same value of default `template` and `filename` at once. But\nit will only overwrite settings with a `null` value, if one is specified, the value of this\nsetting will be ignored."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "template",
        "description": "The file inside your target source that will be used to generate the `html`. If `null`, it will\nfallback to the value of the `default` setting."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "filename",
        "description": "The file that will be generated when your target is bundled. It will automatically include\nthe `<script />` tag to the generated bundle. If `null`, it will fallback to the value of the\n`default` setting."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateHTMLSettings"
    }
  },
  {
    "__docId__": 824,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateCSSSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateCSSSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "modules",
        "description": "Whether or not your application uses CSS Modules. If this is enabled, all your styles will be\nprefixed with a unique identifier."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "inject",
        "description": "If this setting is set to `true`, instead of generating a CSS file with your styles, they'll be\ndynamically injected on HTML when the bundle gets executed."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateCSSSettings"
    }
  },
  {
    "__docId__": 825,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateBabelSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateBabelSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateBabelFeatures"
        ],
        "spread": false,
        "optional": true,
        "name": "features",
        "description": "This object can be used to enable/disable the Babel plugins projext includes.\nIf you need other plugins, they can be included on the `overwrites` option."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2",
        "defaultRaw": 2,
        "name": "browserVersions",
        "description": "When building the Babel configuration, projext uses the `@babel/preset-env` to just include the\nnecessary stuff. This setting tells how many old versions of the major browsers the target needs\ntranspilation for.\nMajor browsers: Firefox, Chrome, Safari and Edge."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "mobileSupport",
        "description": "If `true`, the configuration will add to the list of major browsers `iOS` and `Android`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "polyfill",
        "description": "Whether or not the configuration for the `@babel/preset-env` should include the settings for\nfor `useBuiltIns` and `corejs`."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "overwrites",
        "description": "If you know how to use Babel and need stuff that is not covered by projext, you can use this\nsetting to overwrite/add any value you may need."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "env",
        "description": "Custom settings that projext will use as base when generating the ones for the\n`@babel/preset-env`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateBabelSettings"
    }
  },
  {
    "__docId__": 826,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "key",
        "description": "The path to the SSL key (`.key`)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "cert",
        "description": "The path to the SSL certificate (`.crt`)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "ca",
        "description": "The path to the SSL public file (`.pem`)."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings"
    }
  },
  {
    "__docId__": 827,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "enabled",
        "description": "Whether or not the dev server is being proxied."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "host",
        "description": "The host used to proxy the dev server. If `null`, it will use the host defined on the dev server\nmain settings."
      },
      {
        "nullable": true,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "https",
        "description": "Whether or not the proxied host uses `https`. If `null` and you have provided SSL certificates\nfor the server, it will become `true`, otherwise it will be `false`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings"
    }
  },
  {
    "__docId__": 828,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateDevServerSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateDevServerSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2509",
        "defaultRaw": 2509,
        "name": "port",
        "description": "The server port."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "reload",
        "description": "Whether or not to reload the browser when the code changes."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "open",
        "description": "Whether or not to open the browser when server is ready."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'localhost'",
        "defaultRaw": "'localhost'",
        "name": "host",
        "description": "The dev server hostname."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateDevServerSSLSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "ssl",
        "description": "The paths to the files to enable SSL on the dev server."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateDevServerProxiedSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "proxied",
        "description": "When the dev server is being proxied (using `nginx` for example), there are certain\nfunctionalities, like hot module replacement and live reload that need to be aware of this."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateDevServerSettings"
    }
  },
  {
    "__docId__": 829,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateConfigurationSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateConfigurationSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "enabled",
        "description": "Whether or not the feature is enabled."
      },
      {
        "nullable": null,
        "types": [
          "null",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "default",
        "description": "The default configuration. If none is specified, when the target is builded, it will try to\nuse `[target-name].config.js`, located on the configuration folder."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'config/'",
        "defaultRaw": "'config/'",
        "name": "path",
        "description": "The path where the configuration files are located."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "hasFolder",
        "description": "Whether or not there's a folder with the target name on the configuration path."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'process.env.CONFIG'",
        "defaultRaw": "'process.env.CONFIG'",
        "name": "defineOn",
        "description": "The name of the variable where the configuration is going to be replaced on your code when\nbundled."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'CONFIG'",
        "defaultRaw": "'CONFIG'",
        "name": "environmentVariable",
        "description": "The name of the environment variable projext will check when building the target in order to\nload a dynamic configuration."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "loadFromEnvironment",
        "description": "Whether or not projext should check for the environment variable value."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'[target-name].[configuration-name].config.js'",
        "defaultRaw": "'[target-name].[configuration-name].config.js'",
        "name": "filenameFormat",
        "description": "The name format of the configuration files."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateConfigurationSettings"
    }
  },
  {
    "__docId__": 830,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplateLibraryOptions",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplateLibraryOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'umd'",
        "defaultRaw": "'umd'",
        "name": "libraryTarget",
        "description": "How the library will be exposed: `commonjs2`, `umd` or `window`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "compress",
        "description": "Whether or not to use gzip compression on the generated library file."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplateLibraryOptions"
    }
  },
  {
    "__docId__": 831,
    "kind": "typedef",
    "name": "ProjectConfigurationNodeTargetTemplate",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodeTargetTemplate",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "bundle",
        "description": "Whether or not the target needs to be bundled.\nIf the value is `false`, when running on a development environment, and if the target doesn't\nneed transpilation, the code won't be moved to the distribution directory."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "transpile",
        "description": "This option is kind of tied to the previous one: You may not want to bundle your Node target,\nbut you can transpile it with [Babel](https://babeljs.io) if you want to use a feature not yet\nsupported by the runtime."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'webpack'",
        "defaultRaw": "'webpack'",
        "name": "engine",
        "description": "In case `bundle` is `true`, this will tell projext which build engine you are going to bundle\nthe target code with."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "hasFolder",
        "description": "Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\nthe contents of the source directory are your target code (useful when working with a single\ntarget)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "createFolder",
        "description": "Whether or not to create a folder for your targets code on the distribution directory when the\ntarget is bundled/copied."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "folder",
        "description": "If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\nfolder name than the target's name."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateEntry"
        ],
        "spread": false,
        "optional": true,
        "name": "entry",
        "description": "The target entry files for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": true,
        "name": "output",
        "description": "The target output settings for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateSourceMapSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "sourceMap",
        "description": "The target source map settings for each specific environment build."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetInspectSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "inspect",
        "description": "The target settings for the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateCSSSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "css",
        "description": "These options help you customize the way the bundling process handles your CSS code."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "includeModules",
        "description": "This setting can be used to specify a list of node modules you want to process on your bundle."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "excludeModules",
        "description": "This setting can be used to specify a list of modules that should never be bundled. By default,\nprojext will exclude all the dependencies from the `package.json`, but if you import modules\nusing a sub path (like `colors/safe` instead of `colors`), you need to specify it on this list\nso the build engine won't try to put it inside the bundle it."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "includeTargets",
        "description": "This setting can be used to specify a list of other targets you want to process on your bundle.\nThis means that JS and SCSS files from these targets will be transpiled/processed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "runOnDevelopment",
        "description": "This tells projext that when the target is builded (bundled/copied) on a development\nenvironment, it should execute it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetWatchOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "watch",
        "description": "The settings for the projext watch mode, which watches the target files for changes and updates\nthe build without executing it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateBabelSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "babel",
        "description": "The target transpilation options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "flow",
        "description": "Whether or not your target uses [flow](https://flow.org/). This will update the Babel"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "typeScript",
        "description": "Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\nconfiguration in order to add support and, in case it was disabled, enable transpilation."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "library",
        "description": "If the project is bundled, this will tell the build engine that it needs to be builded as a\nlibrary to be `require`d."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateLibraryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "libraryOptions",
        "description": "In case `library` is `true`, these options are going to be used by the build engine to configure\nyour library"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "cleanBeforeBuild",
        "description": "Whether or not to remove all code from previous builds from the distribution directory when\nmaking a new build."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "copy",
        "description": "A list of files to copy during the bundling process. It can be a list of file paths relative to\nthe target source directory, in which case they'll be copied to the target distribution\ndirectory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateDotEnvSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "dotEnv",
        "description": "These options are used by both projext and the build engine in order to load \"environment\nfiles\"."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodeTargetTemplate"
    }
  },
  {
    "__docId__": 832,
    "kind": "typedef",
    "name": "NodeTarget",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~NodeTarget",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "bundle",
        "description": "Whether or not the target needs to be bundled.\nIf the value is `false`, when running on a development environment, and if the target doesn't\nneed transpilation, the code won't be moved to the distribution directory."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "transpile",
        "description": "This option is kind of tied to the previous one: You may not want to bundle your Node target,\nbut you can transpile it with [Babel](https://babeljs.io) if you want to use a feature not yet\nsupported by the runtime."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "In case `bundle` is `true`, this will tell projext which build engine you are going to bundle\nthe target code with."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasFolder",
        "description": "Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\nthe contents of the source directory are your target code (useful when working with a single\ntarget)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "createFolder",
        "description": "Whether or not to create a folder for your targets code on the distribution directory when the\ntarget is bundled/copied."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "folder",
        "description": "If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\nfolder name than the target's name."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateEntry"
        ],
        "spread": false,
        "optional": false,
        "name": "entry",
        "description": "The target entry files for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "The target output settings for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": false,
        "name": "originalOutput",
        "description": "The target output settings for each specific build type, without the placeholders replaced."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateSourceMapSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceMap",
        "description": "The target source map settings for each specific environment build."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetInspectSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "inspect",
        "description": "The target settings for the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateCSSSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "css",
        "description": "These options help you customize the way the bundling process handles your CSS code."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "includeModules",
        "description": "This setting can be used to specify a list of node modules you want to process on your bundle.\nThis means that JS files from modules on this list will be transpiled."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "excludeModules",
        "description": "This setting can be used to specify a list of modules that should never be bundled. By default,\nprojext will exclude all the dependencies from the `package.json`, but if you import modules\nusing a sub path (like `colors/safe` instead of `colors`), you need to specify it on this list\nso the build engine won't try to put it inside the bundle it."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "includeTargets",
        "description": "This setting can be used to specify a list of other targets you want to process on your bundle.\nThis means that JS and SCSS files from these targets will be transpiled/processed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "runOnDevelopment",
        "description": "This tells projext that when the target is builded (bundled/copied) on a development\nenvironment, it should execute it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetWatchOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "The settings for the projext watch mode, which watches the target files for changes and updates\nthe build without executing it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateBabelSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "babel",
        "description": "The target transpilation options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "flow",
        "description": "Whether or not your target uses [flow](https://flow.org/). This will update the Babel\nconfiguration in order to add support and, in case it was disabled, enable transpilation."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "typeScript",
        "description": "Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\nconfiguration in order to add support and, in case it was disabled, enable transpilation."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "library",
        "description": "If the project is bundled, this will tell the build engine that it needs to be builded as a\nlibrary to be `require`d."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplateLibraryOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryOptions",
        "description": "In case `library` is `true`, these options are going to be used by the build engine to configure\nyour library"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cleanBeforeBuild",
        "description": "Whether or not to remove all code from previous builds from the distribution directory when\nmaking a new build."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "copy",
        "description": "A list of files to copy during the bundling process. It can be a list of file paths relative to\nthe target source directory, in which case they'll be copied to the target distribution\ndirectory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}."
      },
      {
        "nullable": null,
        "types": [
          "TargetTypeCheck"
        ],
        "spread": false,
        "optional": false,
        "name": "is",
        "description": "To check whether the target type is `node` or `browser`"
      },
      {
        "nullable": null,
        "types": [
          "TargetPaths"
        ],
        "spread": false,
        "optional": false,
        "name": "paths",
        "description": "The target absolute paths to both the source directory folder and the distribution directory\nfolder."
      },
      {
        "nullable": null,
        "types": [
          "TargetFolders"
        ],
        "spread": false,
        "optional": false,
        "name": "folders",
        "description": "The target relative paths to both the source directory folder and the distribution directory\nfolder."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateDotEnvSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "dotEnv",
        "description": "These options are used by both projext and the build engine in order to load \"environment\nfiles\"."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "NodeTarget"
    }
  },
  {
    "__docId__": 833,
    "kind": "typedef",
    "name": "ProjectConfigurationBrowserTargetTemplate",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationBrowserTargetTemplate",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'webpack'",
        "defaultRaw": "'webpack'",
        "name": "engine",
        "description": "This will tell projext which build engine you are going to bundle the target code with."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "hasFolder",
        "description": "Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\nthe contents of the source directory are your target code (useful when working with a single\ntarget)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "createFolder",
        "description": "Whether or not to create a folder for your targets code on the distribution directory when the\ntarget is bundled/copied."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "folder",
        "description": "If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\nfolder name than the target's name."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateEntry"
        ],
        "spread": false,
        "optional": true,
        "name": "entry",
        "description": "The target entry files for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": true,
        "name": "output",
        "description": "The target output settings for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateSourceMapSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "sourceMap",
        "description": "The target source map settings for each specific environment build."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateHTMLSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "html",
        "description": "In the case the target is an app, these are the options for the `html` file that will include\nthe bundle `<script />`; and if your target is a library, this can be used to test your library."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateCSSSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "css",
        "description": "These options help you customize the way the bundling process handles your CSS code."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "includeModules",
        "description": "This setting can be used to specify a list of node modules you want to process on your bundle.\nThis means that JS files from modules on this list will be transpiled."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "includeTargets",
        "description": "This setting can be used to specify a list of other targets you want to process on your bundle.\nThis means that JS and SCSS files from these targets will be transpiled/processed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "uglifyOnProduction",
        "description": "When a bundle is created, this setting will tell the build engine whether to uglify the code\nfor production or not."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "runOnDevelopment",
        "description": "This will tell the build engine that when you build the target for a development environment,\nit should bring up an `http` server to _\"run\"_ your target."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetWatchOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "watch",
        "description": "The settings for the projext watch mode, which watches the target files for changes and updates\nthe build without executing it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateBabelSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "babel",
        "description": "These options are used by the build engine to configure [Babel](https://babeljs.io):"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "flow",
        "description": "Whether or not your target uses [flow](https://flow.org/). This will update the Babel\nconfiguration in order to add support for it."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "typeScript",
        "description": "Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\nconfiguration in order to add support for it."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "library",
        "description": "This will tell the build engine that it needs to be builded as a library to be `require`d."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateLibraryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "libraryOptions",
        "description": "In case `library` is `true`, these options are going to be used by the build engine to configure\nyour library."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "cleanBeforeBuild",
        "description": "Whether or not to remove all code from previous builds from the distribution directory when\nmaking a new build."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "copy",
        "description": "A list of files to copy during the bundling process. It can be a list of file paths relative to\nthe target source directory, in which case they'll be copied to the target distribution\ndirectory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateDotEnvSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "dotEnv",
        "description": "These options are used by both projext and the build engine in order to load \"environment\nfiles\"."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateDevServerSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "devServer",
        "description": "These are the options for the `http` server projext will use when running the target on a\ndevelopment environment."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateConfigurationSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "configuration",
        "description": "These are the settings for the feature that allows a browser target to have a dynamic\nconfiguration file."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationBrowserTargetTemplate"
    }
  },
  {
    "__docId__": 834,
    "kind": "typedef",
    "name": "BrowserTarget",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~BrowserTarget",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "This will tell projext which build engine you are going to bundle the target code with."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasFolder",
        "description": "Whether your target code is on a sub folder of the source directory (`src/[target-name]/`) or\nthe contents of the source directory are your target code (useful when working with a single\ntarget)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "createFolder",
        "description": "Whether or not to create a folder for your targets code on the distribution directory when the\ntarget is bundled/copied."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "folder",
        "description": "If either `hasFolder` or `createFolder` is `true`, this can be used to specify a different\nfolder name than the target's name."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateEntry"
        ],
        "spread": false,
        "optional": false,
        "name": "entry",
        "description": "The target entry files for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "The target output settings for each specific build type."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateOutput"
        ],
        "spread": false,
        "optional": false,
        "name": "originalOutput",
        "description": "The target output settings for each specific build type, without the placeholders replaced."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateSourceMapSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceMap",
        "description": "The target source map settings for each specific environment build."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateHTMLSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "html",
        "description": "In the case the target is an app, these are the options for the `html` file that will include\nthe bundle `<script />`; and if your target is a library, this can be used to test your library."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateCSSSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "css",
        "description": "These options help you customize the way the bundling process handles your CSS code."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "includeModules",
        "description": "This setting can be used to specify a list of node modules you want to process on your bundle.\nThis means that JS files from modules on this list will be transpiled."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "includeTargets",
        "description": "This setting can be used to specify a list of other targets you want to process on your bundle.\nThis means that JS and SCSS files from these targets will be transpiled/processed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "uglifyOnProduction",
        "description": "When a bundle is created, this setting will tell the build engine whether to uglify the code\nfor production or not."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "runOnDevelopment",
        "description": "This will tell the build engine that when you build the target for a development environment,\nit should bring up an `http` server to _\"run\"_ your target."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetWatchOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "The settings for the projext watch mode, which watches the target files for changes and updates\nthe build without executing it."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateBabelSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "babel",
        "description": "These options are used by the build engine to configure [Babel](https://babeljs.io):"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "flow",
        "description": "Whether or not your target uses [flow](https://flow.org/). This will update the Babel\nconfiguration in order to add support for it."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "typeScript",
        "description": "Whether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel\nconfiguration in order to add support for it."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "library",
        "description": "This will tell the build engine that it needs to be builded as a library to be `require`d."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateLibraryOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "libraryOptions",
        "description": "In case `library` is `true`, these options are going to be used by the build engine to configure\nyour library."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cleanBeforeBuild",
        "description": "Whether or not to remove all code from previous builds from the distribution directory when\nmaking a new build."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "copy",
        "description": "A list of files to copy during the bundling process. It can be a list of file paths relative to\nthe target source directory, in which case they'll be copied to the target distribution\ndirectory root; or a list of {@link ProjectConfigurationTargetTemplateCopyItem}."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplateDotEnvSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "dotEnv",
        "description": "These options are used by both projext and the build engine in order to load \"environment\nfiles\"."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateDevServerSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "devServer",
        "description": "These are the options for the `http` server projext will use when running the target on a\ndevelopment environment."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplateConfigurationSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "configuration",
        "description": "These are the settings for the feature that allows a browser target to have a dynamic\nconfiguration file."
      },
      {
        "nullable": null,
        "types": [
          "TargetTypeCheck"
        ],
        "spread": false,
        "optional": false,
        "name": "is",
        "description": "To check whether the target type is `node` or `browser`"
      },
      {
        "nullable": null,
        "types": [
          "TargetPaths"
        ],
        "spread": false,
        "optional": false,
        "name": "paths",
        "description": "The target absolute paths to both the source directory folder and the distribution directory\nfolder."
      },
      {
        "nullable": null,
        "types": [
          "TargetFolders"
        ],
        "spread": false,
        "optional": false,
        "name": "folders",
        "description": "The target relative paths to both the source directory folder and the distribution directory\nfolder."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "BrowserTarget"
    }
  },
  {
    "__docId__": 835,
    "kind": "typedef",
    "name": "ProjectConfigurationPathSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationPathSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'src'",
        "defaultRaw": "'src'",
        "name": "source",
        "description": "The directory, relative to your project path, where your targets code is located. On the\ndocumentation is often referred as the _\"source directory\"_."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'dist'",
        "defaultRaw": "'dist'",
        "name": "build",
        "description": "The directory, relative to your project path, where your targets bundled code will be located.\nOn the documentation is often referred as the _\"distribution directory\"_."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'private'",
        "defaultRaw": "'private'",
        "name": "privateModules",
        "description": "This is for the feature that copies when bundling. In case you are using the feature to copy an\nnpm module that, let's say, is not published, projext will save that module (without its\ndependencies) on that folder."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationPathSettings"
    }
  },
  {
    "__docId__": 836,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetTemplates",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetTemplates",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodeTargetTemplate"
        ],
        "spread": false,
        "optional": true,
        "name": "node",
        "description": "The template settings for all targets with the type `node`."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationBrowserTargetTemplate"
        ],
        "spread": false,
        "optional": true,
        "name": "browser",
        "description": "The template settings for all targets with the type `browser`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetTemplates"
    }
  },
  {
    "__docId__": 837,
    "kind": "typedef",
    "name": "ProjectConfigurationFeatureTriggerSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationFeatureTriggerSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "enabled",
        "description": "Whether or not the feature should be triggered when a target is being build."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "onlyOnProduction",
        "description": "This tells projext if the feature should be triggered only when building for production, or if\nit should do it for development too."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "targets",
        "description": "This can be used to specify the targets that will trigger the feature when builded. If no target\nis specified, the feature will be triggered by all the targets."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationFeatureTriggerSettings"
    }
  },
  {
    "__docId__": 838,
    "kind": "typedef",
    "name": "ProjectConfigurationCopyFeatureSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationCopyFeatureSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "enabled",
        "description": "Whether or not the feature is enabled."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "items",
        "description": "A list of files and/or directories that will be copied. All with paths relative to the project\ndirectory."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationFeatureTriggerSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "copyOnBuild",
        "description": "Since the feature is also available through the projext CLI, you can configure how the feature\nbehaves when building."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationCopyFeatureSettings"
    }
  },
  {
    "__docId__": 839,
    "kind": "typedef",
    "name": "ProjectConfigurationVersionRevisionSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationVersionRevisionSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "enabled",
        "description": "Whether or not the revision file feature is enabled."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "copy",
        "description": "Whether or not to copy the revision file when the project files are being copied to the\ndistribution directory."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'revision'",
        "defaultRaw": "'revision'",
        "name": "filename",
        "description": "The name of the revision file."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationFeatureTriggerSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "createRevisionOnBuild",
        "description": "Since the feature is also available through the projext CLI, you can configure how the feature\nbehaves when building."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationVersionRevisionSettings"
    }
  },
  {
    "__docId__": 840,
    "kind": "typedef",
    "name": "ProjectConfigurationVersionSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationVersionSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'process.env.VERSION'",
        "defaultRaw": "'process.env.VERSION'",
        "name": "defineOn",
        "description": "The name of the variable where the version is going to be replaced on your code when bundled."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'VERSION'",
        "defaultRaw": "'VERSION'",
        "name": "environmentVariable",
        "description": "The name of the environment variable projext should check to get the project version."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationVersionRevisionSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "revision",
        "description": "This is like a sub-feature. A revision file is a file that contains the version of your project.\nThis is useful when deploying the project to an environment where you have no access to the\nenvironment variable.\n\nThe way the revision file works is by first checking if the environment variable is available\nand, if not, it will check if the project is on a `GIT` repository and try to get the hash of\nthe last commit."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationVersionSettings"
    }
  },
  {
    "__docId__": 841,
    "kind": "typedef",
    "name": "ProjectConfigurationTargetFinderSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationTargetFinderSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "enabled",
        "description": "Whether or not to automatically search for targets on the project folders."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationTargetFinderSettings"
    }
  },
  {
    "__docId__": 842,
    "kind": "typedef",
    "name": "ProjectConfigurationWatchSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationWatchSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "poll",
        "description": "Whether or not to use polling to get the changes on the file system, and if so, it can also be\nused to specify the ms interval."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationWatchSettings"
    }
  },
  {
    "__docId__": 843,
    "kind": "typedef",
    "name": "ProjectConfigurationNodemonSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationNodemonSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "legacyWatch",
        "description": "Whether or not to enable `nodemon` legacy watch mode."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationNodemonSettings"
    }
  },
  {
    "__docId__": 844,
    "kind": "typedef",
    "name": "ProjectConfigurationOtherSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationOtherSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetFinderSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "These",
        "description": "are the settings for projext _\"targets finder\"_, the feature that reads the project in\norder to identify targets and their settings."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationWatchSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "This",
        "description": "is used by projext to configure `watchpack`, which is used to watch Node files that need to\nbe transpiled."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationNodemonSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "This",
        "description": "is used by projext to configure `nodemon`, which is used to execute and watch Node targets."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationOtherSettings"
    }
  },
  {
    "__docId__": 845,
    "kind": "typedef",
    "name": "ProjectConfigurationSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProjectConfigurationSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationPathSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "paths",
        "description": "This setting is all about where your code is located and where it will be bundled"
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationTargetTemplates"
        ],
        "spread": false,
        "optional": true,
        "name": "targetsTemplates",
        "description": "There was no way to have _\"smart defaults\"_ for targets and at the same time allow projext\nan unlimited amount of targets, and that's why the this setting exists.\nThe targets will extend the template which name is the same as their `type` property."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "targets",
        "description": "This will be a dictionary with the {@link Target} definitions."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationCopyFeatureSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "copy",
        "description": "These settings are for the feature that enables projext to copy files when building targets."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationVersionSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "version",
        "description": "These settings are for the feature that manages your project version."
      },
      {
        "nullable": null,
        "types": [
          "ProjectConfigurationOtherSettings"
        ],
        "spread": false,
        "optional": true,
        "name": "others",
        "description": "Miscellaneous options."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ProjectConfigurationSettings"
    }
  },
  {
    "__docId__": 846,
    "kind": "typedef",
    "name": "Target",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Target",
    "access": "public",
    "description": "",
    "type": {
      "types": [
        "BrowserTarget",
        "NodeTarget"
      ],
      "optional": false,
      "name": "Target"
    }
  },
  {
    "__docId__": 847,
    "kind": "typedef",
    "name": "TargetConfigurationCreator",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetConfigurationCreator",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "overwritePath",
        "description": "The path to the file that can create the configuration."
      },
      {
        "nullable": null,
        "types": [
          "ConfigurationFile"
        ],
        "spread": false,
        "optional": false,
        "name": "baseConfiguration",
        "description": "The configuration service that will be extended."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ConfigurationFile"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "TargetConfigurationCreator"
    }
  },
  {
    "__docId__": 848,
    "kind": "typedef",
    "name": "TargetDefaultHTMLSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetDefaultHTMLSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "title",
        "description": "The value of the `<title />` tag."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bodyAttributes",
        "description": "Extra attributes for the `<body />` tag."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bodyContents",
        "description": "The content of the `<body />` tag."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetDefaultHTMLSettings"
    }
  },
  {
    "__docId__": 849,
    "kind": "typedef",
    "name": "TargetFileRulePathSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFileRulePathSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "include",
        "description": "The list of expressions that match the allowed paths for a rule."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "exclude",
        "description": "The list of expressions that match the paths that should be excluded\n                          from a rule."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFileRulePathSettings"
    }
  },
  {
    "__docId__": 850,
    "kind": "typedef",
    "name": "TargetFileRuleGlobFilesSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFileRuleGlobFilesSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "include",
        "description": "The list of glob patterns that match the allowed files for a rule."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "exclude",
        "description": "The list of glob patterns that match the files that should be excluded\n                          from a rule."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFileRuleGlobFilesSettings"
    }
  },
  {
    "__docId__": 851,
    "kind": "typedef",
    "name": "TargetFileRuleFilesSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFileRuleFilesSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "include",
        "description": "The list of expressions that match the\n                                                    allowed files for a rule."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "exclude",
        "description": "The list of expressions that match the\n                                                    files that should be excluded from a rule."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRuleGlobFilesSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "glob",
        "description": "The settings for files but on glob pattern\n                                                    version. For plugins and libraries that\n                                                    don't support, or maybe prefer glob over,\n                                                    expressions."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFileRuleFilesSettings"
    }
  },
  {
    "__docId__": 852,
    "kind": "typedef",
    "name": "TargetFileRuleSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFileRuleSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "extension",
        "description": "A expression that validates the extension(s)\n                                                  the rule is for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "glob",
        "description": "A glob pattern that validates the extension(s)\n                                                  the rule is for."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRulePathSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "paths",
        "description": "A set of allowed and excluded expressions to\n                                                  validate the paths where the files can be\n                                                  found."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRuleFilesSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "files",
        "description": "A set of allowed and excluded expressions and\n                                                  glob patterns for files that would match with\n                                                  the rule."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFileRuleSettings"
    }
  },
  {
    "__docId__": 853,
    "kind": "typedef",
    "name": "TargetFileRuleHandler",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFileRuleHandler",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasTarget",
        "description": "Whether or not the rule already has a target, or if\n                                            this is the first one being added."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRuleSettings"
        ],
        "spread": false,
        "optional": false,
        "name": "currentRule",
        "description": "The current settings of the rule."
      }
    ],
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "TargetFileRuleHandler"
    }
  },
  {
    "__docId__": 854,
    "kind": "typedef",
    "name": "TargetFontsFileRules",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFontsFileRules",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "common",
        "description": "The rule for all font files that aren't SVG."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "svg",
        "description": "The rule for SVG fonts."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFontsFileRules"
    }
  },
  {
    "__docId__": 855,
    "kind": "typedef",
    "name": "TargetFilesRules",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetFilesRules",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "js",
        "description": "The rule for JS files."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "scss",
        "description": "The rule for SCSS files."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "css",
        "description": "The rule for CSS files."
      },
      {
        "nullable": null,
        "types": [
          "TargetFontsFileRules"
        ],
        "spread": false,
        "optional": false,
        "name": "fonts",
        "description": "The rules for font files."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "images",
        "description": "The rule for image files."
      },
      {
        "nullable": null,
        "types": [
          "TargetFileRule"
        ],
        "spread": false,
        "optional": false,
        "name": "favicon",
        "description": "The rule for favicon files."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetFilesRules"
    }
  },
  {
    "__docId__": 856,
    "kind": "typedef",
    "name": "TargetExtraFileTransform",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetExtraFileTransform",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "The original contents of the file."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string,Error>"
      ],
      "spread": false,
      "description": "The updated contents."
    },
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "TargetExtraFileTransform"
    }
  },
  {
    "__docId__": 857,
    "kind": "typedef",
    "name": "TargetExtraFile",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetExtraFile",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The file origin path."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The file destination path."
      },
      {
        "nullable": true,
        "types": [
          "TargetExtraFileTransform"
        ],
        "spread": false,
        "optional": false,
        "name": "transform",
        "description": "A custom function to modify the contents of\n                                                the file to copy."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetExtraFile"
    }
  },
  {
    "__docId__": 858,
    "kind": "typedef",
    "name": "NodeInspectorSettings",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~NodeInspectorSettings",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "enabled",
        "description": "Whether or not to enable the Node inspector."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": "The host where the Node inspector will run."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "port",
        "description": "The port where the Node inspector will run."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "command",
        "description": "The Node inspector flag command (`inspect` or `inspect-brk`)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "ndb",
        "description": "Whether or not to use Google's {@link ndb} instead of the native\n                            inspector. The way it will be used will be by calling the\n                            executable without path, so it's up to the project to install it\n                            (global or local)."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "NodeInspectorSettings"
    }
  },
  {
    "__docId__": 859,
    "kind": "typedef",
    "name": "TargetsFinderExtractInformation",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~TargetsFinderExtractInformation",
    "access": "protected",
    "description": "",
    "ignore": true,
    "unknown": [
      {
        "tagName": "@description",
        "tagValue": "This is generated by {@link TargetsFinder#_extractFromCode}, which recevies a\n             block of code and a dictionary of regular expressions' lists:\n             `{ listOne: [exp1, exp2], listTwo: [exp3, exp4]}`. So if there are any matches on\n             the block of code, the returned boject will have `items`, the ones extracted by the\n             expressions; and `from`, an array of names of the lists that have expressions that\n             matched."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The names of the regular expressions' lists that found matches on the\n                        code."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "The list of extractions."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "TargetsFinderExtractInformation"
    }
  },
  {
    "__docId__": 860,
    "kind": "typedef",
    "name": "BuildEngineGetCommand",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~BuildEngineGetCommand",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "buildType",
        "description": "The intended build type: `development` or `production`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceRun",
        "description": "Force the target to run even if the `runOnDevelopment` setting is `false`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceWatch",
        "description": "Force the build engine to watch the target files even if the `watch` setting for the required\nbuild type is set to `false`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forceInspect",
        "description": "Force the build engine to use the Node inspector even if the target setting is disabled. This\nonly applies for Node targets."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The command the shell script will use to build the target."
    },
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "BuildEngineGetCommand"
    }
  },
  {
    "__docId__": 861,
    "kind": "typedef",
    "name": "BuildEngine",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~BuildEngine",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "BuildEngineGetCommand"
        ],
        "spread": false,
        "optional": false,
        "name": "getBuildCommand",
        "description": "The method used by projext in order to get the shell comands to build and/or run a target."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "BuildEngine"
    }
  },
  {
    "__docId__": 862,
    "kind": "typedef",
    "name": "CLIBuildCommandOptions",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~CLIBuildCommandOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The intended build type: `development` or `production`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "run",
        "description": "Whether or not the target needs to be executed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "Whether or not the target files will be watched."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "inspect",
        "description": "Whether or not to enable the Node inspector."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "CLIBuildCommandOptions"
    }
  },
  {
    "__docId__": 863,
    "kind": "typedef",
    "name": "CLIBuildCommandNormalizedOptions",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~CLIBuildCommandNormalizedOptions",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "development",
        "description": "Whether or not the intended build type is `development`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "run",
        "description": "Whether or not the target needs to be executed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "Whether or not the target files will be watched."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "inspect",
        "description": "Whether or not to enable the Node inspector."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "CLIBuildCommandNormalizedOptions"
    }
  },
  {
    "__docId__": 864,
    "kind": "typedef",
    "name": "CLIBuildCommandParams",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~CLIBuildCommandParams",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Target"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The target information."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The intended build type: `development` or `production`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "run",
        "description": "Whether or not the target needs to be executed."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "build",
        "description": "Whether or not a build will be created. This is always `true` for\n                            browser targets but it may be false for Node targets if bundling and\n                            transpiling is disabled."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "watch",
        "description": "Whether or not the target files will be watched."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "inspect",
        "description": "Whether or not to enable the Node inspector."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "CLIBuildCommandParams"
    }
  },
  {
    "__docId__": 865,
    "kind": "typedef",
    "name": "ProviderRegisterMethod",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~ProviderRegisterMethod",
    "access": "public",
    "description": "",
    "params": [
      {
        "nullable": null,
        "types": [
          "Projext"
        ],
        "spread": false,
        "optional": false,
        "name": "app",
        "description": "A reference to the projext dependency injection container."
      }
    ],
    "type": {
      "types": [
        "function"
      ],
      "optional": false,
      "name": "ProviderRegisterMethod"
    }
  },
  {
    "__docId__": 866,
    "kind": "typedef",
    "name": "Provider",
    "memberof": "src/typedef.js",
    "static": true,
    "longname": "src/typedef.js~Provider",
    "access": "public",
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "ProviderRegisterMethod"
        ],
        "spread": false,
        "optional": false,
        "name": "register",
        "description": "The method that gets called by projext when registering the provider."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Provider"
    }
  },
  {
    "kind": "index",
    "content": "# projext\n\n[![Travis](https://img.shields.io/travis/homer0/projext.svg?style=flat-square)](https://travis-ci.org/homer0/projext)\n[![Coveralls github](https://img.shields.io/coveralls/github/homer0/projext.svg?style=flat-square)](https://coveralls.io/github/homer0/projext?branch=master)\n[![David](https://img.shields.io/david/homer0/projext.svg?style=flat-square)](https://david-dm.org/homer0/projext)\n[![David](https://img.shields.io/david/dev/homer0/projext.svg?style=flat-square)](https://david-dm.org/homer0/projext)\n\nBundle and run your javascript project without configuring an specific module bundler.\n\n## Introduction\n\n### What?\n\nLet's start with this:\n\n- **projext is not** an alternative to [webpack](https://webpack.js.org/).\n- **projext is not** a module bundler.\n\nNow, this is a tool that allows you to configure a project bundling options on an _\"almost-human\"_ readable format so you don't have to deal with very complex rules and structures.\n\n> projext also has _\"zero configuration\"_ support so you can start coding right away. Read more about this on the [Zero Configuration document](manual/zeroConfiguration.html).\n\nThe idea is to divide your project bundling on a 4 layers architecture:\n\n| Layer                 |                                                                   |\n|-----------------------|-------------------------------------------------------------------|\n| Project configuration | Managed by projext                                                |\n| Bundler engine        | A projext plugin for Webpack/Rollup/Parcel/etc.                   |\n| Framework             | A projext plugin with the framework settings of the used bundler. |\n| Others...             | Other plugins like a runner tool or bundler analyzer.             |\n\n#### Quick example\n\nYou want to create an [AngularJS](https://angularjs.org/) app and you want to bundle it with webpack. You first need the following dependencies:\n\n- [`projext`](https://yarnpkg.com/en/package/projext)\n- [`projext-plugin-webpack`](https://yarnpkg.com/en/package/projext-plugin-webpack)\n- [`projext-plugin-webpack-angularjs`](https://yarnpkg.com/en/package/projext-plugin-webpack-angularjs)\n\nThen, if you want to use a configuration file, you would write something like this:\n\n```js\nmodule.exports = {\n  targets: {\n    browser: {\n      type: 'browser',\n      engine: 'webpack',\n      framework: 'angularjs',\n    },\n  },\n};\n```\n\nOr you can just create your `src/index.js` and start coding:\n\n```js\n// src/index.js\n\nimport angular from 'angular';\n...\n```\n\nprojext will look at your code and automatically assume a configuration like the one above.\n\n> There are a lot of _\"smart defaults\"_ on the project configuration, but since this we just want a quick example, we are going to modify just what we need.\n\nThat's all you need to do in terms of configuration, after that you can start coding your app.\n\n### Why?\n\nModule bundlers have been around for quite some time now and they are amazing tools, they allow us to do so much, from just putting the files together to transpiling, tree shaking, splitting for lazy load, etc.\n\nI've been bundling projects since [require.js](http://requirejs.org/) was popular, and since mid 2016 I've been using [webpack](https://webpack.js.org/) for almost everything. You can configure every detail, [Babel](https://babeljs.io/) integration, files optimization, [Express](https://expressjs.com) middlewares, etc; But after year and half, and more than 20 projects built with it... I'm sick and tired of writing the configuration.\n\nI even [wrote a plugin](https://github.com/homer0/webpack-node-utils/) to manage the configurations, but at the end of the day, I always ended up with huge configurations files, tons of rules and a lot of plugins/dependencies that needed to be up to date and comply with each other versions.\n\n> I'm well aware of the new features webpack 4 will bring to the table, including all the _\"smart defaults\"_, and it looks really promising. But I still believe **this tool is for a different purpose than just bundling**.\n\nAt some point I started considering start using [Rollup](https://rollupjs.org/), at least for the non web apps projects. Rollup was getting a lot of traction and since Facebook started adopting it, it got **really** popular.\n\nI tried it for a npm package project and the results were pretty impressive: It doesn't require a lot of configuration and there's not a lot of boiler plate code on the builds.\n\nI considered migrating a few older projects, but I didn't want to have to go over their configurations, so I just kept it for new projects.\n\nThen, a few months ago, [Parcel](https://parceljs.org/) showed up, and the community was all over it (I know, we are a very hype-driven community :P). And, of course, I wanted to use it, but at that point it was too much. That's when I finally understood the _\"Javascript Fatigue\"_.\n\nAnd at that point was when I had the first idea for this project: Preparing boiler plates for different bundlers for different scenarios: library, web page, web app, etc. Yes, it wasn't very original, but it was the start.\n\nAs you may have suspected, there were a few issues:\n\n- Hard to maintain: Different projects for the same tool that needed to be up-to-date.\n- What about the framework? Yes, frameworks are another big cause of the _\"Javascript Fatigue\"_, and they all have their unique configuration for specific bundlers.\n- I had to align every project to whatever the boiler plate needed in order to work.\n\nBut thanks to those problems was that I was able to come with a plan for this project:\n\n- Make a tool that would understand your project configuration on an _\"almost-human\"_ readable format, meaning, try to move almost every configuration to `boolean` or `string` value and no configuration functions.\n- Add another layer, on a form of plugin, that would take the project configuration and apply it to a bundler configuration.\n- And another layer/plugin that would be the framework implementation for that bundler.\n\nAnd then I built it. Right now it's only webpack as an bundler engine and AngularJS for webpack as framework, but I'm already building the Rollup engine, adding the [React](https://reactjs.org/) to webpack and planning on then making ports of both AngularJS and React.\n\nMy plan is to ask the community for help putting these plugins/recipes together.\n\n### Who?\n\nOf course there's no way this will be helpful for everyone: a tool that works as an abstraction of other tool could never cover all the possible scenarios.\n\nThis is aimed to those who use bundlers everyday to build web sites, libraries and apps without the need to go to the last optimal detail. If you need to do that, then use the bundler directly, it's the best choice.\n\n## Information\n\n| -            | -                                                                             |\n|--------------|-------------------------------------------------------------------------------|\n| Package      | projext                                                                       |\n| Description  | Bundle your Javascript projects without having to learn how to use a bundler. |\n| Node Version | >= v10.13.0                                                                    |\n\n## Usage\n\n### Zero configuration\n\nAfter installing projext and the necessary dependencies for bundling (and framework possibly), you can start coding by just creating a `src/index.js` file on your project.\n\nWhen you run the CLI commands, projext will automatically find your file, it will check its contents and try to determine if you are writing a browser or a Node app based on the modules and syntax you are using.\n\n[Read more about projext Zero Configuration](manual/zeroConfiguration.html)\n\n\n### Project configuration\n\nIn case you need to overwrite targets settings or enable other projext features, you can create a project configuration file called  `projext.config.js`.\n\n> The project configuration file can be located on the following paths:\n>\n> - `projext.config.js`\n> - `config/projext.config.js`\n> - `config/project.config.js`\n>\n> projext will evaluate the list of paths and use the first one it finds.\n\nThe file needs to export a single object that projext will use to merge on top of the _\"smart defaults\"_.\n\nFor example, you want to enable the feature that executes a target when bundled on development:\n\n```js\nmodule.exports = {\n  targets: {\n    myTarget: {\n      runOnDevelopment: true,\n    },\n  },\n};\n```\n\n[Read more about the project configuration](manual/projectConfiguration.html).\n\n### Bundling the code\n\nFor this example, we are going to assume this is what your targets look like:\n\n```js\nmodule.exports = {\n  targets: {\n    backend: {\n      type: 'node',\n    },\n    frontend: {\n      type: 'browser',\n    },\n  },\n};\n```\n\nThe way you bundle your targets is by using the `build` command from the projext CLI:\n\n> You can use scripts from the `package.json`, `$(npm bin)/` or `npx` too, but for these examples I'll be using `yarn`\n\n```bash\nyarn projext build backend\n# or\nyarn projext build frontend\n```\n\nReally simple right? For the `frontend` target, it will take all the source, bundle it and move it to the distribution directory (`dist/` by default, but again, configurable).\n\nFor the `backend` target it will give you a warning (not cool, I know), because the default build type is for a development environment and we didn't specify that the target needed to be bundled nor that it needed transpilation, so projext doesn't see the need to move it.\n\n> By default, projext doesn't bundle nor transpile Node targets code, but you can enable it by changing the `bundle` and/or `transpile` target settings. More about this after the following example.\n\nNow, time to build for production:\n\n```bash\nyarn projext build backend --type production\n# or\nyarn projext build frontend --type production\n```\n\nDone, the `--type` argument set to `production` tells projext that you are preparing a build production, so it will move everything to the distribution directory.\n\n[Read more about projext CLI](manual/cli.html)\n\n### projext and Node apps\n\nBy default, projext doesn't bundle nor transpile Node targets code (yes, it sounds ironic) as there's not a lot of advantages on doing it and the support for ES+ syntaxs on Node is pretty great.\n\nWhen you try to bundle a Node target for development, if you didn't change the settings, you'll get a warning that says that there's no need for it; but if you do it for production, the code will be copied to the distribution directory as you may want to deploy it.\n\nNow, Node targets have two special settings: `bundle` and `transpile`. With `bundle` you can specify whether you want to bundle the entire code on a single file or not; and with `transpile` you can tell projext to just transpile the files content using Babel but keeping all the files.\n\n## Other features\n\n### Running the targets\n\nIt's not all about putting all the files together. You can also use projext to run your targets while you code.\n\nFor `node` targets, it has a custom implementation of [`nodemon`](https://yarnpkg.com/en/package/nodemon) that will take care of watching and, if needed, transpiling your files while you code.\n\nFor `browser` targets it uses the bundle engine to run it so it can update your bundle on any change.\n\n### You can extend most of the things and overwrite EVERYTHING\n\nThe whole tool is built using [Jimple](https://yarnpkg.com/en/package/jimple), a port of [Pimple Dependency Injection container](https://github.com/silexphp/Pimple/) for Node, and EVERYTHING is registered on the container. You can simple set your own version of a service with the same name in order to overwrite it.\n\n> If you haven't tried [Jimple](https://github.com/fjorgemota/jimple), give it a try, it's excellent for organizing your app dependencies and services.\n\n[Read more about overwriting projext](manual/overwrite.html).\n\n### Building plugins is really easy\n\nBy default, projext checks your package.json for dependencies which names start with `projext-plugin-`, `require` them, they need to export a function that will receive the app container as parameter, thus allowing them to listen for events or even overwrite existing services.\n\nFor example, you want to create a plugin for [browserify](https://yarnpkg.com/en/package/browserify) (If someone is interested, please go ahead :)):\n\nYou would call your plugin `projext-plugin-browserify` to assure that projext will pick it and `require` it, and then the code would look something like this:\n\n```js\nmodule.exports = (projext) => {\n\tprojext.set('browserifyBuildEngine', ...);\n};\n```\n\n- [Read more about writing plugins](manual/plugins.html).\n- [Read more about build engines](manual/engines.html).\n\n### Browser targets configuration\n\nFor `node` targets, having multiple configuration files is simple, as they can `require` files on runtime, but in the case of `browser` targets, you would probably want to select the configuration you want to use when you bundle the code and be able to include it inside.\n\nThat's why, if enabled, projext creates an instance of [wootil's `AppConfiguration`](https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html) that `browser` targets can use on the bundling process.\n\nTo enable it, you have to edit your target settings:\n\n```js\nmodule.exports = {\n  targets: {\n    frontend: {\n      type: 'browser',\n      engine: 'webpack',\n      configuration: {\n        enabled: false,\n      },\n    },\n  },\n};\n```\n\nThat's all you need to enable the feature, the rest is dictated by the setting _\"smart defaults\"_:\n\n- You target configurations will be on `config/browser/...`.\n- The default configuration will be loaded from `config/browser/browser.config.js`.\n- Whenever you write `process.env.CONFIG` on your code, when bundled, it will replaced by the configuration contents.\n- If you add `CONFIG=xyz` before the `projext build` command, the service will look for a file `browser.xyz.config.js` and the configuration will be created by extending the default one.\n\n[Read more about browser targets configuration](manual/browserTargetConfiguration.html)\n\n## Development\n\n### NPM/Yarn Tasks\n\n| Task                    | Description                         |\n|-------------------------|-------------------------------------|\n| `yarn test`             | Run the project unit tests.         |\n| `yarn run lint`         | Lint the modified files.            |\n| `yarn run lint:full`    | Lint the project code.              |\n| `yarn run docs`         | Generate the project documentation. |\n| `yarn run todo`         | List all the pending to-do's.       |\n\n### Testing\n\nI use [Jest](https://facebook.github.io/jest/) with [Jest-Ex](https://yarnpkg.com/en/package/jest-ex) to test the project. The configuration file is on `./.jestrc`, the tests and mocks are on `./tests` and the script that runs it is on `./utils/scripts/test`.\n\n### Linting\n\nI use [ESlint](http://eslint.org) to validate all our JS code. The configuration file for the project code is on `./.eslintrc` and for the tests on `./tests/.eslintrc` (which inherits from the one on the root), there's also an `./.eslintignore` to ignore some files on the process, and the script that runs it is on `./utils/scripts/lint`.\n\n### Documentation\n\nI use [ESDoc](http://esdoc.org) to generate HTML documentation for the project. The configuration file is on `./.esdocrc` and the script that runs it is on `./utils/scripts/docs`.\n\n### To-Dos\n\nI use `@todo` comments to write all the pending improvements and fixes, and [Leasot](https://yarnpkg.com/en/package/leasot) to generate a report. The script that runs it is on `./utils/scripts/todo`.\n",
    "longname": "/Users/homer0/CODE/node/projext/projext/README-esdoc.md",
    "name": "./README-esdoc.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"projext\",\n  \"description\": \"Bundle and run your javascript project without configuring an specific module bundler.\",\n  \"homepage\": \"https://projextjs.com\",\n  \"version\": \"8.0.0\",\n  \"repository\": \"homer0/projext\",\n  \"author\": \"Leonardo Apiwan (@homer0) <me@homer0.com>\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"wootils\": \"^3.0.1\",\n    \"jimple\": \"^1.5.0\",\n    \"fs-extra\": \"^8.1.0\",\n    \"extend\": \"^3.0.2\",\n    \"del\": \"^5.1.0\",\n    \"shelljs\": \"0.8.3\",\n    \"glob\": \"^7.1.6\",\n    \"commander\": \"^4.0.1\",\n    \"@babel/core\": \"7.7.7\",\n    \"@babel/cli\": \"7.7.7\",\n    \"@babel/plugin-proposal-class-properties\": \"7.7.4\",\n    \"@babel/plugin-proposal-decorators\": \"7.7.4\",\n    \"@babel/plugin-syntax-dynamic-import\": \"7.7.4\",\n    \"@babel/plugin-proposal-object-rest-spread\": \"7.7.7\",\n    \"@babel/plugin-transform-runtime\": \"7.7.6\",\n    \"@babel/preset-flow\": \"7.7.4\",\n    \"@babel/preset-typescript\": \"7.7.7\",\n    \"@babel/preset-env\": \"7.7.7\",\n    \"@babel/runtime\": \"7.7.7\",\n    \"watchpack\": \"^1.6.0\",\n    \"nodemon\": \"^2.0.2\",\n    \"prompt\": \"^1.0.0\",\n    \"dotenv\": \"^8.2.0\",\n    \"dotenv-expand\": \"^5.1.0\",\n    \"core-js\": \"^3.6.1\",\n    \"regenerator-runtime\": \"0.13.3\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^6.8.0\",\n    \"eslint-plugin-homer0\": \"^3.0.0\",\n    \"jest-ex\": \"^7.0.1\",\n    \"jest-cli\": \"^24.9.0\",\n    \"jasmine-expect\": \"^4.0.3\",\n    \"minimatch\": \"^3.0.4\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"esdoc-node\": \"1.0.4\",\n    \"leasot\": \"^9.3.1\",\n    \"coveralls\": \"^3.0.9\",\n    \"husky\": \"^3.1.0\"\n  },\n  \"engine-strict\": true,\n  \"engines\": {\n    \"node\": \">=10.13.0\"\n  },\n  \"main\": \"src/index.js\",\n  \"bin\": {\n    \"projext\": \"./src/bin/projext\",\n    \"projext-cli\": \"./src/bin/projext-cli\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"./utils/hooks/pre-commit\",\n      \"post-merge\": \"./utils/hooks/post-merge\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"./utils/scripts/test\",\n    \"lint\": \"./utils/scripts/lint\",\n    \"lint:full\": \"./utils/scripts/lint-full\",\n    \"predocs\": \"./utils/scripts/docs-index\",\n    \"docs\": \"./utils/scripts/docs\",\n    \"todo\": \"./utils/scripts/todo\"\n  }\n}\n",
    "longname": "/Users/homer0/CODE/node/projext/projext/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/projectConfiguration.md",
    "name": "./documents/projectConfiguration.md",
    "content": "# Project Configuration\n\nThese are the settings that will determine how projext will handle your project.\n\n**The file must be created on one of the following paths:**\n\n- `[YOUR-PROJECT-PATH]/projext.config.js`\n- `[YOUR-PROJECT-PATH]/config/projext.config.js`\n- `[YOUR-PROJECT-PATH]/config/project.config.js`\n\n> projext will evaluate the list of paths and use the first one it finds.\n\nThere's no _\"top level\"_ setting, everything is separated in different scopes relevant to one specific thing:\n\n```js\n{\n  // Everything related to where your code is and where it will be bundled.\n  paths: ...,\n\n  // The default templates for your target settings.\n  targetsTemplates: ...,\n\n  // Your targets information - This must be overwritten.\n  targets: ...,\n\n  // The settings of the feature that copies files when bundling.\n  copy: ...,\n\n  // The settings of the feature the manages your project version.\n  version: ...,\n\n  // The path to custom plugins projext should load\n  plugins: ...,\n\n  // Miscellaneous settings.\n  others: ...,\n}\n```\n\n## `paths`\n\nThis setting is all about where your code is located and where it will be bundled:\n\n```js\n{\n  paths: {\n    source: 'src',\n    build: 'dist',\n    privateModules: 'private',\n  }\n}\n```\n\n### `source`\n\nThe directory, relative to your project path, where your targets code is located. On the documentation is often referred as the _\"source directory\"_.\n\n### `build`\n\nThe directory, relative to your project path, where your targets bundled code will be located. On the documentation is often referred as the _\"distribution directory\"_.\n\n### `privateModules`\n\nThis is for the feature that copies when bundling. In case you are using the feature to copy an npm module that, let's say, is not published, projext will save that module (without its dependencies) on that folder.\n\n## `targetsTemplates`\n\nThere was no way to have _\"smart defaults\"_ for targets and at the same time allow projext an unlimited amount of targets, and that's why the this setting exists.\n\nThe targets will extend the template which name is the same as their `type` property:\n\n```js\n{\n  node: ...,\n  browser: ...,\n}\n```\n\nSince there are a lot of settings for the templates, will divide them by type and see each one on detail.\n\n### `node`\n\n```js\n{\n  type: 'node',\n  bundle: false,\n  transpile: false,\n  engine: null,\n  hasFolder: true,\n  createFolder: false,\n  folder: '',\n  entry: { ... },\n  output: { ... },\n  sourceMap: { ... },\n  inspect: { ... },\n  css: { ... },\n  includeModules: [],\n  excludeModules: [],\n  includeTargets: [],\n  runOnDevelopment: false,\n  watch: { ... },\n  babel: { ... },\n  flow: false,\n  typeScript: false,\n  library: false,\n  libraryOptions: { ... },\n  cleanBeforeBuild: true,\n  copy: [],\n  dotEnv: { ... },\n}\n```\n\n#### `bundle`\n> Default value: `false`\n\nWhether or not the target needs to be bundled. Yes, it's kind of ironic that a tool that aims to simplify bundling would have an option like this, but there are a few scenarios where this may be useful:\n\n- You are bundling a frontend while you have your backend running on Node, you can bundle your frontend and just copy your backend.\n- You have no frontend target and you are using projext just to organize, run and prepare the distributable files.\n\nIf the value is `false`, when running on a development environment, and if the target doesn't need transpilation, the code won't be moved to the distribution directory.\n\n#### `transpile`\n> Default value: `false`\n\nThis option is kind of tied to the previous one: You may not want to bundle your Node target, but you can transpile it with [Babel](https://babeljs.io) if you want to use a feature not yet supported by the runtime.\n\n#### `engine`\n> Default value: `null`\n\nIn case `bundle` is `true`, this will tell projext which build engine you are going to bundle the code with.\n\nIf not overwritten, the value of this setting will be decided by projext when loading the configuration: It will take a list of known engines (webpack and Rollup) and check if any of them was loaded as a plugin.\n\n> This is the list of known build engines plugins you can install:\n>\n> - **webpack:** [`projext-plugin-webpack`](https://yarnpkg.com/en/package/projext-plugin-webpack)\n> - **Rollup:** [`projext-plugin-rollup`](https://yarnpkg.com/en/package/projext-plugin-rollup)\n\n#### `hasFolder`\n> Default value: `true`\n\nWhether your target code is on a sub folder of the source directory (`src/[target-name]/`) or the contents of the source directory are your target code (useful when working with a single target).\n\n#### `createFolder`\n> Default value: `false`\n\nWhether or not to create a folder for your targets code on the distribution directory when the target is bundled/copied.\n\n#### `folder`\n> Default value: `''`\n\nIf either `hasFolder` or `createFolder` is `true`, this can be used to specify a different folder name than the target's name.\n\n#### `entry`\n> Default value\n>\n> ```js\n> {\n>   default: 'index.js',\n>   development: null,\n>   production: null,\n> }\n> ```\n\nThis object is the one that tells projext which is the main file (executable) of your target for each specific environment. If you set `null` to an entry for an specific environment, it will fallback to the value of the `default` setting.\n\n#### `output`\n> Default value:\n>\n> ```js\n> {\n>   default: {\n>     js: '[target-name].js',\n>     fonts: 'statics/fonts/[name]/[name].[hash].[ext]',\n>     css: 'statics/styles/[target-name].[hash].css',\n>     images: 'statics/images/[name].[hash].[ext]',\n>   },\n>   development: {\n>     fonts: 'statics/fonts/[name]/[name].[ext]',\n>     css: 'statics/styles/[target-name].css',\n>     images: 'statics/images/[name].[ext]',\n>   },\n>   production: null,\n> }\n> ```\n\nThis tells projext where to place the files generated while bundling on each environment, depending on the file type.\n\nYou can use the following placeholders:\n\n- `[target-name]`: The name of the target.\n- `[hash]`: A random hash generated for cache busting.\n- `[name]`: The file original name (Not available for `css` and `js`).\n- `[ext]`: The file original extension (Not available for `css` and `js`).\n\n#### `sourceMap`\n> Default value:\n>\n> ```js\n> {\n>   development: false,\n>   production: true,\n> }\n> ```\n\nWhether or not to disable source map generation for each environment.\n\n#### `inspect`\n> Default value:\n>\n> ```js\n> {\n>   enabled: false,\n>   host: '0.0.0.0',\n>   port: 9229,\n>   command: 'inspect',\n>   ndb: false,\n> }\n> ```\n\nThese options allow you to enable and customize the Node inspector for debugging your target code.\n\n**`inspect.enabled`**\n\nWhether or not the inspector should be enabled when the target is run for development. You can also leave this as `false` and force it using the `inspect` command or the `--inspect` flag on the `run` and `build` commands.\n\n**`inspect.host`**\n\nThe native Node inspector uses a web socket so it can be accessed as a remote connection from the Chrome Developer tools. This setting is for the socket hostname.\n\n**`inspect.port`**\n\nThe port the socket for the inspector will use.\n\n**`inspect.command`**\n\nThe _\"inspect flag\"_ that will be used to enabled the inspector. It can be either `inspect` or `inspect-brk`. More information about this on the [Node documentation](https://nodejs.org/en/docs/guides/debugging-getting-started/).\n\n**`inspect.ndb`**\n\nWhether or not to use the new [Google's ndb](https://github.com/GoogleChromeLabs/ndb). Enabling this setting will make projext ignore the `host`, `port` and `command` as `ndb` is its own executable.\n\nSince `ndb` is experimental and **requires Node 8 or higher**, it's not included by `projext` automatically, so in order to enable it and avoid errors, you should run on a environment with Node 8 (or higher) and `ndb` should be installed (local or global, it doesn't matter).\n\n#### `css`\n> Default value:\n>\n> ```js\n> {\n>   modules: false,\n> }\n> ```\n\nThese options help you customize the way the bundling process handles your CSS code.\n\n**`css.modules`**\n\nWhether or not your application uses [CSS Modules](https://github.com/css-modules/css-modules). If this is enabled, all your styles will be prefixed with a unique identifier.\n\n#### `includeModules`\n> Default value: `[]`\n\nThis setting can be used to specify a list of node modules you want to process on your bundle.\n\nFor example, let's say you are using a library that exports a native `Class` that you are `extend`ing, but you are transpiling for an environment that doesn't support native `Class`es; you can add the name of the module on this setting and projext will include it on its bundling process and transpile it if needed.\n\n> At the end of the process, those names are converted to regular expressions, so you can also make the name a expression, while escaping especial characters of course.\n\n#### `excludeModules`\n> Default value: `[]`\n\nThis setting can be used to specify a list of modules that should never be bundled. By default, projext will exclude all the dependencies from the `package.json`, but if you import modules using a sub path (like `colors/safe` instead of `colors`), you need to specify it on this list so the build engine won't try to put it inside the bundle it.\n\n#### `includeTargets`\n> Default value: `[]`\n\nThis setting can be used to specify a list of other targets you want to process on your bundle.\n\nFor example, you have two targets, let's call them `frontend` and `backend`, that share some functionality and which code needs to be transpiled/processed. Since projext define the paths for transpilation/processing to match each target's directory, the wouldn't be able to use shared code between each other.\n\nYou have two possible solutions now, thanks to `includeTargets`: You can either add the other target name on each `includeTargets` setting, or define a third `shared` target that both have on the setting.\n\n#### `runOnDevelopment`\n> Default value: `false`\n\nThis tells projext that when the target is builded (bundled/copied) on a development environment, it should execute it.\n\nWhen the target needs to be bundled, it will relay on the build engined to do it, otherwise, projext will use its custom implementation of [`nodemon`](https://yarnpkg.com/en/package/nodemon) for watching and, if needed, transpile your target code.\n\n#### `watch`\n> Default value:\n>\n> ```js\n> {\n>   development: false,\n>   production: false,\n> }\n> ```\n\nUsing this flags, you can tell projext to always watch your files when building for an specific environment.\n\n#### `babel`\n> Default value:\n>\n> ```js\n> {\n>   features: {\n>     classProperties: false,\n>     decorators: false,\n>     dynamicImports: true,\n>     objectRestSpread: false,\n>   },\n>   nodeVersion: 'current',\n>   env: {},\n>   overwrites: {},\n> }\n> ```\n\nThese options are used in the case the target needs to be bundled or transpiled, to configure [Babel](https://babeljs.io):\n\n**`babel.features`**\n\nThis object can be used to enable/disable the Babel plugins projext includes:\n\n- `classProperties` (disabled): [`@babel/plugin-proposal-class-properties`](https://yarnpkg.com/en/package/@babel/plugin-proposal-class-properties).\n- `decorators` (disabled): [`@babel/plugin-proposal-decorators`](https://yarnpkg.com/en/package/@babel/plugin-proposal-decorators).\n- `dynamicImports` (enabled): [`@babel/plugin-syntax-dynamic-import`](https://yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import).\n- `objectRestSpread` (enabled): [`@babel/plugin-proposal-object-rest-spread`](https://yarnpkg.com/en/package/@babel/plugin-proposal-object-rest-spread).\n\nIf you need other plugins, they can be included on the `overwrites` option.\n\n**`babel.nodeVersion`**\n\nWhen building the Babel configuration, projext uses the [`@babel/preset-env`](https://yarnpkg.com/en/package/@babel/preset-env) to just include the necessary stuff. This setting tells the preset the version of Node it should _\"complete\"_.\n\n**`babel.env`**\n\nCustom settings that projext will use as base when generating the ones for the [`@babel/preset-env`](https://yarnpkg.com/en/package/@babel/preset-env).\n\n**`babel.overwrites`**\n\nIf you know how to use Babel and need stuff that is not covered by projext, you can use this setting to overwrite/add any value you may need.\n\n#### `flow`\n> Default value: `false`\n\nWhether or not your target uses [flow](https://flow.org/). This will update the Babel configuration in order to add support and, in case it was disabled, it will enable transpilation.\n\n#### `typeScript`\n> Default value: `false`\n\nWhether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel configuration in order to add support and, in case it was disabled, it will enable transpilation.\n\n#### `library`\n> Default value: `false`\n\nIf the project is bundled, this will tell the build engine that it needs to be builded as a library to be `require`d.\n\n#### `libraryOptions`\n> Default value:\n>\n> ```js\n> {\n>   libraryTarget: 'commonjs2',\n> }\n> ```\n\nIn case `library` is `true`, these options are going to be used by the build engine to configure your library:\n\n**`libraryOptions.libraryTarget`**\n\nHow the library will be exposed: `commonjs2` or `umd`.\n\n> Since this was built based on the webpack API, if you are using it as a build engine, you can set any `libraryTarget` that webpack supports. The ones mentioned above will be the ones projext will support for all the other build engines with different APIs.\n\n#### `cleanBeforeBuild`\n> Default value: `true`\n\nWhether or not to remove all code from previous builds from the distribution directory when making a new build.\n\n#### `copy`\n> Default value: `[]`\n\nA list of files to be copied during the bundling process. It can be a list of file paths relative to the target source directory, in which case they'll be copied to the target distribution directory root; or a list of objects with the following format:\n\n```js\n{\n  from: 'path/relative/to/the/source/directory.txt',\n  to: 'path/relative/to/the/distribution/directory.txt',\n}\n```\n\nThis is different from the main `copy` feature as this is specific to targets and you may require it for your app to work. For example: You may use this setting to copy a `manifest.json` for your PWA while you can use the main `copy` feature for the `package.json` or an `.nvmrc`, things you need for distribution.\n\n#### `dotEnv`\n> Default value:\n>\n> ```js\n> {\n>   enabled: true,\n>   files: [\n>     '.env.[target-name].[build-type]',\n>     '.env.[target-name]',\n>     '.env.[build-type]',\n>     '.env',\n>   ],\n>   extend: true,\n> }\n> ```\n\nThese options are used by both projext and the build engine in order to load environment variables from an \"environment file\". The variables are parsed with [`dotenv`](https://yarnpkg.com/en/package/dotenv) and expanded with [`dotenv-expand`](https://yarnpkg.com/en/package/dotenv-expand).\n\n**`dotEnv.enabled`**\n\nWhether or not the feature is enabled.\n\n**`dotEnv.files`**\n\nThe list of files projext will try to find in order to load the variables. Based on the value of `extend`, the way projext will process them may change.\n\n**`dotEnv.extend`**\n\nWhether or not projext should merge all the variables from all the files it can find.\n\nTake for example the following list of files:\n\n```js\n[\n  '.env.[target-name].[build-type],\n  '.env.[target-name]',\n]\n```\n\nIf `extend` is set to `true` and both files exist, projext will load `.env.[target-name]` as the first file and then merge the values from `.env.[target-name].[build-type]` on top of it.\n\nIf `extend` is set to `false`, projext will use the first file it can find.\n\n### `browser`\n\n```js\n{\n  type: 'browser',\n  engine: null,\n  hasFolder: true,\n  createFolder: true,\n  folder: '',\n  entry: { ... },\n  output: { ... },\n  sourceMap: { ... },\n  html: { ... },\n  css: { ... },\n  includeModules: [],\n  excludeModules: [],\n  includeTargets: [],\n  uglifyOnProduction: true,\n  runOnDevelopment: false,\n  watch: { ... },\n  babel: { ... },\n  flow: false,\n  typeScript: false,\n  library: false,\n  libraryOptions: { ... },\n  cleanBeforeBuild: true,\n  copy: [],\n  dotEnv: { ... },\n  devServer: { ... },\n  configuration: { ... },\n}\n```\n\n#### `engine`\n> Default value: `null`\n\nThis will tell projext which build engine you are going to bundle the target code with.\n\nIf not overwritten, the value of this setting will be decided by projext when loading the configuration: It will take a list of known engines (webpack and Rollup) and check if any of them was loaded as a plugin.\n\n> This is the list of known build engines plugins you can install:\n>\n> - **webpack:** [`projext-plugin-webpack`](https://yarnpkg.com/en/package/projext-plugin-webpack)\n> - **Rollup:** [`projext-plugin-rollup`](https://yarnpkg.com/en/package/projext-plugin-rollup)\n\n#### `hasFolder`\n> Default value: `true`\n\nWhether your target code is on a sub folder of the source directory (`src/[target-name]/`) or the contents of the source directory are your target code (useful when working with a single target).\n\n#### `createFolder`\n> Default value: `false`\n\nWhether or not to create a folder for your targets code on the distribution directory when the target is bundled/copied.\n\n#### `folder`\n> Default value: `''`\n\nIf either `hasFolder` or `createFolder` is `true`, this can be used to specify a different folder name than the target's name.\n\n#### `entry`\n> Default value\n>\n> ```js\n> {\n>   default: 'index.js',\n>   development: null,\n>   production: null,\n> }\n> ```\n\nThis object is the one that tells projext which is the main file (the one that fires the app) of your target for each specific environment. If you set `null` to an entry for an specific environment, it will fallback to the value of the `default` setting.\n\n#### `output`\n> Default value:\n>\n> ```js\n> {\n>   default: {\n>     js: 'statics/js/[target-name].[hash].js',\n>     fonts: 'statics/fonts/[name]/[name].[hash].[ext]',\n>     css: 'statics/styles/[target-name].[hash].css',\n>     images: 'statics/images/[name].[hash].[ext]',\n>   },\n>   development: {\n>     js: 'statics/js/[target-name].js',\n>     fonts: 'statics/fonts/[name]/[name].[ext]',\n>     css: 'statics/styles/[target-name].css',\n>     images: 'statics/images/[name].[ext]',\n>   },\n>   production: null,\n> }\n> ```\n\nThis tells projext where to place the files generated while bundling on each environment, depending on the file type.\n\nYou can use the following placeholders:\n\n- `[target-name]`: The name of the target.\n- `[hash]`: A random hash generated for cache busting.\n- `[name]`: The file original name (Not available for `css` and `js`).\n- `[ext]`: The file original extension (Not available for `css` and `js`).\n\n#### `sourceMap`\n> Default value:\n>\n> ```js\n> {\n>   development: false,\n>   production: true,\n> }\n> ```\n\nWhether or not to disable source map generation for each environment.\n\n#### `html`\n> Default value:\n>\n> ```js\n> {\n>   default: 'index.html',\n>   template: null,\n>   filename: null,\n> }\n> ```\n\nIn the case the target is an app, these are the options for the `html` file that will include the bundle `<script />`; and if your target is a library, this can be used to test your library.\n\n**`html.default`**\n\nThis would be the fallback if either `template` or `filename` is `null`.\n\n**`html.template`**\n\nThe file inside your target source that will be used to generate the `html`.\n\n**`html.filename`**\n\nThe file that will be generated when your target is bundled. It will automatically include the `<script />` tag to the generated bundle.\n\n#### `css`\n> Default value:\n>\n> ```js\n> {\n>   modules: false,\n>   inject: false,\n> }\n> ```\n\nThese options help you customize the way the bundling process handles your CSS code.\n\n**`css.modules`**\n\nWhether or not your application uses [CSS Modules](https://github.com/css-modules/css-modules). If this is enabled, all your styles will be prefixed with a unique identifier.\n\n**`css.inject`**\n\nIf this setting is set to `true`, instead of generating a CSS file with your styles, they'll be dynamically injected on HTML when the bundle gets executed.\n\n#### `includeModules`\n> Default value: `[]`\n\nThis setting can be used to specify a list of node modules you want to process on your bundle.\n\nFor example, let's say you are using a library that exports a native `Class` that you are `extend`ing, but you are transpiling for a browser that doesn't support native `Class`es; you can add the name of the module on this setting and projext will include it on its bundling process and transpile it if needed.\n\n> At the end of the process, those names are converted to regular expressions, so you can also make the name a expression, while escaping especial characters of course.\n\n#### `excludeModules`\n> Default value: `[]`\n\nThis setting can be used to specify a list of modules that should never be bundled.\n\n#### `includeTargets`\n> Default value: `[]`\n\nThis setting can be used to specify a list of other targets you want to process on your bundle.\n\nFor example, you have two targets, let's call them `frontend` and `backend`, that share some functionality and which code needs to be transpiled/processed. Since projext define the paths for transpilation/processing to match each target's directory, the wouldn't be able to use shared code between each other.\n\nYou have two possible solutions now, thanks to `includeTargets`: You can either add the other target name on each `includeTargets` setting, or define a third `shared` target that both have on the setting.\n\n#### `uglifyOnProduction`\n> Default value: `true`\n\nWhen a bundle is created, this setting will tell the build engine whether to uglify the code for production or not.\n\nThis can be useful for debugging production code.\n\n#### `runOnDevelopment`\n> Default value: `false`\n\nThis will tell the build engine that when you build the target for a development environment, it should bring up an `http` server to _\"run\"_ your target.\n\n#### `watch`\n> Default value:\n>\n> ```js\n> {\n>   development: false,\n>   production: false,\n> }\n> ```\n\nUsing this flags, you can tell projext to always watch your files when building for an specific environment.\n\n#### `babel`\n> Default value:\n>\n> ```js\n> {\n>   features: {\n>     classProperties: false,\n>     decorators: false,\n>     dynamicImports: true,\n>     objectRestSpread: false,\n>   },\n>   browserVersions: 2,\n>   mobileSupport: true,\n>   polyfill: true,\n>   env: {},\n>   overwrites: {},\n> }\n> ```\n\nThese options are used by the build engine to configure [Babel](https://babeljs.io):\n\n**`babel.features`**\n\nThis object can be used to enable/disable the Babel plugins projext includes:\n\n- `classProperties` (disabled): [`@babel/plugin-proposal-class-properties`](https://yarnpkg.com/en/package/@babel/plugin-proposal-class-properties).\n- `decorators` (disabled): [`@babel/plugin-proposal-decorators`](https://yarnpkg.com/en/package/@babel/plugin-proposal-decorators).\n- `dynamicImports` (enabled): [`@babel/plugin-syntax-dynamic-import`](https://yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import).\n- `objectRestSpread` (enabled): [`@babel/plugin-proposal-object-rest-spread`](https://yarnpkg.com/en/package/@babel/plugin-proposal-object-rest-spread).\n\nIf you need other plugins, they can be included on the `overwrites` option.\n\n**`babel.browserVersions`**\n\nWhen building the Babel configuration, projext uses the [`@babel/preset-env`](https://yarnpkg.com/en/package/@babel/preset-env) to just include the necessary stuff. This setting tells how many old versions of the major browsers the target needs transpilation for.\n\n> Major browsers: Firefox, Chrome, Safari and Edge.\n\n**`babel.mobileSupport`**\n\nIf `true`, the configuration will add to the list of major browsers `iOS` and `Android`.\n\n**`babel.polyfill`**\n\nWhether or not the configuration for the [`@babel/preset-env`](https://yarnpkg.com/en/package/@babel/preset-env) should include the settings for [`useBuiltIns` and `corejs`](https://babeljs.io/docs/en/babel-preset-env#usebuiltins).\n\nSomething that should be noted is that if `babel.polyfill` is set to `true`, projext will set `useBuiltIns` to `usage`; if you want to change it to `entry`, you have to change it using `babel.env` (explained below) and manually import [`core-js/stable`](https://yarnpkg.com/en/package/core-js) and [`regenerator-runtime/runtime`](https://yarnpkg.com/en/package/regenerator-runtime). If you do it, you can use the same _semver range_ projext uses so `npm`/`yarn` can resolve them to the ones installed by projext.\n\n**`babel.env`**\n\nCustom settings that projext will use as base when generating the ones for the [`@babel/preset-env`](https://yarnpkg.com/en/package/@babel/preset-env).\n\n**`babel.overwrites`**\n\nIf you know how to use Babel and need stuff that is not covered by projext, you can use this setting to overwrite/add any value you may need.\n\n#### `flow`\n> Default value: `false`\n\nWhether or not your target uses [flow](https://flow.org/). This will update the Babel configuration in order to add support for it.\n\n#### `typeScript`\n> Default value: `false`\n\nWhether or not your target uses [TypeScript](https://www.typescriptlang.org/). This will update the Babel configuration in order to add support for it.\n\n#### `library`\n> Default value: `false`\n\nThis will tell the build engine that it needs to be builded as a library to be `require`d.\n\n#### `libraryOptions`\n> Default value:\n>\n> ```js\n> {\n>   libraryTarget: 'umd',\n>   compress: false,\n> }\n> ```\n\nIn case `library` is `true`, these options are going to be used by the build engine to configure your library:\n\n**`libraryOptions.libraryTarget`**\n\nHow the library will be exposed: `commonjs`, `umd` or `window`.\n\n> Since this was built based on the webpack API, if you are using it as a build engine, you can set any `libraryTarget` that webpack supports. The ones mentioned above will be the ones projext will support for all the other build engines with different APIs.\n\n\n**`libraryOptions.compress`**\n\nWhether or not to use gzip compression on the generated library file.\n\n#### `cleanBeforeBuild`\n> Default value: `true`\n\nWhether or not to remove all code from previous builds from the distribution directory when making a new build.\n\n#### `copy`\n> Default value: `[]`\n\nA list of files to be copied during the bundling process. It can be a list of file paths relative to the target source directory, in which case they'll be copied to the target distribution directory root; or a list of objects with the following format:\n\n```js\n{\n  from: 'path/relative/to/the/source/directory.txt',\n  to: 'path/relative/to/the/distribution/directory.txt',\n}\n```\n\nThis is different from the main `copy` feature as this is specific to targets and you may require it for your app to work. For example: You may use this setting to copy a `manifest.json` for your PWA while you can use the main `copy` feature for the `package.json` or an `.nvmrc`, things you need for distribution.\n\n#### `dotEnv`\n> Default value:\n>\n> ```js\n> {\n>   enabled: true,\n>   files: [\n>     '.env.[target-name].[build-type]',\n>     '.env.[target-name]',\n>     '.env.[build-type]',\n>     '.env',\n>   ],\n>   extend: true,\n> }\n> ```\n\nThese options are used by both projext and the build engine in order to load environment variables from an \"environment file\". The variables are parsed with [`dotenv`](https://yarnpkg.com/en/package/dotenv) and expanded with [`dotenv-expand`](https://yarnpkg.com/en/package/dotenv-expand).\n\n**`dotEnv.enabled`**\n\nWhether or not the feature is enabled.\n\n**`dotEnv.files`**\n\nThe list of files projext will try to find in order to load the variables. Based on the value of `extend`, the way projext will process them may change.\n\n**`dotEnv.extend`**\n\nWhether or not projext should merge all the variables from all the files it can find.\n\nTake for example the following list of files:\n\n```js\n[\n  '.env.[target-name].[build-type],\n  '.env.[target-name]',\n]\n```\n\nIf `extend` is set to `true` and both files exist, projext will load `.env.[target-name]` as the first file and then merge the values from `.env.[target-name].[build-type]` on top of it.\n\nIf `extend` is set to `false`, projext will use the first file it can find.\n\n#### `devServer`\n> Default value:\n>\n> ```js\n> {\n>   port: 2509,\n>   reload: true,\n>   open: true,\n>   host: 'localhost',\n>   ssl: {\n>     key: null,\n>     cert: null,\n>     ca: null,\n>   },\n>   proxied: { ... },\n>   historyApiFallback: true,\n> }\n> ```\n\nThese are the options for the `http` server projext will use when running the target on a development environment.\n\n**`devServer.port`**\n\nThe server port.\n\n**`devServer.reload`**\n\nWhether or not to reload the browser when the code changes.\n\n**`devServer.open`**\n\nWhether or not to open the browser when server is ready.\n\n**`devServer.host`**\n\nThe dev server hostname.\n\n**`devServer.ssl`**\n\nThis allows you to set your own SSL certificates in order to run the dev server over HTTPS. The paths must be relative to your project root directory, for example:\n\n```js\nssl: {\n  key: 'ssl-files/server.key',\n  cert: 'ssl-files/server.crt',\n  ca: 'ssl-files/ca.pem',\n}\n```\n\n**`devServer.proxied`**\n> Default value:\n>\n> ```js\n> {\n>   enabled: false,\n>   host: null,\n>   https: null,\n> }\n> ```\n\nWhen the dev server is being proxied (using `nginx` for example), there are certain functionalities, like hot module replacement and live reload that need to be aware of this, so you need to use these options:\n\n- `enabled`: Whether the server is being proxied or not.\n- `host`: The hostname used. If `null`, it will use the same as `devServer.host`.\n- `https`: Whether or not the server is being proxied over `https`. This settings has a boolean value, but if you let it as `null` it will set its value based on `devServer.ssl`, if you added the certificates it will be `true`, otherwise `false`.\n\n**`devServer.historyApiFallback`**\n> Default value: true\n\nWhether or not to redirect the browser back to the root whenever a path can't be found.\n\n#### `configuration`\n> Default value:\n>\n> ```js\n> {\n>   enabled: false,\n>   default: null,\n>   path: 'config/',\n>   hasFolder: true,\n>   defineOn: 'process.env.CONFIG',\n>   environmentVariable: 'CONFIG',\n>   loadFromEnvironment: true,\n>   filenameFormat: '[target-name].[configuration-name].config.js',\n> }\n> ```\n\nThese are the settings for the feature that allows a browser target to have a dynamic configuration file.\n\n> For more precise information, check the document about Browser configuration.\n\n**`configuration.enabled`**\n\nWhether or not the feature is enabled.\n\n**`configuration.default`**\n\nThe default configuration. If none is specified, when the target is builded, it will try to use `[target-name].config.js`, located on the configuration folder.\n\n**`configuration.path`**\n\nThe path where the configuration files are located.\n\n**`configuration.hasFolder`**\n\nWhether or not there's a folder with the target name on the configuration path.\n\n**`configuration.defineOn`**\n\nThe name of the variable where the configuration is going to be replaced on your code when bundled.\n\n**`configuration.environmentVariable`**\n\nThe name of the environment variable projext will check when building the target in order to load a dynamic configuration.\n\n**`configuration.loadFromEnvironment`**\n\nWhether or not projext should check for the environment variable value.\n\n**`configuration.filenameFormat`**\n\nThe name format of the configuration files.\n\n## `targets`\n\nThis setting is an empty object because this is the only required setting. This is where you'll add your target(s) information, for example:\n\n```js\n{\n  targets: {\n    backend: {\n      type: 'node',\n    },\n    frontend: {\n      type: 'browser',\n    },\n  }\n}\n```\n\n## `copy`\n\nThese settings are for the feature that enables projext to copy files when building targets:\n\n```js\n{\n  enabled: false,\n  items: [],\n  copyOnBuild: { ... },\n}\n```\n\n### `enabled`\n> Default value: `false`\n\nWhether or not the feature is enabled.\n\n### `items`\n> Default value: `[]`\n\nA list of files and/or directories that will be copied. All with paths relative to the project directory.\n\n### `copyOnBuild`\n> Default value:\n>\n> ```js\n> {\n>   enabled: true,\n>   onlyOnProduction: true,\n>   targets: [],\n> }\n> ```\n\nSince the feature is also available through the projext CLI, you can configure how the feature behaves when building:\n\n#### `copyOnBuild.enabled`\n> Default value: `true`\n\nWhether or not to copy the files when building. If disabled, you can use the CLI to copy the files.\n\n#### `copyOnBuild.onlyOnProduction`\n> Default value: `true`\n\nThis tells projext if the files should be copied only when building for production, or if it should do it for development too.\n\n#### `copyOnBuild.targets`\n> Default value: `[]`\n\nThis can be used to specify the targets that will trigger the feature when builded. If no target is specified, the feature will be triggered by all the targets.\n\n## `version`\n\nThese settings are for the feature that manages your project version:\n\n```js\n{\n  defineOn: 'process.env.VERSION',\n  environmentVariable: 'VERSION',\n  revision: { ... },\n}\n```\n\n### `defineOn`\n> Default value: `process.env.VERSION`\n\nThe name of the variable where the version is going to be replaced on your code when bundled.\n\n### `environmentVariable`\n> Default value: `VERSION`\n\nThe name of the environment variable projext should check to get the project version.\n\n### `revision`\n> Default value:\n>\n> ```js\n> {\n>   enabled: false,\n>   copy: true,\n>   filename: 'revision',\n>   createRevisionOnBuild: { ... },\n> }\n> ```\n\nThis is like a sub-feature. A revision file is a file that contains the version of your project. This is useful when deploying the project to an environment where you have no access to the environment variable.\n\nThe way the revision file works is by first checking if the environment variable is available and, if not, it will check if the project is on a `GIT` repository and try to get the hash of the last commit.\n\n#### `revision.enabled`\n> Default value: `false`\n\nWhether or not the revision file feature is enabled.\n\n#### `revision.copy`\n> Default value: `false`\n\nWhether or not to copy the revision file when the project files are being copied to the distribution directory.\n\n#### `revision.filename`\n> Default value: `revision`\n\nThe name of the revision file.\n\n#### `revision.createRevisionOnBuild`\n> Default value:\n>\n> ```js\n> {\n>   enabled: true,\n>   onlyOnProduction: true,\n>   targets: [],\n> }\n> ```\n\n\nSince the feature is also available through the projext CLI, you can configure how the feature behaves when building:\n\n**`revision.createRevisionOnBuild.enabled`**\n> Default value: `true`\n\nWhether or not to create the file when building. If disabled, you can use the CLI to copy the files.\n\n**`revision.createRevisionOnBuild.onlyOnProduction`**\n> Default value: `true`\n\nThis tells projext if the file should be created only when building for production, or if it should do it for development too.\n\n**`revision.createRevisionOnBuild.targets`**\n> Default value: `[]`\n\nThis can be used to specify the targets that will trigger the feature when builded. If no target is specified, the feature will be triggered by all the targets.\n\n## `plugins`\n\nTo load custom plugins.\n\n```js\n{\n  enabled: true,\n  list: [],\n}\n```\n\n### `enabled`\n> Default value: `true`\n\nWhether or not custom plugins should be loaded.\n\n### `list`\n> Default value: `[]`\n\nA list of plugin paths relative to the project root directory. Those files can export a single function or a function called `plugin` in order to be loaded.\n\n> For more precise information, check the document about creating plugins.\n\n## `others`\n\nMiscellaneous options.\n\n```js\n{\n  findTargets: { ... },\n  watch: { ... },\n  nodemon: { ... },\n}\n```\n\n### `findTargets`\n> Default value:\n>\n> ```js\n> {\n>   enabled: true,\n> }\n> ```\n\nBy default, projext will look in your source directory and try to identify as much information as possible about your target(s), but if for some reason you don't want it to do it, you can use this setting to disable that functionality.\n\n#### `findTargets.enabled`\n> Default value: `true`\n\nWhether or not you want projext to read your project files and try to assume information about your targets.\n\n### `watch`\n> Default value:\n>\n> ```js\n> {\n>   poll: true,\n> }\n> ```\n\nThis is used by projext to configure [`watchpack`](https://yarnpkg.com/en/package/watchpack), which is used to watch Node files that need to be transpiled.\n\nThe reason is outside the `targetsTemplate.node` is because this can be used for any other plugin that watches the file system.\n\n#### `watch.poll`\n> Default value: `true`\n\nWhether or not to use polling to get the changes on the file system, and if so, it can also be used to specify the ms interval.\n\n### `nodemon`\n> Default value:\n>\n> ```js\n> {\n>   legacyWatch: false,\n> }\n> ```\n\nThis is used by projext to configure [`nodemon`](https://yarnpkg.com/en/package/nodemon), which is used to execute and watch Node targets.\n\n#### `nodemon.legacyWatch`\n> Default value: `false`\n\nWhether or not to enable the `nodemon` legacy watch mode for systems where the refresh doesn't work. More information [check the `nodemon` documentation](https://github.com/remy/nodemon#application-isnt-restarting).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/cli.md",
    "name": "./documents/cli.md",
    "content": "# projext CLI\n\nThe projext Command-Line Interface allows you to tell projext which tasks you want to execute and for which targets.\n\nYou can run this commands with either [yarn](https://yarnpkg.com), [npx](https://www.npmjs.com/package/npx) or by using a `package.json` script.\n\n## Available commands\n\n### Build targets\n\nIt builds a target and moves it bundle to the distribution directory.\n\n```bash\nprojext build [target] [--type [type]] [--watch] [--run] [--inspect] [--analyze]\n```\n\n- **target:** The name of the target you intend to build. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n- **type:** Which build type: `development` (default) or `production`.\n- **watch:** Watch the target files and update the build. If the target type is Node and it doesn't require bundling nor transpiling, it won't do anything.\n- **run:** Run the target after the build is completed. It only works when the build type is `development`.\n- **inspect:** Enable the Node inspector. It only works with the `run` flag and if the target type is `node`.\n- **analyze:** Enable the bundle analyzer of the build engine. It only works on browser targets o Node targets with `bundle` set to `true`.\n\n### Watching a target\n\nIt tells projext to watch your target files and update the build if they change.\n\n```bash\nprojext run [target]\n```\n- **target:** The name of the target you intend to build and watch. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n\n> This is basically an alias of `projext build` that uses the `--watch` flag by default.\n\n### Running a target\n\nIf the target is a Node app, it will execute it, otherwise, it will bring up an `http` server to _\"run\"_ your target.\n\n```bash\nprojext run [target] [--inspect]\n```\n- **target:** The name of the target you intend to build and run. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n- **inspect:** Enable the Node inspector. It only works if the target type is `node`.\n\n> This is basically an alias of `projext build` that uses the `--run` flag by default.\n\n### Inspecting a Node target\n\nIf the target is a Node app, it will execute it and enable the Node inspector.\n\n```bash\nprojext inspect [target]\n```\n- **target:** The name of the target you intend to build, run and inspect. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n\n> This is basically an alias of `projext build` that uses the `--run` and `--inspect` flags by default.\n\n### Analyzing a target bundle\n\nThis is for bundled targets, it tells the build engine to use the analyzer and show the stats for the generated bundle.\n\n```bash\nprojext analyze [target] [--type [type]]\n```\n- **target:** The name of the target you intend to analyze. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n- **type:** Which build type: `development` (default) or `production`.\n\n> This is basically an alias of `projext build` that uses the `--analyze` flag by default.\n\n### Cleaning previous builds\n\nRemoves the files from previous builds from the distribution directory.\n\n```bash\nprojext clean [target] [--all]\n```\n- **target:** The name of the target you intend to remove builds from. If no target is specified, projext will try to use the default target (the one with the project's name or the first on an alphabetical list).\n- **all:** Instead of just removing a target files, it removes the entire distribution directory.\n\n> This gets automatically called when building if the target `cleanBeforeBuild` setting is `true`.\n\n### Copy the project files\n\nIf the feature is enabled (check the project configuration document), this will copy the files and/or directories specified on the feature settings to the distribution directory.\n\n```bash\nprojext copy-project-files\n```\n\n> This gets automatically called when building if the feature is configured to run when building.\n\n### Create the revision file\n\nIf the feature is enabled (check the project configuration document), this will create the revision file with the project version.\n\n```bash\nprojext create-revision\n```\n\n> This gets automatically called when building if the feature is configured to run when building.\n\n### Read the project settings\n\nIt logs all the project settings on the console. You can also specify a directory-like path to access specific settings.\n\n```bash\nprojext info [path]\n```\n- **path:** A directory-like path for an specific setting, for example: `targetsTemplates/browser/html`. If no path is specified, it will log all the project settings.\n\n\n### Generate resources\n\nprojext zero configuration assumes a lot of things about your project in order to run it without a configuration file: Your target(s) settings and, for browser targets, the default HTML.\n\nThis command allows you to write down those resources on your project so you can manually modify them:\n\n```bash\nprojext generate [resource] [options]\n```\n\nResources:\n\n- `config`: Writes a configuration file with your target information.\n- `html`: Writes a browser target default HTML file.\n\nFor more information about the generators, please check the Zero configuration document.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/overwrite.md",
    "name": "./documents/overwrite.md",
    "content": "# Overwriting projext\n\nprojext was built on the idea that everything could be overwritten, so if the default functionalities don't cover all your project scenarios, you could easily overwrite a service and make it work the way you like (and hopefully publish it as a plugin later).\n\nAll the project structure was built using [Jimple](https://yarnpkg.com/en/package/jimple), a port of [Pimple Dependency Injection container](https://github.com/silexphp/Pimple/) for Node, and EVERYTHING is registered on the container. You can simple set your own version of a service with the same name in order to overwrite it.\n\nThe way you get access to the container is by creating a file called `projext.setup.js` on your project root directory, there you'll create your own instance of projext, register your custom/overwrite services and export it:\n\n```js\n// projext.setup.js\n\n// Get the main class\nconst { Projext } = require('projext');\n\n// Create a new instance\nconst myProjext = new Projext();\n\n// Overwrite a service\nmyProjext.set('cleaner', () => myCustomCleaner);\n\n// Export your custom version\nmodule.exports = myProjext;\n```\n\nAll projext commands will first check if you have the file and then fallback to the default app.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/plugins.md",
    "name": "./documents/plugins.md",
    "content": "# projext plugins\n\nCreating plugins for projext is really simple as the tool takes care of finding them on your `package.json`, loading them, allowing them to register services and providing the necessary events so they can interact with the targets.\n\n## Naming convention\n\nAll projext plugins names should start with `projext-plugin-`, this allows projext to find them on your project dependencies. Once a plugin is found, projext will be `require` it and call its exported function with a reference to the dependency container.\n\n## Adding services to the container\n\nAll the project structure was built using [Jimple](https://yarnpkg.com/en/package/jimple), a port of [Pimple Dependency Injection container](https://github.com/silexphp/Pimple/) for Node, so in oder to register a new service, you should `set` it on the container.\n\nLet's say the following code is the `main` file of a plugin:\n\n```js\n// Get the service you want to register\nconst MyService = require('...');\n\n// Export the function that will be called when the plugin is register\nmodule.exports = (projext) => {\n  // Set the service on the container\n  projext.set('myServiceName', () => new MyService());\n}\n```\n\n## Events\n\nprojext has an `events` service that is an implementation of [wootil's `EventsHub`](https://homer0.github.io/wootils/class/wootils/shared/eventsHub.js~EventsHub.html) and that it uses to emit information events and reduce variables when needed.\n\n```js\n...\nmodule.exports = (projext) => {\n\t...\n\tconst events = projext.get('events');\n\n\t// Add a new listener for a regular event\n\tevents.on('some-event', () => {\n\t  console.log('some-event was fired!');\n\t});\n\n\t// Add a reducer event\n\tevents.on('some-reducer-events', (someConfiguration) => Object.assign({}, someConfiguration, {\n\t  name: 'charito',\n\t}));\n});\n```\n\n### Regular events\n\n#### Revision file creation\n\n- Name: `revision-file-created`.\n- Parameters:\n - `version`: The version written on the file.\n\nThis is emitted if the revision file feature is enabled (check the project configuration document) and the command that creates it was called.\n\n### Reducer events\n\n#### List of the project files and/or folders to copy\n\n- Name: `project-files-to-copy`.\n- Reduces: The list of files and/or folders to copy.\n\nThis event is used if the feature to copy project files is enabled (check the project configuration document) and the command that does the copying is called.\n\n#### Target information\n\n- Name: `target-load`.\n- Reduces: A target information.\n\nThis is called when projext loads a new target, after defining its paths and applying its type template.\n\n#### The list of commands to build a target\n\n- Name: `build-target-commands-list`.\n- Reduces: The list of CLI commands projext uses to build a target.\n- Parameters:\n - `target`: The target information.\n - `type`: The build type, `development` or `production`.\n - `run`: Whether or not the target will be executed after building.\n\nIn order to build targets, projext generates a list of CLI commands that a shell script executes, and this event is called in order to reduce that list.\n\n#### A target Babel configuration\n\n- Name: `babel-configuration`.\n- Reduces: The Babel configuration for an specific target.\n- Parameters:\n - `target`: The target information.\n\nWhen building a target, projext will create a Babel configuration based on this settings, then this event is used to reduce that configuration.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/engines.md",
    "name": "./documents/engines.md",
    "content": "# projext build engines\n\nA build engine is what takes care of bundling your target code, projext is just the intermediary.\n\n## Implementing a build engine\n\nA build engine is a plugin that you need to install on your project, so the first requirement is to install it as a dependency, after that you should change your target(s) `engine` setting to the name of the build engine you installed.\n\n> On an ideal world, that would be enough, but never forget to read the plugin `README`.\n\n## Creating a build engine\n\nYou should probably start with the Plugins document to get an idea of how plugins work.\n\nOnce you are ready, you need to register a service with the name `[your-build-engine-name]BuildEngine` and it should implement one required method:\n\n**`getBuildCommand(target, buildType, forceRun = false)`**\n\n- `target`: The target information.\n- `buildType`: `development` or `production`.\n- `forceRun`: Whether or not the user intends to run the target after building it, even if the target `runOnDevelopment` setting is `false.\n\nThis should return a string with the command(s) the projext shell script should run in order to generate the bundle.\n\n### Let's create a plugin for browserify\n\nThe first thing is to create the plugin with the naming convention: `projext-plugin-browserify`.\nNow, we'll create a build engine service for it:\n\n> This example is just to show how to create the engine, it will only build the target and nothing else. Not even include it on an HTML file.\n\n```js\n// src/browserify.js\n\nclass BrowserifyBuildEngine {\n  getBuildCommand(target, buildType) {\n    const entryFile = path.join(target.paths.source, target.entry[buildType]);\n    const output = path.join(target.paths.build, target.name);\n    return `browserify ${entryFile} -o ${output}.js`;\n  }\n}\n\nmodule.exports = BrowserifyBuildEngine;\n```\n\nReally simple, right? Now, assuming the `package.json` `main` entry points to `src/index.js`:\n\n```js\n// src/index.js\nconst BrowserifyBuildEngine = require('./browserify.js');\n\nmodule.exports = (projext) => {\n  projext.set('browserifyBuildEngine', () => new BrowserifyBuildEngine());\n};\n```\n\nDone, the only thing to do now is to change a target `engine` setting to `browserify` and when building, it will create a bundle using Browserify.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/browserTargetConfiguration.md",
    "name": "./documents/browserTargetConfiguration.md",
    "content": "# projext browser target configuration\n\nThis feature allows you to have dynamic configurations on your browser targets.\n\nFor `node` targets, having multiple configuration files is simple, as they can `require` files on runtime, but in the case of `browser` targets, you would probably want to select the configuration you want to use when you bundle the code and be able to include it inside.\n\nThat's why, if enabled, projext creates an instance of [wootil's `AppConfiguration`](https://homer0.github.io/wootils/class/wootils/node/appConfiguration.js~AppConfiguration.html) that `browser` targets can use on the bundling process.\n\n## Settings\n\nThe settings for this feature are on the target own settings, under the `configuration` key:\n\n```js\n{\n  type: 'browser',\n  configuration: {\n    enabled: false,\n    default: null,\n    path: 'config/',\n    hasFolder: true,\n    defineOn: 'process.env.CONFIG',\n    environmentVariable: 'CONFIG',\n    loadFromEnvironment: true,\n    filenameFormat: '[target-name].[configuration-name].config.js',\n  },\n}\n```\n\n### `enabled`\n\nWhether or not the feature is enabled.\n\n### `default`\n\nThe default configuration. It will be the base all the other, _\"dynamic\"_, configuration will extend.\n\nIf not specified, projext will try to load a configuration file called `[target-name].config.js`, inside the configuration path.\n\n### `path`\n\nThe path relative to the root directory where the configurations are located.\n\n### `hasFolder`\n\nIf `true`, projext will append a folder with the name of the target on the configurations path.\n\n### `defineOn`\n\nThe name of a variable that, when the target is builded, will be replaced with the configuration object.\n\n### `environmentVariable`\n\nThe name of an environment variable where projext will check for a configuration name.\n\n### `loadFromEvironment`\n\nWhether or not projext should check the environment variable. This is for cases in which loading the default configuration is enough for your project.\n\n### `filenameFormat`\n\nThe name format of the configuration files. `[configuration-name]` will be replaced with the value of the environment variable.\n\n## Using a configuration\n\nFirst, let's assume the following things:\n\n- You set `enabled` to `true`.\n- You left all the other default values.\n- You target is named `myapp`\n\nNow, you should be able to use it by sending the environment variable before the projext command:\n\n```bash\nCONFIG=debug [projext-command-to-build-a-target]\n```\n\nThis will load `config/myapp/myapp.config.js` and then `config/myapp/myapp.debug.js`.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/homer0/CODE/node/projext/projext/documents/codeSplitting.md",
    "name": "./documents/codeSplitting.md",
    "content": "# Code splitting\n\nThis feature allows you to split your bundles on smaller pieces and then load those pieces when you need them (basically, _\"lazy loading\"_ parts of your bundle).\n\nLet's say you are building an application with an admin panel, you could use code splitting for the route/module that handles the admin panel and only load it if the user goes to an `/admin` route. Doing something like this will make the initial load and the initialization of the app faster, providing a better experience for the user.\n\n\n## How does it work?\n\nInstead of importing a file on the top of your file, you use `import` as a function and wait for a `Promise` with the module's content to be resolved.\n\nUsing the same example as above, here's some code to better understand it: You have a module that exports a function that will return a component for a given route:\n\n```js\nimport Home from './components/home';\nimport Admin from './components/admin';\n\nconst getComponentForRoute = (route) => {\n  switch(route) {\n  case '/admin':\n    return Admin;\n  default:\n    return Home;\n  }\n};\n\nexport default getComponentForRoute;\n```\n\nEasy enough, if the route is `/admin`, you return the admin panel component, which was imported at the top.\n\nLet's switch it a little bit in order to import the admin panel only when the user goes to `/admin`, thus, splitting it on different bundle:\n\n```js\nimport Home from './components/home';\n\nconst getComponentForRoute = (route) => {\n  switch(route) {\n  case '/admin':\n    return import('./components/admin');\n  default:\n    return Promise.resolve(Home);\n  }\n};\n\nexport default getComponentForRoute;\n```\n\nThere are 3 changes here:\n\n1. The `import` for the admin component is not longer on the top.\n2. The `case` for `/admin` now returns a call to the `import` function.\n3. The default `case` returns `Home` on an already resolved `Promise`.\n\nFirst and second go together: By using the `import` function instead of doing the regular `import` declaration, we tell the bundle engine that we don't need that file right now, but that it will be required later, so the engine will create a smaller bundle with that code.\n\nThird, why do we return `Home` on a `Promise`? Well, the `import` function returns a promise as the other bundle is loaded asynchronously, we should try to keep a consistent signature for the function, so the part of the app that implements it won't need to know whether the component was loaded from this bundle or a different one.\n\n## How to use it with projext\n\nAdding code splitting to your targets is really simple, you just need to define a `jsChunks` (_\"chunks\"_ are the smaller bundles with the code that will be lazy loaded) with a value of `true` on you target output settings:\n\n```js\n...\noutput: {\n  default: {\n    ...\n    jsChunks: true,\n  },\n  ...\n}\n```\n\nIn the example above, you define it on the `default` so both `production` and `development` will inherit it.\n\nThis will tell the bundle engine to use code splitting and that the chunks should be on the same directory as the main bundle and that the name format will be `[original-bundle-name].[chunk-name].js`.\n\nYou can also set `jsChunks` as a string and send a path and name format for your chunks:\n\n```js\n...\noutput: {\n  default: {\n    ...\n    jsChunks: 'statics/js/[target-name].[hash].[name].js',\n  },\n  ...\n}\n```\n\nThe special placeholder there is `[name]`, which will be replaced with the chunk name, decided by the bundle engine.\n\nThat's all, enable `jsChunks` and enjoy code splitting!\n\n> Currently, the webpack bundle engine will enable code splitting by default (you can even use the special `webpackChunkName` comment to set a name for it) but other engines still need the property in order to make it work. So, if you are using webpack as an engine, you can still enjoy zero configuration and take advantage of this feature.",
    "static": true,
    "access": "public"
  }
]